<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>算法总结 · 9Docs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">9Docs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">机器学习</span><ul><li><a class="tocitem" href="../../machine_learning/GNN/">图神经网络</a></li></ul></li><li><a class="tocitem" href="../../git/git_notebook/">Git 学习笔记</a></li><li><span class="tocitem">LeetCode 刷题</span><ul><li><a class="tocitem" href="../data_structure/">数据结构</a></li><li class="is-active"><a class="tocitem" href>算法总结</a><ul class="internal"><li><a class="tocitem" href="#排序算法"><span>排序算法</span></a></li><li><a class="tocitem" href="#拓扑排序"><span>拓扑排序</span></a></li><li><a class="tocitem" href="#二分查找（Binary-Search）"><span>二分查找（Binary Search）</span></a></li><li><a class="tocitem" href="#二叉树的遍历"><span>二叉树的遍历</span></a></li><li><a class="tocitem" href="#堆排序"><span>堆排序</span></a></li><li><a class="tocitem" href="#BF/RK-字符串匹配算法"><span>BF/RK 字符串匹配算法</span></a></li><li><a class="tocitem" href="#广度优先搜索（Breadth-First-Search）"><span>广度优先搜索（Breadth-First Search）</span></a></li><li><a class="tocitem" href="#深度优先搜索（Depth-First-Search）"><span>深度优先搜索（Depth-First Search）</span></a></li><li><a class="tocitem" href="#贪心算法（Greedy-Algorithm）"><span>贪心算法（Greedy Algorithm）</span></a></li><li><a class="tocitem" href="#分治算法（Divide-and-Conquer）"><span>分治算法（Divide and Conquer）</span></a></li><li><a class="tocitem" href="#回溯算法（Backtrack）"><span>回溯算法（Backtrack）</span></a></li><li><a class="tocitem" href="#动态规划（Dynamic-Programming）"><span>动态规划（Dynamic Programming）</span></a></li><li><a class="tocitem" href="#A*-算法"><span>A* 算法</span></a></li><li><a class="tocitem" href="#哈希算法"><span>哈希算法</span></a></li><li><a class="tocitem" href="#字符串匹配算法"><span>字符串匹配算法</span></a></li><li><a class="tocitem" href="#LeetCode-刷题总结"><span>LeetCode 刷题总结</span></a></li><li><a class="tocitem" href="#索引"><span>索引</span></a></li><li><a class="tocitem" href="#工程问题与算法题"><span>工程问题与算法题</span></a></li><li><a class="tocitem" href="#参考"><span>参考</span></a></li></ul></li><li><a class="tocitem" href="../leetcoding/">刷题记录</a></li></ul></li><li><a class="tocitem" href="../../product/product_manager/">产品</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">LeetCode 刷题</a></li><li class="is-active"><a href>算法总结</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>算法总结</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/strongnine/9Docs/blob/master/docs/src/leetcode/algorithm.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="算法总结"><a class="docs-heading-anchor" href="#算法总结">算法总结</a><a id="算法总结-1"></a><a class="docs-heading-anchor-permalink" href="#算法总结" title="Permalink"></a></h1><h2 id="排序算法"><a class="docs-heading-anchor" href="#排序算法">排序算法</a><a id="排序算法-1"></a><a class="docs-heading-anchor-permalink" href="#排序算法" title="Permalink"></a></h2><p>用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。假设有 <span>$n$</span> 个数据，要从小到大排列，完全有序的数据的有序度就是 <span>$n(n-1)/2$</span>，逆序度就是 0. </p><h3 id="归并排序（Merge-Sort）"><a class="docs-heading-anchor" href="#归并排序（Merge-Sort）">归并排序（Merge Sort）</a><a id="归并排序（Merge-Sort）-1"></a><a class="docs-heading-anchor-permalink" href="#归并排序（Merge-Sort）" title="Permalink"></a></h3><p>核心思想：先把数值从中间分成前后两个部分，然后对前后两个部分分别排序，再将排好的两个部分合并在一起，这样整个数组就都有序了。归并排序可以用递归的方式来实现，写递归代码的技巧：</p><ul><li>分析得出递推公式；</li><li>找到终止条件；</li><li>将递推公式翻译成递归代码；</li></ul><p>我根据王争老师的的课程<a href="http://gk.link/a/11bHN">《数据结构与算法之美》第 12 讲</a>中给的伪代码，翻译出了一个 Python 版本的：</p><pre><code class="language-python hljs"># 递推公式：
# merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+1...r))
# 
# 终止条件：
# p &gt;= r 不用再继续分解

# 归并排序算法，A 是数组，n 表示数组大小
def merge_sort(A, n):
    return merge_sort_c(A, 0, n-1)

# 递归调用函数
def merge_sort_c(A, p, r):
    # 递归终止条件
    if p &gt;= r:
        return
    # 取 p 到 r 之间的中间位置 q
    q = p + (r - p) / 2
    # 分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)
    # 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
    merge(A[p...r], A[p...q], A[q+1...r])
    
# 将已经有序的两个子数组合并成一个新的有序数值的函数
def merge(A[p...r], A[p...q], A[q+1...r]):
    i, j, k = p, q+1, 0  # 初始化变量 i, j, k
    tmp = [0 for _ in range(len(A))]  # 申请一个大小跟 A[p...r] 一样的临时数组
    while (i &lt;= q) and (j &lt;= r):
        if A[i] &lt;= A[j]:
            tmp[k] = A[i]
            i += 1
        else:
            tmp[k] = A[j]
            j += 1
        k += 1
        
    # 判断哪个子数组中有剩余的数据
    start, end = i, q
    if j &lt;= r:
        start, end = j, r
    
    # 将剩余的数据拷贝到临时数组 tmp
    while start &lt;= end:
        tmp[k] = A[start]
        k += 1
        start += 1
    
    # 将 tmp 中的数组拷贝回 A[p...r]
    for i in range(r-p):
        A[p+i] = tmp[i]</code></pre><blockquote><p>之后会思考一下，如何使用「哨兵」来简化 merge() 函数的编程</p></blockquote><p><strong>性能分析</strong>：</p><ul><li>归并排序稳不稳定取决于 <code>merge()</code> 函数的实现；</li><li>时间复杂度：<span>$\mathcal{O}(n\log n)$</span>；</li><li>空间复杂度：<span>$\mathcal{O}(n)$</span>；</li></ul><h2 id="拓扑排序"><a class="docs-heading-anchor" href="#拓扑排序">拓扑排序</a><a id="拓扑排序-1"></a><a class="docs-heading-anchor-permalink" href="#拓扑排序" title="Permalink"></a></h2><h2 id="二分查找（Binary-Search）"><a class="docs-heading-anchor" href="#二分查找（Binary-Search）">二分查找（Binary Search）</a><a id="二分查找（Binary-Search）-1"></a><a class="docs-heading-anchor-permalink" href="#二分查找（Binary-Search）" title="Permalink"></a></h2><p>王争老师的二分查找循环写法：</p><pre><code class="language-c hljs">int bsearch(vector&lt;int&gt; a, int n, int value) {
    int low = 0;
    int high = n - 1;
    
    while (low &lt;= high) {
        int mid = low + (hight - low) / 2;
        if (a[mid] == value) {
            return mid;
        } else if (a[mid] &lt; value) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    return -1;
}</code></pre><p>递归写法：</p><pre><code class="language-c hljs">int bsearch(vector&lt;int&gt; a, int n, int val) {
    return bsearchInternally(a, 0, n - 1, val);
}

int bsearchInternally(vector&lt;int&gt;, int low, int high, int value) {
    if (low &gt; high) return -1;
    
    int mid = low + ((high - low) &gt;&gt; 1);
    if (a[mid] == value) {
        return mid;
    } else if (a[mid] &lt; value) {
        return bsearchInternally(a, mid+1, high, value);
    } else {
        return bsearchInternally(a, low, mid-1, value);
    }
}</code></pre><blockquote><p>liweiwei 的版本下，循环条件是 <code>left &lt; right</code>，他的写法中，退出循环时一定有 <code>left == right</code> 成立。</p></blockquote><p>二分查找的时间复杂度是 <span>$\mathcal{O}(\log n)$</span>，查找数据的效率非常高。</p><p>二分查找的局限性：</p><ul><li>依赖顺序表结构，也就是数组；</li><li>只针对有序数据。如果是对于静态数据（没有频繁插入和删除），可以用一次排序，多次二分查找，来均摊排序的成本；</li><li>数据量太小不适合二分查找；</li><li>数据量太大也不适合用二分。主要原因在于二分查找依赖于数组，而数组需要的是连续的内存空间，如果数组太大，难以找到连续的内存空间；</li></ul><p>二分查找的原理及其简单，但是想要写出没有 Bug 的二分查找并不容易。</p><blockquote><p>尽管第一个二分查找算法在 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。</p><p>—— 《计算机程序设计艺术》唐纳德 • 克努特（Donald E.Knuth）</p></blockquote><p>4 种常见二分查找变形问题：</p><ul><li>查找第一个值等于给定值的元素；</li><li>查找最后一个值等于给定值的元素；</li><li>查找第一个大于等于给定值的元素；</li><li>查找最后一个小于等于给定值的元素；</li></ul><p><strong>变体一：查找第一个值等于给定值的元素</strong></p><pre><code class="language-c hljs">int bsearch(vector&lt;int&gt; a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt; value) {
            high = mid - 1;
        } else if (a[mid] &lt; value) {
            low = mid + 1;
        } else {
            if ((mid == 0) || (a[mid - 1] != value)) return mid;    // 第 11 行
            else high = mid - 1;
        }
    }
    return -1;
}</code></pre><p>关键是第 11 行代码：</p><ul><li>如果 <code>mid == 0</code>，那这个元素是第一个元素，肯定是我们要找的；</li><li>如果 <code>mid != 0</code> 并且前面一个元素 <code>a[mid-1]</code> 不等于要找的值 <code>value</code>，那这个元素就是我们要找的；</li><li>如果 <code>a[mid]</code> 前面的元素也是 value，那么此时的 <code>a[mid]</code> 肯定不是第一个等于给定值 <code>value</code> 的元素，让 <code>high = mid - 1</code>；</li></ul><p><strong>变体二：查找最后一个值等于给定值的元素</strong></p><pre><code class="language-c hljs">int bsearch(vector&lt;int&gt; a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt; value) {
            high = mid - 1;
        } else if (a[mid] &lt; value) {
            low = mid + 1;
        } else {
            if ((mid == n - 1) || (a[mid + 1] != value)) return mid;  // 第 11 行
            else low = mid + 1;
        }
    }
    return -1;
}</code></pre><p>关键是第 11 行代码：</p><ul><li>如果 <code>a[mid]</code> 是数组中的最后一个元素，那肯定是要找的值；</li><li>如果 <code>a[mid]</code> 的最后一个元素 <code>a[mid+1]</code> 不等于 <code>value</code>，那也说明是要找的最后一个值等于给定值的元素；</li><li>如果发现 <code>a[mid]</code> 的后面一个元素 <code>a[mid+1]</code> 也等于 <code>value</code>，说明当前的 <code>a[mid]</code> 并不是最后一个值等于给定值的元素，更新 <code>low = mid + 1</code>；</li></ul><p><strong>变体三：查找第一个大于等于给定值的元素</strong></p><pre><code class="language-c hljs">int bsearch(vector&lt;int&gt; a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt;= value) {
            if ((mid == 0) || (a[mid - 1] &lt; value)) return mid;  // 第 7 行
            else high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}</code></pre><p>如果 <code>a[mid]</code> 小于给定的值 <code>value</code>，那要查找的值肯定在 <code>[mid+1, high]</code> 之间，所以更新 <code>low = mid + 1</code>；</p><p>对于第 7 行代码，如果 <code>a[mid]</code> 大于等于给定值 <code>value</code>：</p><ul><li>如果 <code>a[mid]</code> 为第一个元素，或者前面一个元素小于要查找的值 <code>value</code>，那 <code>a[mid]</code> 就是我们要找的元素；</li><li>如果 <code>a[mid-1]</code> 也大于等于要查找的值 <code>value</code>，那么说明要查找的元素在 <code>[low, mid-1]</code> 之间，更新 <code>high = mid - 1</code>；</li></ul><p><strong>变体四：查找最后一个小于等于给定值的元素</strong></p><pre><code class="language-c hljs">int bsearch(vector&lt;int&gt; a, int n, int value) {
    int low = 0;
    int high = n - 1;
    while (low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt; value) {
            high = mid - 1;
        } else {
            if ((mid == n - 1) || (a[mid + 1] &gt; value)) return mid;  // 第 9 行
            else low = mid + 1;
        }
    }
    return -1;
}</code></pre><p>如果 <code>a[mid]</code> 大于给定的值 <code>value</code>，那么要查找的值肯定在区间 <code>[low, mid-1]</code> 之间，所以更新 <code>high = mid - 1</code>；</p><p>对于第 9 行代码，如果 <code>a[mid]</code> 小于等于给定的值：</p><ul><li>如果 <code>a[mid]</code> 为最后一个元素，或者其后面一个元素大于要查找的值 <code>value</code>，那么其肯定是要找的元素；</li><li>如果 <code>a[mid+1</code> 也小于等于要查找的值，那么说明要查找的元素在 <code>[low, mid+1]</code> 之间，更新 <code>low = mid + 1</code>；</li></ul><h2 id="二叉树的遍历"><a class="docs-heading-anchor" href="#二叉树的遍历">二叉树的遍历</a><a id="二叉树的遍历-1"></a><a class="docs-heading-anchor-permalink" href="#二叉树的遍历" title="Permalink"></a></h2><p>实际上，二叉树的前、中、后序遍历就是一个递归过程。写递归代码的关键，就是写出递推公式。写递归公式的关键，就是如果要解决问题 A，就假设问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。</p><pre><code class="language-c hljs">// 前序遍历的递推公式：
preOrder(r) = print r =&gt; preOrder(r-&gt;left) =&gt; preOrder(r-&gt;right);

// 中序遍历的递推公式：
inOrder(r) = inOrder(r-&gt;left) =&gt; print r =&gt; inOrder(r-&gt;right);

// 后序遍历的递推公式：
postOrder(r) = postOrder(r-&gt;left) =&gt; postOrder(r-&gt;right) =&gt; print r;</code></pre><p>根据递推公式，可以写出三种遍历方式的伪代码：</p><pre><code class="language-c hljs">// 前序遍历
void preOrder(TreeNode* root) {
  if (root == nullptr) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root-&gt;left);
  preOrder(root-&gt;right);
}

// 中序遍历
void inOrder(TreeNode* root) {
  if (root == nullptr) return;
  inOrder(root-&gt;left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root-&gt;right);
}

// 后序遍历
void postOrder(TreeNode* root) {
  if (root == nullptr) return;
  postOrder(root-&gt;left);
  postOrder(root-&gt;right);
  print root // 此处为伪代码，表示打印 root 节点
}</code></pre><p>由于每个节点最多会被访问两次，所以前中后序遍历的时间复杂度为 <span>$\mathcal{O}(n)$</span>。</p><h2 id="堆排序"><a class="docs-heading-anchor" href="#堆排序">堆排序</a><a id="堆排序-1"></a><a class="docs-heading-anchor-permalink" href="#堆排序" title="Permalink"></a></h2><h2 id="BF/RK-字符串匹配算法"><a class="docs-heading-anchor" href="#BF/RK-字符串匹配算法">BF/RK 字符串匹配算法</a><a id="BF/RK-字符串匹配算法-1"></a><a class="docs-heading-anchor-permalink" href="#BF/RK-字符串匹配算法" title="Permalink"></a></h2><h2 id="广度优先搜索（Breadth-First-Search）"><a class="docs-heading-anchor" href="#广度优先搜索（Breadth-First-Search）">广度优先搜索（Breadth-First Search）</a><a id="广度优先搜索（Breadth-First-Search）-1"></a><a class="docs-heading-anchor-permalink" href="#广度优先搜索（Breadth-First-Search）" title="Permalink"></a></h2><p>广度优先搜索有三个重要的辅助变量：</p><ul><li><code>visited</code> 用来记录顶点是否被访问了，避免顶点被重复访问；</li><li><code>queue</code> 队列，用来存储已经访问，但相连的顶点还没有被访问的顶点；</li><li><code>prev</code> 用来记录搜索路径。例如 <code>prev[w]</code> 存储的是，顶点 <code>w</code> 是从哪个前驱顶点遍历过来的。所以为了正向打印出路径，需要递归地进行。</li></ul><p>广度优先搜索 C++ 模板：</p><pre><code class="language-c hljs">private:
	static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

public:
	vector&lt;vector&lt;int&gt;&gt; BFS(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int m = matrix.size(), n = matrix[0].size(0);
        vector&lt;vector&lt;int&gt;&gt; seen(m, vector&lt;int&gt;(n));
        queue&lt;pair&lt;int, int&gt;&gt; q;

        // 广度优先搜索
        while (!q.empty()) {
            auto [i, j] = q.front();
            q.pop();
			for (int d = 0; d &lt; 4; ++d) {
                int ni = i + dirs[d][0];
                int nj = j + dirs[d][1];
                if (ni &gt;= 0 &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; n &amp;&amp; !seen[ni][nj]) {
                    // ...;	// 写某些具体的操作
                    q.emplace(ni, nj);
                    seen[ni][nj] = 1;
                }
            }
        }
        return ...;			// 返回结果
    }
</code></pre><p>Python3 模板</p><pre><code class="language-python hljs">def BFS(self, matrix: List[List[int]]) -&gt; ...:
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    m, n = len(matrix), len(matrix[0])
    q = collections.deque(...);		# 队列
    seen = set(...)					# 将见过的位置坐标放进集合里面
    
    while q:
        i, j = q.popleft()
        for d in range(4):
            ni = i + dirs[d][0]
            nj = j + dirs[d][1]
            if (0 &lt;= ni &lt; m) and (0 &lt;= nj &lt; n) and ((ni, nj) not in seen):
                # ...				# 写某些具体操作
                q.append((ni, nj))
                seen.add((ni, nj))
    return ...						# 返回结果 </code></pre><p>时间复杂度：<span>$\mathcal{O}(V+E)$</span>，空间复杂度：<span>$\mathcal{O}(V)$</span>；<span>$V, E$</span> 分别为有向图顶点和边的个数。</p><h2 id="深度优先搜索（Depth-First-Search）"><a class="docs-heading-anchor" href="#深度优先搜索（Depth-First-Search）">深度优先搜索（Depth-First Search）</a><a id="深度优先搜索（Depth-First-Search）-1"></a><a class="docs-heading-anchor-permalink" href="#深度优先搜索（Depth-First-Search）" title="Permalink"></a></h2><p>深度优先搜索（DFS），最直观的例子就是「走迷宫」。</p><p>C++ 深度优先搜索的框架</p><pre><code class="language-c hljs">vector&lt;int&gt; temp;
void dfs(int cur, int n) {
    if (cur == n + 1) {
        // 记录答案
        // ...
        return;
    }
    // 考虑选择当前位置
    temp.push_back(cur);
    dfs(cur + 1, n, k);
    temp.pop_back();
    // 考虑不选择当前位置
    dfs(cur + 1, n, k);
}</code></pre><p>时间复杂度：<span>$\mathcal{O}(E)$</span>，空间复杂度：<span>$\mathcal{O}(V)$</span>；<span>$V, E$</span> 分别为有向图顶点和边的个数。</p><h2 id="贪心算法（Greedy-Algorithm）"><a class="docs-heading-anchor" href="#贪心算法（Greedy-Algorithm）">贪心算法（Greedy Algorithm）</a><a id="贪心算法（Greedy-Algorithm）-1"></a><a class="docs-heading-anchor-permalink" href="#贪心算法（Greedy-Algorithm）" title="Permalink"></a></h2><p>贪心算法的解题步骤：</p><ul><li><strong>贪心算法适用的问题</strong>：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大；</li><li><strong>初步尝试</strong>：选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据；</li><li><strong>举例子</strong>：检查贪心算法产生的结果是否最优。因为贪心贪心算法并不总能够给出最优解；</li></ul><blockquote><p>王争：掌握贪心算法的关键是<strong>多练习</strong>。不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p></blockquote><p>以下具体例子，应该可以帮助自己去理解贪心算法：</p><p><strong>1. 分糖果</strong>：有 <span>$m$</span> 个糖果和 <span>$n$</span> 个孩子（孩子比糖果多（<span>$m&lt;n$</span>），要把糖果分配给孩子。糖果有大小之分，并且每个孩子对于糖果大小的需求是不一样的，如何分配才能够尽可能地满足最多数量的孩子？</p><p><strong>2. 钱币找零</strong>：纸币面值有 1、2、5、10、20、50、100 元的，每种面值的纸币有张数限制，如何用最少张的纸币去支付 <span>$K$</span> 元？</p><blockquote><p>用户「开心小毛」留言：</p><p>找零问题不能用贪婪算法，即使有面值为 1 元的币值也不行：考虑币值为 100，99 和 1 的币种，每种各 100 张，找 396 元。动态规划可求出 4 张 99 元，但贪心算法解出需 3 张 100 和 96 张 1 元。</p><p><a href="https://leetcode-cn.com/problems/coin-change/">LeetCode 322. 零钱兑换</a></p></blockquote><p><strong>3. 区间覆盖</strong>：有 <span>$n$</span> 个区间，起始端点和结束端点分别为 <span>$[l_1,r_1], [l_2, r_2],\dots$</span>，选出两两不相交的区间，最多可以选出多少个？</p><h3 id="霍夫曼编码（Huffman-Coding）"><a class="docs-heading-anchor" href="#霍夫曼编码（Huffman-Coding）">霍夫曼编码（Huffman Coding）</a><a id="霍夫曼编码（Huffman-Coding）-1"></a><a class="docs-heading-anchor-permalink" href="#霍夫曼编码（Huffman-Coding）" title="Permalink"></a></h3><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中。压缩率通常在 20% ~ 90% 之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率。出现频率较多的字符，用稍微短一些的编码，出现频率少的，用稍微长一点的编码。</p><p><strong>问题</strong>：假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1 byte = 8 bits），存储这 1000 个字符就需要 8000 biits，如何对这些数据进行压缩？</p><p>假设文件中只有 6 个字符 a、b、c、d、e、f，并且出现频率从高到低排序。可以将其编码为</p><table><tr><th style="text-align: center">字符</th><th style="text-align: center">出现频率</th><th style="text-align: center">编码</th><th style="text-align: center">总二进制位数</th></tr><tr><td style="text-align: center">a</td><td style="text-align: center">450</td><td style="text-align: center">1</td><td style="text-align: center">450</td></tr><tr><td style="text-align: center">b</td><td style="text-align: center">350</td><td style="text-align: center">01</td><td style="text-align: center">700</td></tr><tr><td style="text-align: center">c</td><td style="text-align: center">90</td><td style="text-align: center">001</td><td style="text-align: center">270</td></tr><tr><td style="text-align: center">d</td><td style="text-align: center">60</td><td style="text-align: center">0001</td><td style="text-align: center">240</td></tr><tr><td style="text-align: center">e</td><td style="text-align: center">30</td><td style="text-align: center">00001</td><td style="text-align: center">150</td></tr><tr><td style="text-align: center">f</td><td style="text-align: center">20</td><td style="text-align: center">00000</td><td style="text-align: center">100</td></tr></table><p>这样一来，任何字符的编码都不会是另一个的<strong>前缀</strong>，在解压缩的时候，读取尽可能长的可解压二进制串。经过这种编码之后，这 1000 个字符只需要 1910 bits 就可以了，压缩率 73.75%。</p><p>问题是，如何根据字符出现频率的不同，给不同的字符进行不同长度的编码，才能不混淆不同的字符？方法如下：</p><p>把每个字符看做一个节点，并且把频率也放到优先队列当中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p>王争老师的课程<a href="http://gk.link/a/11bwH">《数据结构与算法之美》第 37 讲</a>中有一张图片，结合图片去看就很好理解了。</p><p><img src="https://static001.geekbang.org/resource/image/7b/7a/7b6a08e7df45eac66820b959c64f877a.jpg" alt="huffman_coding_queue"/></p><h3 id="Prim-和-Kruskal-最小生成树算法"><a class="docs-heading-anchor" href="#Prim-和-Kruskal-最小生成树算法">Prim 和 Kruskal 最小生成树算法</a><a id="Prim-和-Kruskal-最小生成树算法-1"></a><a class="docs-heading-anchor-permalink" href="#Prim-和-Kruskal-最小生成树算法" title="Permalink"></a></h3><h3 id="Dijkstra-单源最短路径算法"><a class="docs-heading-anchor" href="#Dijkstra-单源最短路径算法">Dijkstra 单源最短路径算法</a><a id="Dijkstra-单源最短路径算法-1"></a><a class="docs-heading-anchor-permalink" href="#Dijkstra-单源最短路径算法" title="Permalink"></a></h3><h2 id="分治算法（Divide-and-Conquer）"><a class="docs-heading-anchor" href="#分治算法（Divide-and-Conquer）">分治算法（Divide and Conquer）</a><a id="分治算法（Divide-and-Conquer）-1"></a><a class="docs-heading-anchor-permalink" href="#分治算法（Divide-and-Conquer）" title="Permalink"></a></h2><blockquote><p>MapReduce、GFS 和 Bigtable 是 Google 大数据处理的三驾马车。</p></blockquote><p>分治算法是一种处理问题的思想，递归是一种编程技巧，这就是分治和递归的区别所在。分治算法的核心思想：分而治之。分治算法的递归实现中，每一层递归都会涉及这三个操作：</p><ul><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，直到子问题足够小到可以直接求解；</li><li>合并：将子问题的结果合并成原问题；</li></ul><p>能够用分治算法解决的问题，需要满足：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性；</li><li>具有分解终止条件 —— 有足够小到可以直接求解的子问题；</li><li>子问题合并成原问题的操作复杂度不能太高；</li></ul><p>分治算法的应用：</p><ul><li>对于海量数据的情况（数据量远远大于内存的大小），可以用分治的思路，用多线程或者多机处理，加快处理速度；</li></ul><p><strong>问题</strong>：如何编程求出一组数据的有序对个数或者逆序对个数？</p><p>利用<a href="https://strongnine.github.io/9Docs/dev/leetcode/algorithm/#.-分治算法（Divide-and-Conquer）">归并排序</a>算法，将两个有序的小数组，合并成一个有序的数组，同时计算逆序对个数。</p><blockquote><p>王争老师的课程<a href="http://gk.link/a/11bHy">《数据结构与算法之美》第 38 讲</a>有相关代码可供参考。</p></blockquote><p><strong>MapReduce 的本质就是分治</strong>：其框架只是一个人物调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳，就重新从 Borg 中调度一台机器执行。</p><h2 id="回溯算法（Backtrack）"><a class="docs-heading-anchor" href="#回溯算法（Backtrack）">回溯算法（Backtrack）</a><a id="回溯算法（Backtrack）-1"></a><a class="docs-heading-anchor-permalink" href="#回溯算法（Backtrack）" title="Permalink"></a></h2><p><strong>0 - 1 背包</strong>：</p><pre><code class="language-c hljs">// 0 - 1 背包的回溯算法实现
vector&lt;int&gt; weight = {2, 2, 4, 6, 3};   //	物品重量
int w = 9;      // 	背包承受的最大重量
int maxW = INT_MIN;
void f(int i, int cw, int w) {  // 调用 f(0, 0)
    int n = weight.size()
    if (cw == w || i == n) {  // cw == c 表示装满了，i == n 表示物品都考察完了
        if (cw &gt; maxW) {
            maxW = cw;
            return maxW;
        }
    }
    f(i + 1, cw, w);  // 选择不装第 i 个物品
    if (cw + weight[i] &lt;= w) {
        f(i + 1, cw + weight[i], w);  // 选择装第 i 个物品
    }
}</code></pre><p>这种写法的时间复杂度很高，可以使用「备忘录」来记录所有已经计算过的值，再次要用到的时候，就直接拿出来。</p><pre><code class="language-c hljs">vector&lt;int&gt; weight = {2, 2, 4, 6, 3};     // 物品重量
int w = 9;
int maxW = INT_MIN;
vector&lt;vector&lt;int&gt;&gt; mem(n, vector&lt;int&gt;(w + 1));
void f(int i, int cw, int w) {
    int n = weight.size()
    if (cw == w || i == n) {
        if (cw &gt; maxW) {
            maxW = cw;
            return;
        }
    }
    if (mem[i][cw]) {return;}  //  重复状态
    mem[i][cw] = true;   // 记录 (i, cw) 这个状态
    f(i + 1, cw);        // 选择不装第 i 个物品
    if (cw + weight[i] &lt;= w) {
        f(i + 1, cw + weight[i]);  // 选择装第 i 个物品
    }
}</code></pre><p>加了「备忘录」的方法跟动态规划的执行效率已经基本没有差别。</p><p>适用问题：</p><ul><li>解决一个问题有多个步骤</li><li>每个步骤有多种方法</li><li>需要找出所有的方法</li></ul><p>原理：在一棵树上的<strong>深度优先遍历</strong></p><h2 id="动态规划（Dynamic-Programming）"><a class="docs-heading-anchor" href="#动态规划（Dynamic-Programming）">动态规划（Dynamic Programming）</a><a id="动态规划（Dynamic-Programming）-1"></a><a class="docs-heading-anchor-permalink" href="#动态规划（Dynamic-Programming）" title="Permalink"></a></h2><p>把问题分解为多个阶段，每个阶段对应一个决策。记录每一个阶段可达的状态合集（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p><p><strong>0 - 1 背包问题</strong>：对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少？</p><p>用一个二维数组 <code>state[n][w+1]</code> 来记录每个物品决策完可以到达的状态。</p><pre><code class="language-c hljs">// weight: 物品重量，n: 物品个数，w: 背包可承载重量
int knapsack(vector&lt;int&gt; weight, int n, int w) {
    vector&lt;vector&lt;int&gt;&gt; states(n, vector&lt;int&gt;(w + 1)); // 默认值 0
    states[0][0] = 1;  // 第一行的数据要特殊处理，可以利用哨兵优化
    if (weight[0] &lt;= w) {
        states[0][weight[0]] = 1;
    }
    for (int i = 1; i &lt; n; ++i) {  // 动态规划状态转移
        for (int j = 0; j &lt;= w; ++j) {  // 不把第 i 个物品放入背包
            if (states[i - 1][j] == 1) {states[i][j] = states[i - 1][j]};
        }
        for (int j = 0; j &lt;= w - weight[i]; ++j) {  // 把第 i 个物品放入背包
          if (states[i - 1][j] == 1) {states[i][j + weight[i]] = 1;}  
        }
    }
    for (int i = w; i &gt;= 0; --i) {  // 输出结果
        if (states[n - 1][i] == 1) {return i;}
    }
    return 0;
}</code></pre><p>一般来说动态规划是一种空间换时间的方法。</p><h2 id="A*-算法"><a class="docs-heading-anchor" href="#A*-算法">A* 算法</a><a id="A*-算法-1"></a><a class="docs-heading-anchor-permalink" href="#A*-算法" title="Permalink"></a></h2><h2 id="哈希算法"><a class="docs-heading-anchor" href="#哈希算法">哈希算法</a><a id="哈希算法-1"></a><a class="docs-heading-anchor-permalink" href="#哈希算法" title="Permalink"></a></h2><h2 id="字符串匹配算法"><a class="docs-heading-anchor" href="#字符串匹配算法">字符串匹配算法</a><a id="字符串匹配算法-1"></a><a class="docs-heading-anchor-permalink" href="#字符串匹配算法" title="Permalink"></a></h2><p>字符串匹配算法中 BM、KMP、AC 自动机都是比较难懂的算法，对于算法有一定基础的人来说，想要看懂也不容易。要求是能够看懂就好，不要求自己能够实现。</p><h3 id="Trie-树"><a class="docs-heading-anchor" href="#Trie-树">Trie 树</a><a id="Trie-树-1"></a><a class="docs-heading-anchor-permalink" href="#Trie-树" title="Permalink"></a></h3><p>面试官喜欢考 Trie，但是要求能够看懂，会结合应用场景来考，考察的是面试者知道啥时候要用 Trie 树。</p><h3 id="BM"><a class="docs-heading-anchor" href="#BM">BM</a><a id="BM-1"></a><a class="docs-heading-anchor-permalink" href="#BM" title="Permalink"></a></h3><h3 id="KMP"><a class="docs-heading-anchor" href="#KMP">KMP</a><a id="KMP-1"></a><a class="docs-heading-anchor-permalink" href="#KMP" title="Permalink"></a></h3><h3 id="AC-自动机"><a class="docs-heading-anchor" href="#AC-自动机">AC 自动机</a><a id="AC-自动机-1"></a><a class="docs-heading-anchor-permalink" href="#AC-自动机" title="Permalink"></a></h3><h2 id="LeetCode-刷题总结"><a class="docs-heading-anchor" href="#LeetCode-刷题总结">LeetCode 刷题总结</a><a id="LeetCode-刷题总结-1"></a><a class="docs-heading-anchor-permalink" href="#LeetCode-刷题总结" title="Permalink"></a></h2><h3 id="最高有效位"><a class="docs-heading-anchor" href="#最高有效位">最高有效位</a><a id="最高有效位-1"></a><a class="docs-heading-anchor-permalink" href="#最高有效位" title="Permalink"></a></h3><p>如果正整数 <span>$y$</span> 是 2 的整数次幂，则 <span>$y$</span> 的二进制表示中只有最高位为 1，其余都是 0，因此 <span>$y\&amp; (y-1)=0$</span>. 如果 <span>$y\le x$</span>，则称 <span>$y$</span> 为 <span>$x$</span> 的「最高有效位」。</p><p>题目 <a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a> 利用这样的一个方式，动态地维护最高有效位 <code>highBit</code>，然后算出所有小于给定整数 <span>$n$</span> 的整数二进制表示包含 1 的数量。</p><h3 id="最低有效位"><a class="docs-heading-anchor" href="#最低有效位">最低有效位</a><a id="最低有效位-1"></a><a class="docs-heading-anchor-permalink" href="#最低有效位" title="Permalink"></a></h3><p>对于正整数 <span>$x$</span>，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 <span>$\lfloor\frac{x}{2}\rfloor$</span>，如果 <span>$bits[\lfloor\frac{x}{2}\rfloor]$</span> 的值已知，则可以得到 <span>$bits[x]$</span> 的值：</p><ul><li>如果 <span>$x$</span> 是偶数，则 <span>$bits[x]=bits[\lfloor\frac{x}{2}\rfloor]$</span>；</li><li>如果 <span>$x$</span> 是奇数，则 <span>$bits[x] = bits[\lfloor\frac{x}{2}\rfloor]+1$</span>.</li></ul><p>上述两种情况可以合并成：<span>$bits[x] $ 的值等于 $bits[\lfloor\frac{x}{2}\rfloor]$</span> 的值加上 <span>$x$</span> 除以 2 的余数。</p><p>由于 <span>$\lfloor\frac{x}{2}\rfloor$</span> 可以通过 <span>$x\gg1$</span> 得到，<span>$x$</span> 除以 2 的余数可以通过 <span>$x \&amp; 1$</span> 得到，因此有：<span>$bits[x]=bits[x\gg1]+(x\&amp;1)$</span>.</p><p>题目 <a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a> 利用最低有效位，遍历从 1 到 <span>$n$</span> 的每个正整数 <span>$i$</span>，计算 <span>$bits$</span> 的值，最终得到的数组 <span>$bits$</span> 即为答案。</p><h3 id="Brian-Kernighan-算法"><a class="docs-heading-anchor" href="#Brian-Kernighan-算法">Brian Kernighan 算法</a><a id="Brian-Kernighan-算法-1"></a><a class="docs-heading-anchor-permalink" href="#Brian-Kernighan-算法" title="Permalink"></a></h3><p>记 <span>$f(x)$</span> 表示 <span>$x$</span> 和 <span>$x-1$</span> 进行「与」运算所得的结果（即 <span>$f(x)=x\&amp;(x−1)$</span>），那么 <span>$f(x)$</span> 恰为 <span>$x$</span> 删去其二进制表示中最右侧的 1 的结果。参考 LeetCode 题目 <a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a>。</p><p>例如 <span>$x=10001000$</span>，<span>$x-1=10000111$</span>，那么 <span>$x\&amp;(x-1)=10000000$</span>. </p><p>利用 Brian kernighan 算法计算出一个数的二进制表示有多少个 1 的方法如下。不断让 <span>$s=f(s)$</span>，直到 <span>$s=0$</span>。每循环一次 <span>$s$</span> 都会删除二进制表示中最右侧的 1，最终的循环次数即为 <span>$s$</span> 二进制表示中的 1 的数量。</p><h2 id="索引"><a class="docs-heading-anchor" href="#索引">索引</a><a id="索引-1"></a><a class="docs-heading-anchor-permalink" href="#索引" title="Permalink"></a></h2><p>软件开发中，抛开业务和功能的外壳，本质都可以抽象为「对数据的存储和计算」，「存储」需要的就是数据结构，「计算」需要的就是算法。<strong>索引</strong>设计得好，可以节省存储空间、提高数据的处理效率。</p><p>索引的需求定义：</p><ul><li>功能性需求：<ul><li><strong>数据是格式化数据还是非格式化数据。</strong>MySQL 中的是结构化数据，搜索引擎中的网页是非结构化数据；</li><li><strong>数据是静态数据还是动态数据。</strong>静态数据不会有数据的增加、删除、更新操作；</li><li><strong>索引存储在内存还是硬盘。</strong>数据在内存上的查询速度比在磁盘中的快；</li><li><strong>单值查找还是区间查找。</strong>有一些数据结构不支持区间查找；</li><li><strong>单关键词查找还是多关键词组合查找。</strong>可以通过集合操作（并交集）来得到多关键词查询；</li></ul></li><li>非功能性需求<ul><li><strong>无论是那种存储方式，索引对存储空间的消耗不能太大</strong>；</li><li><strong>在考虑索引查询效率的同时，还要考虑索引的维护成本。</strong>对原始数据的增删改时，也要维护索引；</li></ul></li></ul><p>构建索引常用的数据结构：</p><ul><li>散列表：增删改查操作的性能好，具有 <span>$\mathcal{O}(1)$</span> 的时间复杂度。例如 Redis、Memcache 等键值数据库；</li><li>红黑树：具有 <span>$\mathcal{O}(\log n)$</span> 的时间复杂度。例如 Ext 文件系统中对磁盘块的索引；</li><li>B+ 树： </li></ul><h2 id="工程问题与算法题"><a class="docs-heading-anchor" href="#工程问题与算法题">工程问题与算法题</a><a id="工程问题与算法题-1"></a><a class="docs-heading-anchor-permalink" href="#工程问题与算法题" title="Permalink"></a></h2><p>工程上的问题比较开放，需要综合各种因素去选择数据结构和算法。我们要考虑到的可能有编码难度、维护成本、数据特征、数据规模等，只有最合适的方法，没有最好的方法。而算法题的背景、条件、限制都十分明确，只需要在规定的输入、输出下找到最优解就好了。</p><p>关于合理地选择使用哪种数据结构和算法，王争老师在极客时间上的课程《数据结构与算法之美》<span>$^{[1]}$</span>中总结了六条经验：</p><ol><li><strong>时间、空间复杂度不能跟性能划等号</strong>；<ul><li>复杂度不是执行时间和内存消耗的精确值；</li><li>代码的执行时间有时不跟时间复杂度成正比【大 <span>$\mathcal{O}$</span> 表示法有效的前提是在处理大规模数据的情况下才成立】；</li><li>对于处理不同问题的不同算法，其复杂度大小没有可比性；</li></ul></li><li><strong>抛开数据规模谈数据结构和算法都是「耍流氓」</strong>；</li><li><strong>结合数据特征和访问方式来选择数据结构。</strong>如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式，这才是解决问题的重点；</li><li><strong>区别对待 IO 密集、内存密集和计算密集</strong>；</li><li><strong>善用语言提供的类，避免重复造轮子</strong>；</li><li><strong>千万不要漫无目的地过度优化。</strong>要优化代码的时候，要先做 Benchmark 基准测试，避免想当然地换了更高效的算法，但是实际上性能是下降了的；</li></ol><h2 id="参考"><a class="docs-heading-anchor" href="#参考">参考</a><a id="参考-1"></a><a class="docs-heading-anchor-permalink" href="#参考" title="Permalink"></a></h2><p>[1] <a href="http://gk.link/a/11bwG">《数据结构与算法之美》王争｜极客时间</a></p><p>[2] <a href="https://leetcode-cn.com/u/leetcode-solution/">LeetCode 官方题解</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structure/">« 数据结构</a><a class="docs-footer-nextpage" href="../leetcoding/">刷题记录 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 23 February 2022 08:57">Wednesday 23 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
