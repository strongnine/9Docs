<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · 9Docs</title><meta name="title" content="- · 9Docs"/><meta property="og:title" content="- · 9Docs"/><meta property="twitter:title" content="- · 9Docs"/><meta name="description" content="Documentation for 9Docs."/><meta property="og:description" content="Documentation for 9Docs."/><meta property="twitter:description" content="Documentation for 9Docs."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">9Docs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">深度学习</span><ul><li><a class="tocitem" href="../../DL/CNN/">卷积神经网络</a></li><li><a class="tocitem" href="../../DL/stereo/">立体匹配</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/strongnine/9Docs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/strongnine/9Docs/blob/main/docs/src/AI/ML.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="特征工程"><a class="docs-heading-anchor" href="#特征工程">特征工程</a><a id="特征工程-1"></a><a class="docs-heading-anchor-permalink" href="#特征工程" title="Permalink"></a></h2><p><strong>❓问：为什么要对特征做归一化处理？</strong></p><p>特征归一化、标准化，是数据预处理中的重要技术。特征间的单位（尺度）可能不同，变化范围也可能是不同的，在进行距离有关的计算时，尺度大的特征会起决定性的作用，而尺度小的特征可能会被忽略，为了消除特征间单位和尺度差异的影响，要对特征做归一化处理。</p><p><strong>❓问：「类别型特征」的编码方式有哪些？</strong></p><p><strong>序号编码（Ordinal Encoding）</strong>：通常用于处理类别间具有大小关系的数据，转换后依然保留相对的大小关系。</p><p><strong>独热编码（One-hot Encoding）</strong>：通常用于处理类别间不具有大小关系的特征。对于类别取值较多的情况下使用 One-hot Encoding 需要注意以下问题：</p><ul><li>使用稀疏向量来节省空间。</li><li>配合特征选择来降低维度。高维度特征会带来几方面的问题：<ul><li>在 K 近邻算法中，高维度空间下两点之间的距离很难得到有效的衡量；</li><li>在逻辑回归模型中，参数的数量会随着维度的增高而增加，容易引起过拟合的问题；</li><li>通常只有部分维度是对分类、预测有帮助，因此可以考虑配合特征选择来降低维度；</li></ul></li></ul><p><strong>二进制编码（Binary Encoding）</strong>：先用序号编码给每个类别赋予一个类别 ID，然后将类别 ID 对应的二进制编码作为结果。</p><p>Helmert Contrast</p><p>Sum Contrast</p><p>Polynomial Contrast</p><p>Backward Difference Contrast</p><p><strong>❓问：什么是组合特征？如何处理高维组合特征？</strong></p><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。在实际问题中，需要面对多种高维特征，简单地两两组合，依然容易存在参数过多、过拟合等问题。</p><p><strong>怎样有效地找到组合特征？</strong>可以利用决策树来寻找特征组合方式。</p><p><strong>对于这种「高维组合特征」要如何处理？</strong>假设用户和物品的数量分别为 <span>$m$</span> 和 <span>$n$</span>，一种行之有效的方法是将两个特征分别用 <span>$k$</span> 维的低维向量表示（<span>$k\ll m,k\ll n$</span>），这样原本 <span>$m\times n$</span> 的学习参数就降低为 <span>$m\times k + n\times k$</span>，这其实等价于推荐算法中的<strong>矩阵分解</strong>。</p><h2 id="距离函数"><a class="docs-heading-anchor" href="#距离函数">距离函数</a><a id="距离函数-1"></a><a class="docs-heading-anchor-permalink" href="#距离函数" title="Permalink"></a></h2><p><strong>欧氏距离</strong>：欧几里得距离，就是平方和开根号。是最常用的一种距离度量，欧氏距离越小，两个向量的相似度越大；欧氏距离越大，两个向量的相似度越小。</p><p><strong>曼哈顿距离</strong>：<span>$|x_1-x_2| + |y_1-y_2|$</span></p><p><strong>切比雪夫距离</strong>：<span>$\max(|x_1, x_2|, |y_1, y_2|)$</span></p><p><strong>❓问：什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？</strong></p><p>对于两个向量 <span>$A$</span> 和 <span>$B$</span>，其余弦相似度定义为 <span>$\cos(A,B)=\frac{AB}{|A||B|}$</span>，即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小，余弦相似度依然符合「相同为 1，正交为 0，相反为 -1」的性质，其取值范围是 <span>$[-1, 1]$</span>，欧氏距离衡量空间点的直线距离，余弦距离衡量点在空间的方向差异，欧氏距离体现数值上的绝对差异，余弦距离体现方向上的相对差异。</p><h2 id="模型评估"><a class="docs-heading-anchor" href="#模型评估">模型评估</a><a id="模型评估-1"></a><a class="docs-heading-anchor-permalink" href="#模型评估" title="Permalink"></a></h2><p><strong>❓过拟合和欠拟合是啥？</strong></p><ul><li>过拟合：在训练集上表现很好，测试集上表现很差。过拟合会导致高 Variance；</li><li>欠拟合：在训练集上表现很差。欠拟合会导致高 Bias；</li><li>模型需要在 Bias 与 Variance 之间做出一个权衡；</li></ul><p>解决欠拟合的方法：</p><ul><li>增加新特征，可以考虑加入特征组合、高次特征来增大假设空间；</li><li>尝试非线性模型，比如核 SVM、决策树、DNN 等模型；</li><li>如果有正则项可以适当降低正则项参数；</li><li>Boosting 方法往往会有较小的 Bias；</li></ul><p>解决过拟合的方法：</p><ul><li>交叉验证，通过交叉验证得到较优的模型参数；</li><li>减少特征的数量：通过人工选择保留哪些特征或者模型选择算法来降低；</li><li>正则化：降低模型参数的数量；</li></ul><p>Holdout 检验</p><p>交叉检验</p><p><strong>自助法（Bootstrap）</strong>：有放回地从 N 个样本中抽样 n 个样本。当样本规模比较小的时候，将样本集进行划分会让训练集进一步减小，这可能会影响模型训练效果。自助法是基于自助采样的检验方法。在 n 次采样过程中，有的样本会被重复采样，有的样本没有被抽出过，将这些没有被抽出的样本作为验证集，进行模型验证，这就是自助法的验证过程。</p><p><strong>交并比（Intersection over Union，IoU）</strong>：交并比 IoU 衡量的是两个区域的重叠程度，是两个区域的交集比上并集。在目标检测任务重，如果模型输出的矩形框与人工标注的矩形框 IoU 值大于某个阈值（通常为 0.5）时，即认为模型输出正确。</p><p><strong>精准率与召回率（Precision &amp; Recall）</strong>：在目标检测中，假设有一组图片，Precision 代表我们模型检测出来的目标有多少是真正的目标物体，Recall 就是所有真实的目标有多少比例被模型检测出来了。目标检测中的真正例（True Positive）、真负例（True Negative）、假正例（False Positive）、假负例（False Positive）的定义如下：</p><table><tr><th style="text-align: center"></th><th style="text-align: center">实际为正</th><th style="text-align: center">实际为负</th></tr><tr><td style="text-align: center"><strong>预测为正</strong></td><td style="text-align: center">TP</td><td style="text-align: center">FP</td></tr><tr><td style="text-align: center"><strong>预测为负</strong></td><td style="text-align: center">FN</td><td style="text-align: center">TN</td></tr></table><p>对于这四个指标可以这样去理解，后面的 Positive 和 Negative 以预测的结果为主，因为我们关注的是模型的预测，如果模型的预测与实际的标注不一样，那么这个预测就是「假的」，比如预测为负那么就称为 Negative，但是实际为正，与预测的不一样，那么就是「假的」False，因此这个预测就是 False Negative，这是一个「假的正例」是「错误的正例」。</p><p>精准率，就是在预测为正样本中实际为正样本的概率，也就是所有的 Positive 中 True Positive 的概率</p><p class="math-container">\[Precision = \frac{TP}{TP+FP},\]</p><p>召回率，就是在实际为正样本中预测为正样本的概率，就是所有的实际标注为正样本的（TP + FN）预测为正样本的概率（TP）</p><p class="math-container">\[Recall = \frac{TP}{TP+FN},\]</p><p>准确率，就是模型预测正确的（所有的 True：TP + TN）占全部的比例</p><p class="math-container">\[Accuracy = \frac{TP+TN}{TP+TN+FP+FN},\]</p><p><strong>平均精度（Average precision，AP）</strong>：是主流的目标检测模型评价指标，它的意思是不同召回率上的平均精度。我们希望训练好的模型 Precision 和 Recall 都越高越好，但是这两者之间有个矛盾，当 Recall 很小的时候 Precision 可能会很高，当 Recall 很大的时候，Precision 可能会很低。我们将不同 Recall 对应的 Precision 做一个曲线（PR 曲线），然后在这个曲线上计算 Precision 的均值。</p><p><strong>曲线下面积（Area Under Curve，AUC）</strong>：</p><h2 id="优化算法"><a class="docs-heading-anchor" href="#优化算法">优化算法</a><a id="优化算法-1"></a><a class="docs-heading-anchor-permalink" href="#优化算法" title="Permalink"></a></h2><h3 id="损失函数总结"><a class="docs-heading-anchor" href="#损失函数总结">损失函数总结</a><a id="损失函数总结-1"></a><a class="docs-heading-anchor-permalink" href="#损失函数总结" title="Permalink"></a></h3><p>为了刻画模型输出与样本标签的匹配程度，定义损失函数 <span>$L(\cdot,\cdot):Y\times Y\rightarrow \mathbb{R}_{\ge 0}$</span>，<span>$L(f(x_i,\theta),y_i)$</span> 越小，表明模型在该样本点匹配得越好。</p><blockquote><p>为了具有更加简介的表达，将网络的输出表示为 <span>$f$</span>，而实际标签表达为 <span>$y$</span>。</p></blockquote><p>在分类问题上常用的损失函数：</p><p>（1）<strong><span>$0-1$</span> 损失函数</strong>：最常用于二分类问题，<span>$Y=\{1,-1\}$</span>，我们希望 <span>$\texttt{sign}\, f(x_i,\theta)=y_i$</span>，所以 <span>$0-1$</span> 损失函数为</p><p class="math-container">\[L_{0-1}(f,y) = 1_{fy\le 0},\]</p><p>其中 <span>$1_{P}$</span> 是指示函数（Indicator Function），当且仅当 <span>$P$</span> 为真时取值为 1，否则取值为 0。<span>$0-1$</span> 损失的优点是可以直观地刻画分类的错误率，缺点是由于其非凸、非光滑的特点，算法很难对该函数进行优化。</p><p>（2）<strong>Hinge 损失函数</strong>：是 <span>$0-1$</span> 损失函数相对紧的凸上界，且当 <span>$fy\ge 1$</span> 时，函数不对其做任何惩罚。它在 <span>$fy=1$</span> 处不可导，不能够用梯度下降法进行优化，而是用次梯度下降法（Subgradient Descent Method）。适用于 Maximum-Margin 分类，主要用于支持向量机（SVM）中，用来解间距最大化的问题。</p><p class="math-container">\[L_{\text{hinge}}(f,y)=\max\{0,1-fy\}.\]</p><p>（3）<strong>感知损失函数（Perceptron Loss）</strong>：是 Hinge 损失函数的一个变种。Hinge 对判定边界附近的点（正确端）惩罚力度很高，但是 Perceptron 只要样本的判定类别正确就行，不管其判定边界的距离。它比 Hinge 更加简单，不是 Max-margin Boundary，所以模型的泛化能力没有 Hinge 强。</p><p class="math-container">\[L_{\text{Perceptron}}=\max(0, -f).\]</p><p>（4）<strong>Logistic 损失函数</strong>：是 <span>$0-1$</span> 损失函数的凸上界，该函数处处光滑，对所有的样本点都有所惩罚，因此对异常值相对更敏感一点。</p><p class="math-container">\[L_{\text{logistic}}(f,y)=\log_2(1+\exp(-fy)).\]</p><p>（5）<strong>Log 对数损失函数</strong>：即对数似然损失（Log-likelihood Loss），它的标准形式</p><p class="math-container">\[L_{\text{log}}(f(\boldsymbol{x};\theta),y)=-\log f_y(\boldsymbol{x};\theta),\]</p><p>其中 <span>$f_y(\boldsymbol{x};\theta)$</span> 可以看作真实类别 <span>$y$</span> 的似然函数。</p><p>（6）<strong>交叉熵（Cross Entropy）损失函数</strong>：对于两个概率分布，一般可以用交叉熵去衡量它们的差异。标签的真实分布 <span>$\boldsymbol{y}$</span> 和模型预测分布 <span>$f(\boldsymbol{x};\theta)$</span> 之间的交叉熵为</p><p class="math-container">\[\mathcal{L}(f(\boldsymbol{x};\theta),\boldsymbol{y})=-\boldsymbol{y}^\top\log f(\boldsymbol{x};\theta)=-\sum_{c=1}^Cy_c\log f_c(\boldsymbol{x};\theta).\]</p><p>因为 <span>$\boldsymbol{y}$</span> 为 one-hot 向量，因此交叉熵可以写为</p><p class="math-container">\[\mathcal{L}(f(\boldsymbol{x};\theta),\boldsymbol{y})=-\log f_y(\boldsymbol{x};\theta),\]</p><p>其中 <span>$f(\boldsymbol{x};\theta)$</span> 可以看作真实类别 <span>$y$</span> 的似然函数。因此交叉熵损失函数也就是<strong>负对数似然函数（Negative Log-Likelihood）</strong>。</p><p>在回归问题中常用的损失函数：</p><p>（1）<strong>平方损失（Mean Squared Error）函数</strong>：在回归问题中最常用的损失函数。对于 <span>$Y=\mathbb{R}$</span>，我们希望 <span>$f(x_i,\theta)\approx y_i$</span></p><p class="math-container">\[L_{\text{MSE}}(f,y)=(f-y)^2.\]</p><p>（2）<strong>绝对损失（Mean Absolute Error）函数</strong>：当预测值距离真实值较远的时候，平方损失函数的惩罚力度大，也就是说它对于异常点比较敏感。如果说平方损失函数是在做均值回归的话，那么绝对损失函数就是在做中值回归，对于异常点更加鲁棒一点。只不过绝对损失函数在 <span>$f=y$</span> 处无法求导。</p><p class="math-container">\[L_{\text{MAE}}(f,y)=|f-y|.\]</p><p>（3）<strong>Huber 损失函数</strong>：也称为 Smooth L1 Loss， 综合考虑可导性和对异常点的鲁棒性。在 <span>$|f-y|$</span> 较小的时候为平方损失，比较大的时候为线性损失</p><p class="math-container">\[L_{\text{Huber}}(f,y)=\begin{cases}(f-y)^2,\qquad |f-y|\le \delta\\ 2\delta|f-y|-\delta^2,\quad|f-y|&gt;\delta\end{cases}\]</p><p>（4）<strong>Log-Cosh 损失函数</strong>：</p><p>（5）<strong>分位数损失函数</strong>：</p><h3 id="随机梯度算法"><a class="docs-heading-anchor" href="#随机梯度算法">随机梯度算法</a><a id="随机梯度算法-1"></a><a class="docs-heading-anchor-permalink" href="#随机梯度算法" title="Permalink"></a></h3><p>随机梯度下降法本质上是采用迭代方式更新参数，每次迭代在当前位置的基础上，沿着某一方向迈一小步抵达下一位置，不断地重复这个步骤，它的更新公式为</p><p class="math-container">\[\theta_{t+1}=\theta_{t} - \eta g_t,\]</p><p>其中 <span>$\eta$</span> 是学习率。</p><p><strong>动量（Momentum）方法：</strong>类比中学物理知识，当前梯度就好比当前时刻受力产生的加速度，前一次步长 <span>$v_{t-1}$</span> 好比前一时刻的速度，当前步长 <span>$v_t$</span> 好比当前加速度共同作用的结果。这就好比小球有了惯性，而刻画惯性的物理量是动量。模型参数的迭代公式为：</p><p class="math-container">\[v_t = \gamma v_{t-1} + \eta g_t,\]</p><p class="math-container">\[\theta_{t+1} = \theta_t - v_t,\]</p><p>在这里当前更新步长 <span>$v_t$</span> 直接依赖于前一次步长 <span>$v_{t-1}$</span> 和当前梯度 <span>$g_t$</span>，衰减系数 <span>$\gamma$</span> 扮演了阻力的作用。</p><p><strong>AdaGrad 方法：</strong>在应用中，我们希望更新频率低的参数可以拥有较大的更新步幅，而更新频率高的参数的步幅可以减小，AdaGrad 方法采用「历史梯度平方和」来衡量不同参数的梯度的稀疏性，取值越小表明越稀疏。AdaGrad 借鉴了 <span>$\mathscr{l}_2$</span> 正则化的思想，每次迭代时自适应地调整每个参数的学习率。这样的方式保证了不同的参数有具有自适应学习率。具体的更新公式表示为：</p><p>在第 <span>$t$</span> 次迭代时，先计算每个参数梯度平方的累计值</p><p class="math-container">\[G_t = \sum_{\tau=1}^t \boldsymbol{g}_\tau \odot \boldsymbol{g}_\tau,\]</p><p>其中 <span>$\odot$</span> 为按元素乘积，<span>$\boldsymbol{g}_\tau\in \mathbb{R}^{|\theta|}$</span> 是第 <span>$\tau$</span> 次迭代时的梯度。参数更新差值为</p><p class="math-container">\[\Delta\theta_t=-\frac{\eta}{\sqrt{G_t+\epsilon}}\odot\boldsymbol{g}_t,\]</p><p>其中 <span>$\alpha$</span> 是初始学习率，<span>$\epsilon$</span> 是为了保持数值稳定性而设定的非常小的常数，一般取值为 <span>$e^{-7}\sim e^{-10}$</span>。分母中求和的形式实现了退火过程，意味着随着时间推移，学习速率 <span>$\frac{\eta}{\sqrt{G_t+\epsilon}}$</span> 越来越小，保证算法的最终收敛。在 AdaGrad 算法中，如果某个参数的偏导数积累比较大，其学习率相对较小；相反如果其偏导数积累较小，其学习率相对较大，但整体是随着迭代次数的增加，学习率逐渐变小。</p><h3 id="Adam-算法"><a class="docs-heading-anchor" href="#Adam-算法">Adam 算法</a><a id="Adam-算法-1"></a><a class="docs-heading-anchor-permalink" href="#Adam-算法" title="Permalink"></a></h3><p>Adam 算法的全称是<strong>自适应动量估计算法</strong>（Adaptive Moment Estimation Algorithm），它将惯性保持和自适应两个优点结合，可以看作是动量法和 RMSprop 算法（或者 AdaGrad 算法）的结合。</p><p>它一方面记录梯度的一阶矩（First Moment）<span>$M_t$</span>，即过往梯度与当前梯度的平均，理解为「惯性」，是梯度 <span>$\boldsymbol{g}_t$</span> 的指数加权平均。</p><p>另一方面记录梯度的二阶矩（Second Moment）<span>$G_t$</span>，即过往梯度平方与当前梯度平方的平均，理解为「自适应部分」，是梯度 <span>$\boldsymbol{g}_t^2$</span> 的指数加权平均。</p><blockquote><p>一阶矩可以理解为均值；二阶矩可以理解为未减去均值的方差</p></blockquote><p class="math-container">\[M_t = \beta_1 M_{t-1} + (1 - \beta_1)\boldsymbol{g}_t,\]</p><p class="math-container">\[G_t = \beta_2 G_{t-1} + (1 - \beta_2)\boldsymbol{g}_t\odot\boldsymbol{g}_t,\]</p><p>其中 <span>$\beta_1$</span> 和 <span>$\beta_2$</span> 分别为两个移动平均的衰减率，通常取值为 <span>$\beta_1 = 0.9$</span>, <span>$\beta_2 = 0.99$</span>. </p><p>Adam 算法考虑了 <span>$M_t, G_t$</span> 在零初始情况下的偏置矫正。假设 <span>$M_0=0, G_0=0$</span>，那么在迭代初期 <span>$M_t$</span> 和 <span>$G_t$</span> 的值会比真实的均值和方差要小，特别是当 <span>$\beta_1$</span> 和 <span>$\beta_2$</span> 都接近于 1 时，偏差会很大。具体来说，Adam 算法的更新公式为：</p><p class="math-container">\[\hat{M}_t = \frac{M_t}{1 - \beta_1^t},\]</p><p class="math-container">\[\hat{G}_t = \frac{G_t}{1 - \beta_2^t},\]</p><p class="math-container">\[\Delta\theta_t = -\frac{\alpha}{\sqrt{\hat{G}_t + \epsilon}} \hat{M}_t,\]</p><p>其中学习率 <span>$\alpha$</span> 通常设为 0.001，并且也可以进行衰减，比如 <span>$\alpha_t=\alpha_0/\sqrt{t}$</span>. </p><p>Adam 算法的物理意义：</p><blockquote><p>《百面机器学习》163 页</p></blockquote><h3 id="逐层归一化"><a class="docs-heading-anchor" href="#逐层归一化">逐层归一化</a><a id="逐层归一化-1"></a><a class="docs-heading-anchor-permalink" href="#逐层归一化" title="Permalink"></a></h3><p>逐层归一化（Layer Normalization）是将传统机器学习中的数据归一化方法应用到深度神经网络中，对神经网络中隐藏的输入进行归一化，使得网络更容易训练。常用的逐层归一化方法有：批量归一化、层归一化、权重归一化和局部响应归一化。</p><p><strong>内部协变量偏移（Internal Covariate Shift）</strong>：当使用随机梯度下降来训练网络时，每次参数更新都会导致该神经层的输入分布发生改变，越高的层，其输入分布会改变得越明显。从机器学习角度来看，如果一个神经层的输入分布发生了改变，那么其参数需要重新学习。</p><p>逐层归一化的能够提高训练效率的原因：</p><p>（1）<strong>更好的尺度不变性</strong>：把每个神经层的输入分布都归一化为标准正态分布，可以使得每个神经层对其输入具有更好的尺度不变性。不论低层的参数如何变化，高层的输入保持相对稳定。另外，尺度不变性可以使得我们更加高效地进行参数初始化以及超参选择。</p><p>（2）<strong>更平滑的优化地形</strong>：逐层归一化一方面可以使得大部分神经层的输入处于不饱和区域，从而让梯度变大，避免梯度消失问题；另一方面还可以使得神经网络的优化地形（Optimization Landscape）更加平滑，以及使梯度变得更加稳定，从而允许我们使用更大的学习率，并提高收敛速度。</p><p><strong>批量归一化（Batch Normalization，BN）方法</strong> 是一种有效的逐层归一化方法，可以对神经网络中任意的中间层进行归一化操作。假设神经网络第 <span>$l$</span> 层的净输入为 <span>$\boldsymbol{z}^{(l)}$</span>，神经元输出为 <span>$\boldsymbol{a}^{(l)}$</span>，即</p><p class="math-container">\[\boldsymbol{a}^{(l)} = f(\boldsymbol{z}^{(l)})=f\left( \boldsymbol{W}\boldsymbol{a}^{(l)} + \boldsymbol{b} \right),\]</p><p>其中 <span>$f(\cdot)$</span> 是激活函数，<span>$\boldsymbol{W}, \boldsymbol{b}$</span> 是神经网络的参数。为了提高优化效率，就要使得净输入 <span>$\boldsymbol{z}^{(l)}$</span> 的分布一致，比如都归一化到标准正态分布。归一化操作一般应用在仿射变换（Affine Transformation）<span>$\boldsymbol{W}\boldsymbol{a}^{(l)}+\boldsymbol{b}$</span> 之后，激活函数之前。</p><p>为了提高归一化效率，一般使用标准化将净输入 <span>$\boldsymbol{z}^{(l)}$</span> 的每一维都归一化到标准正态分布</p><p class="math-container">\[\hat{\boldsymbol{z}}^{(l)} = \frac{\boldsymbol{z}^{(l)}-\mathbb{E}[\boldsymbol{z}^{(l)}]}{\sqrt{\text{var}(\boldsymbol{z}^{(l)})+\epsilon}},\]</p><p>其中 <span>$\mathbb{E}[\boldsymbol{z}^{(l)}]$</span> 和 <span>$\text{var}(\boldsymbol{z}^{(l)})$</span> 是当前参数下 <span>$\boldsymbol{z}^{(l)}$</span> 的每一维在整个训练集上的期望和方差。</p><h2 id="决策树与集成学习"><a class="docs-heading-anchor" href="#决策树与集成学习">决策树与集成学习</a><a id="决策树与集成学习-1"></a><a class="docs-heading-anchor-permalink" href="#决策树与集成学习" title="Permalink"></a></h2><h3 id="决策树（Decision-Tree）"><a class="docs-heading-anchor" href="#决策树（Decision-Tree）">决策树（Decision Tree）</a><a id="决策树（Decision-Tree）-1"></a><a class="docs-heading-anchor-permalink" href="#决策树（Decision-Tree）" title="Permalink"></a></h3><p>一颗决策树包含一个根结点、若干个内部结点和若干个叶结点；</p><ul><li>叶结点对应于决策结果，其他每个结点则对应于一个属性测试；</li><li>每个结点包含的样本集合根据属性测试的结果被划分到子结点中；</li><li>根结点包含样本全集；</li></ul><p>决策树的生成是一个递归过程，遵循「分治策略」（divide-and-conquer）。</p><p>决策树基本算法中导致递归返回的三种情况：</p><ol><li>当前结点包含的样本全部属于同一个类别；</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分。在这种情况下，把当前结点标记为叶结点，并将其类别设定为该结点所含样本最多的类别。这相当于利用了当前结点的后验分布；</li><li>当前结点包含的样本集合为空，不能划分。在这种情况下，同样把当前结点标记为叶结点，但将其类别设定为其父结点所含样本最多的类别；</li></ol><p>信息熵（Information Entropy）：是度量样本集合纯度最常用的一种指标。假定当前样本集合 <span>$D$</span> 中第 <span>$k$</span> 类样本所占的比例为 <span>$p_k (k=1,2,\dots,|\mathcal{Y}|)$</span>，则 <span>$D$</span> 的信息熵为：</p><p class="math-container">\[\text{Ent}(D)=-\sum_{k=1}^{|\mathcal{Y}|}p_k\log_2p_k,\]</p><p>如果 <span>$\text{Ent}(D)$</span> 的值越小，则 <span>$D$</span> 的纯度越高，纯度越高说明包含的信息量越少。<span>$\text{Ent}(D)\in[0,\log_2|\mathcal{Y}|]$</span>.</p><blockquote><p>注意：计算信息熵时约定，若 <span>$p=0$</span>，则 <span>$p\log_2p=0$</span>，这与极限一致 <span>$\lim_{p\rightarrow 0^{+}}p\log p=0$</span>。</p></blockquote><p>信息增益（Information Gain）：一般而言，信息增益越大，表示用属性 <span>$a$</span> 来进行划分所获得的「纯度提升」越大。</p><p>假定离散属性 <span>$a$</span> 有 <span>$V$</span> 个可能的取值 <span>$\{a^1, a^2,\dots,a^V\}$</span>，如果使用 <span>$a$</span> 来对样本集 <span>$D$</span> 进行划分，则会产生 <span>$V$</span> 个分支结点，其中第 <span>$v$</span> 个分支结点包含了 <span>$D$</span> 中所有在属性 <span>$a$</span> 上取值为 <span>$a^v$</span> 的样本，记为 <span>$D^v$</span>.</p><p>因此用属性 <span>$a$</span> 对样本集 <span>$D$</span> 进行划分所获得的信息增益为：</p><p class="math-container">\[\text{Gain}(D, a)=\text{Ent}(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}\text{Ent}(D^v).\]</p><p>其中考虑到不同的分支结点所包含的样本数不同，给分支结点赋予权重 <span>$|D^v|/|D|$</span>，表示样本数越多的分支结点的影响越大。</p><blockquote><p>著名的决策树算法 ID3（Iterative Dichotomiser，迭代二分器）就是以信息增益为准则来选择划分属性的。</p></blockquote><p>以信息增益作为准则来生成决策树有一个缺点，就是信息增益对可取值数目较多的属性有更大的偏好，一个更好的方法就是使用「增益率」（Gain Ratio）来选择最优划分属性，著名的 C4.5 决策树算法就利用增益率来生成决策树。增益率的定义为：</p><p class="math-container">\[\text{Gain\_ratio}(D, a)=\frac{\text{Gain(D, a)}}{\text{IV}(a)},\]</p><p>其中</p><p class="math-container">\[\text{IV}(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}\log_2\frac{|D^v|}{|D|},\]</p><p>称为属性 <span>$a$</span> 的「固有值」（intrinsic value），属性 <span>$a$</span> 的可能取值书目越多，<span>$V$</span> 就会越大，<span>$\text{IV}(a)$</span> 的值通常就会越大。</p><p>但是增益率准则带来的一个缺点又变成了对可取值数目较少的属于更加偏好，因此 C4.5 算法并不直接选择增益率最大的候选划分属性，它的具体做法是：</p><ul><li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的属性作为「最优划分属性」。</li></ul><p>基尼指数（Gini index）：反映了从数据集 <span>$D$</span> 中随机抽取两个样本，其类别标记不一致的概率。因此 <span>$\text{Gini}(D)$</span> 越小，则数据集 <span>$D$</span> 的纯度越高。属性 <span>$a$</span> 的基尼指数定义为：</p><p class="math-container">\[\text{Gini\_index}(D, a)=\sum_{v=1}^V\frac{|D^v|}{|D|}\text{Gini}(D^v).\]</p><p>在候选属性集合 <span>$A$</span> 中，选择那个使得划分后基尼指数最小的属性作为划分属性。</p><blockquote><p>CART 决策树（Classification and Regression Tree）就是使用基尼指数来选择划分属性的。</p></blockquote><p>剪枝（pruning）是决策树学习算法对付「过拟合」的主要手段，基本策略有「预剪枝」（pre-pruning）和「后剪枝」（post-pruning）。</p><h3 id="Boosting-与-Bagging"><a class="docs-heading-anchor" href="#Boosting-与-Bagging">Boosting 与 Bagging</a><a id="Boosting-与-Bagging-1"></a><a class="docs-heading-anchor-permalink" href="#Boosting-与-Bagging" title="Permalink"></a></h3><p>机器学习问题的两种策略：一种是研发人员尝试各种模型，选择其中表现最好的模型，做重点调参优化；另一种是将多个分类器的结果统一成一个最终的决策，其中每个单独的分类器称为<strong>基分类器</strong>，使用这类策略的机器学习方法统称为<strong>集成学习</strong>。</p><p>集成学习分为 Boosting 和 Bagging 两种。<strong>Boosting 方法</strong>训练基分类器时采用串行方式，各个基分类器之间有依赖。它的基本思路是将基分类器层层叠加，每一层在训练的时候，对前一层基分类器分错的样本，给予更高的权重。测试时，根据各层分类器的结果的加权得到最终结果。<strong>Bagging</strong> 与 Boosting 的串行训练方式不同，Bagging 方法在训练过程中，各基分类器之间无强依赖，可以进行并行训练。最著名的算法之一就是基于决策树基分类器的<strong>随机森林（Random Forest）</strong>。Bagging 方法更像是一个集体决策的过程，每个个体都进行单独学习，在最终做决策时，每个个体单独做出判断，再通过投票的方式做出最后的集体决策。</p><p><strong>基分类器</strong>，有时候又被称为弱分类器。基分类器的错误，是偏差和方差两种错误之和。偏差主要是由于分类器的表达能力有限导致的系统性错误，表现在训练误差不收敛，方差是由于分类器对于样本分布过于敏感，导致在训练样本数较少时，产生过拟合。而 Boosting 方法通过逐步聚焦于基分类器分错的样本，减小集成分类器的偏差。Bagging 方法则是采取分而治之的策略，通过对训练样本多次采样，并分别训练出多个不同模型，然后做综合，来减小集成分类器的方差。</p><p>最常用的基分类器是决策树：</p><ul><li>决策树可以较为方便地将样本的权重整合到训练过程当中，而不需要使用过采样的方法来调整样本权重；</li><li>决策树的表达能力和泛化能力，可以通过调节树的层数来做折中；</li><li>数据样本的扰动对于决策树的影响较大，因此不同子样本集合生成的决策树基分类器随机性较大，这样的「不稳定学习期」更适合作为基分类器。（在这个点上，神经网络也因为不稳定性而适合作为基分类器，可以通过调节神经元数量、连接方式、网络层数、初始权值等方式引入随机性）；</li></ul><p><strong>集成学习的基本步骤</strong>。集成学习一般可以分为以下 3 个步骤：</p><p>（1）找到误差互相独立的基分类器；</p><p>（2）训练基分类器；</p><p>（3）合并基分类器的结果；</p><p>合并基分类器的方法有 voting 和 stacking 两种，前者对应 Bagging 方法，后者对应 Boosting 方法。</p><p>以 Adaboost 为例，其基分类器的训练和合并的基本步骤如下：</p><p>（1）确定基分类器：可以选择 ID3 决策树作为基分类器。虽然任何分类模型都可以作为基分类器，但树形模型由于结构简单且较为容易产生随机性所以比较常用。</p><p>（2）训练基分类器：假设训练集为 <span>$\{x_i,y_i\},i=1,\dots,N$</span>，其中 <span>$y_i\in\{-1,1\}$</span>，并且有 <span>$T$</span> 个基分类器，则可以按照如下过程来训练基分类器：</p><ul><li><p>初始化采样分布 <span>$D_1(i)=1/N$</span>；</p></li><li><p>令 <span>$t=1,2,\dots,T$</span> 循环：</p><ul><li><p>从训练集中，按照 <span>$D_t$</span> 分布，采样出子集 <span>$S_i=\{x_i,y_i\},i=1,\dots,N$</span>；</p></li><li><p>用 <span>$S_i$</span> 训练出基分类器 <span>$h_t$</span>；</p></li><li><p>计算基分类器 <span>$h_t$</span> 的错误率：</p><p class="math-container">\[\varepsilon_t=\frac{\sum_{i=1}^{N_t}I[h_t(x_i)\neq y_i]D_i(x_i)}{N_t}\]</p><p>其中 <span>$I[\cdot]$</span> 为判别函数；</p></li><li><p>计算基分类器 <span>$h_t$</span> 权重 <span>$a_t=\log{\frac{(1-\varepsilon_t)}{\varepsilon_t}}$</span>，这里可以看到错误率 <span>$\varepsilon_t$</span> 越大，基分类器的权重 <span>$a_t$</span> 就越小；</p></li><li><p>设置下一次采样：</p><p class="math-container">\[D_{t+1}=\begin{cases}D_t(i) \text{ or } \frac{D_t(i)(1-\varepsilon_t)}{\varepsilon_t}, \, h_t(x_i)\neq y_i;\\
\frac{D_t(i)\varepsilon_t}{(1-\varepsilon_t)}, \, h_t(x_i)= y_i.\end{cases}\]</p></li></ul></li></ul><p>（3）合并基分类器：给定一个未知样本 <span>$z$</span>，输出分类结果为加权投票的结果 <span>$\text{Sign}(\sum_{t=1}^Th_t(z)a_t)$</span>.</p><h3 id="梯度提升决策树（GBDT）"><a class="docs-heading-anchor" href="#梯度提升决策树（GBDT）">梯度提升决策树（GBDT）</a><a id="梯度提升决策树（GBDT）-1"></a><a class="docs-heading-anchor-permalink" href="#梯度提升决策树（GBDT）" title="Permalink"></a></h3><p><strong>❓GBDR 和 RF 有什么区别？</strong></p><h3 id="XGBoost"><a class="docs-heading-anchor" href="#XGBoost">XGBoost</a><a id="XGBoost-1"></a><a class="docs-heading-anchor-permalink" href="#XGBoost" title="Permalink"></a></h3><p>XGBoost 是陈天奇等人开发的一个开源机器学习项目，高效地实现了 GBDT 算法并进行了算法和工程上的许多改进，被广泛应用在 Kaggle 竞赛以及其他许多机器学习竞赛中。</p><p>XGBoost 本质上还是一个 GBDT（Gradient Boosting Decision Tree），只是把速度和效率发挥到极致，所以前面加上了 X（代表 Extreme）。原始的 GBDT 算法基于经验损失函数的负梯度来构造新的决策树，只是在决策树构建完成后再进行剪枝。XGBoost 在决策树构建阶段就加入了正则项，即</p><p class="math-container">\[L_t=\sum_i l\left(y_i,\, F_{t-1}(x_i)+f_t(x_i)\right)+\Omega(f_t),\]</p><p>其中 <span>$F_{t-1}(x_i)$</span> 表示现有的 <span>$t-1$</span> 棵树最优解，树结构的正则项定义为</p><p class="math-container">\[\Omega(f_t)=\gamma T+\frac{1}{2}\lambda\sum_{j=1}^Tw^2_j,\]</p><p>其中 <span>$T$</span> 为叶子节点个数，<span>$w_j$</span> 表示第 <span>$j$</span> 个叶子节点的预测值。对该损失函数在 <span>$F_{t-1}$</span> 处进行二阶泰勒展开可以推导出</p><p class="math-container">\[L_t\approx\overset{\sim}{L_t}=\sum_{j=1}^T\left[G_jw_j+\frac{1}{2}(H_j+\lambda)w^2_j\right]+\gamma T\]</p><p>从所有的树结构中寻找最优的树结构是一个 NP-hard 问题，在实际中往往采用贪心法来构建出一个次优的树结构，基本思想是根据特定的准则选取最优的分裂。不同的决策树算法采用不同的准则，如 IC3 算法采用信息增益，C4.5 算法为了克服信息增益中容易偏向取值较多的特征而采用信息增益比，CART 算法使用基尼指数和平方误差，XGBoost 也有特定的准则来选取最优分裂。</p><p><strong>❓XGBoost 与 GBDT 有什么区别和联系？</strong></p><p>（1）GBDT 是机器学习算法，XGBoost 是该算法的工程实现；</p><p>（2）在使用 CART 作为基分类器时，XGBoost 显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力；</p><p>（3）GBDT 在模型训练时只使用了代价函数的一阶导数信息，XGBoost 对代价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数；</p><p>（4）传统的 GBDT 采用 CART 作为基分类器，XGBoost 支持多种类型的基分类器，比如线性分类器；</p><p>（5）传统的 GBDT 在每轮迭代时使用全部的数据，XGBoost 则采用了与随机森林相似的策略，支持对数据进行采样；</p><p>（6）传统的 GBDT 没有设计对缺失值进行处理，XGBoost 能够自动学习出缺失值的处理策略；</p><p><strong>❓XGBoost 如何实现并行化生成树？</strong></p><p><strong>XGBoost 的并行化：</strong>boosting 是一种串行结构，它的并行不是在 tree 粒度上的，而是在特征粒度上的并行。决策树学习最耗时的一个步骤就是对特征的值进行排序（为了确定最佳分割点）。XGBoost 训练之前，预先对数据进行排序，保存为 block 结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个 block 结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p><p><strong>XGBoost 的特点：</strong></p><ul><li>传统的 GBDT 以 CART 作为基函数，而 XGBoost 相当于有 L1/L2 正则化项的分类或者回归</li><li>传统的 GBDT 在优化的时候只用到一阶导数，XGBoost 对代价函数进行了二阶泰勒展开，同时用到一阶和二阶导数。并且 XGBoost 工具支持自定义代价函数，只要函数可以一阶和二阶求导；</li><li>XGBoost 在代价函数里加入了正则项，控制模型复杂度。正则项里包含了树的叶节点个数、每个叶子节点上输出 score 的 L2 模的平方和。从 Bias-variance tradeoff 角度来讲，正则项降低了模型 variance，使学习出来的模型更加简单，防止过拟合，这也是 XGBoost 优于传统 GBDT 的一个特性。 剪枝是都有的，叶子节点输出 L2 平滑是新增的；</li><li>shrinkage 缩减和 column subsampling。shrinkage 缩减：类似于学习速率，在每一步 tree boosting 之后增加了一个参数 n（权重），通过这种方式来减小每棵树的影响力，给后面的树提供空间去优化模型。column subsampling：列（特征）抽样，随机森林那边学习来的，防止过拟合的效果比传统的行抽样还好（行抽样功能也有），并且有利于后面提到的并行化处理算法；</li><li>split finding algorithms（划分点查找算法），树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法 greedy algorithm 枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以 XGBoost 还提出了一种可并行的近似直方图算法（Weighted Quantile Sketch），用于高效地生成候选的分割点；</li><li>对缺失值的处理。对于特征的值有缺失的样本，XGBoost 可以自动学习出它的分裂方向。 稀疏感知算法 Sparsity-aware Split Finding；</li><li>内置交叉验证（Built-in Cross-Validation），XGBoost 可以在 boosting 过程的每次迭代中运行交叉验证，因此很容易在一次运行中获得准确的最佳 boosting 迭代次数；</li><li>XGBoost 支持并行，提高计算速度；</li></ul><h3 id="LightGBM"><a class="docs-heading-anchor" href="#LightGBM">LightGBM</a><a id="LightGBM-1"></a><a class="docs-heading-anchor-permalink" href="#LightGBM" title="Permalink"></a></h3><p>LightGBM 是 XGBoost 的更高效实现，由微软发布。LightGBM 相比于 Xgboost，添加了很多新的方法来改进模型，包括：并行方案、基于梯度的单边检测（GOSS）、排他性特征捆绑等。</p><p>LightGBM 的设计思路主要是两点：</p><ol><li>减小数据对内存的使用，保证单个机器在不牺牲速度的情况下，尽可能地用上更多的数据；</li><li>减小通信的代价，提升多机并行时的效率，实现在计算上的线性加速。</li></ol><p>由此可见，LightGBM 的设计初衷就是提供一个快速高效、低内存占用、高准确度、支持并行和大规模数据处理的数据科学工具。</p><p>LightGBM 并没有垂直的切分数据集，而是每个 worker 都有全量的训练数据，因此最优的特征分裂结果不需要传输到其他 worker 中，只需要将最优特征以及分裂点告诉其他 worker，worker 随后本地自己进行处理。处理过程如下：</p><ul><li>每个 worker 在基于局部的特征集合找到最优分裂特征；</li><li>worker 间传输最优分裂信息，并得到全局最优分裂信息；</li><li>每个 worker 基于全局最优分裂信息，在本地进行数据分裂，生成决策树；</li></ul><h2 id="其他知识"><a class="docs-heading-anchor" href="#其他知识">其他知识</a><a id="其他知识-1"></a><a class="docs-heading-anchor-permalink" href="#其他知识" title="Permalink"></a></h2><p>HMM：EM 算法、维特比算法、前向后向算法、极大似然估计</p><p>在 HMM 中，如果已知观察序列和产生观察序列的状态序列，可以用极大似然估计进行阐述估计。</p><p>EM 算法只有观测序列，无状态序列时来学习模型参数，即 Baum-Welch 算法。</p><p>维特比算法是用动态规划解决 HMM 的预测问题的，不是参数估计。</p><p>前向后向算法是用来计算概率的。</p><p>极大似然估计是观测序列和相应序列都存在时的监督学习算法，用来进行阐参数估计。</p><p>序列模式挖掘算法、AprioriAll 算法、GSP 算法、FreeSpan 算法、PrefixSpan 算法</p><p>Apriori 算法：关联分析原始算法，用于从候选项集中发现频繁项集。两个步骤：进行自连接、进行剪枝。缺点：无时序先后性。</p><p>AprioriAll 算法：AprioriAll 算法与 Apriori 算法的执行过程是一样的，不同点在于候选集的产生，需要区分最后两个元素的前后。</p><p>AprioriSome 算法：可以看做是 AprioriAll 算法的改进</p><p>AprioriAll 算法和 AprioriSome 算法的比较：</p><p>（1）AprioriAll 用  去计算出所有的候选 Ck，而 AprioriSome 会直接用  去计算所有的候选 ，因为 包含 ，所以 AprioriSome 会产生比较多的候选。</p><p>（2）虽然 AprioriSome 跳跃式计算候选，但因为它所产生的候选比较多，可能在回溯阶段前就占满内存。</p><p>（3）如果内存占满了，AprioriSome 就会被迫去计算最后一组的候选。</p><p>（4）对于较低的支持度，有较长的大序列，AprioriSome 算法要好些。</p><p>GPS算法：类Apriori算法。用于从候选项集中发现具有时序先后性的频繁项集。两个步骤：进行自连接、进行剪枝。缺点：每次计算支持度，都需要扫描全部数据集；对序列模式很长的情况，由于其对应的短的序列模式规模太大，算法很难处理。</p><p>SPADE算法：改进的GPS算法，规避多次对数据集D进行全表扫描的问题。与GSP算法大体相同，多了一个ID<em>LIST记录，使得每一次的ID</em>LIST根据上一次的ID<em>LIST得到（从而得到支持度）。而ID</em>LIST的规模是随着剪枝的不断进行而缩小的。所以也就解决了GSP算法多次扫描数据集D问题。</p><p>FreeSpan算法：即频繁模式投影的序列模式挖掘。核心思想是分治算法。基本思想为：利用频繁项递归地将序列数据库投影到更小的投影数据库集中，在每个投影数据库中生成子序列片断。这一过程对数据和待检验的频繁模式集进行了分割，并且将每一次检验限制在与其相符合的更小的投影数据库中。 优点：减少产生候选序列所需的开销。缺点：可能会产生许多投影数据库，开销很大，会产生很多的</p><p>PrefixSpan 算法：从FreeSpan中推导演化而来的。收缩速度比FreeSpan还要更快些。</p><p><strong>模型过拟合</strong>：</p><p>原因：（1）训练数据太少；（2）模型太复杂；（3）参数过多；（4）噪声过多。</p><p>解决办法：（1）获得更多的训练数据；（2）降低特征维度；（3）正则化；（4）Dropout；（5）早停 Early Stop；（6）数据清洗。</p><hr/><p><strong>参考</strong></p><p>[1] <a href="https://github.com/NLP-LOVE/ML-NLP">GitHub 项目：ML-NLP</a>；</p><p>[2] <a href="https://blog.csdn.net/niaolianjiulin/article/details/76574216">XGBoost 特点、调参、讨论</a>；</p><p>[3] 诸葛越，葫芦娃，《百面机器学习》，中国工信出版集团，人民邮电出版社</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 11 October 2025 07:59">Saturday 11 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
