var documenterSearchIndex = {"docs":
[{"location":"git/git_notebook/#第一章-Git-基础","page":"Git 学习笔记","title":"第一章 Git 基础","text":"","category":"section"},{"location":"git/git_notebook/#.-基本操作","page":"Git 学习笔记","title":"1. 基本操作","text":"","category":"section"},{"location":"git/git_notebook/#.1.-配置-user-信息","page":"Git 学习笔记","title":"1.1. 配置 user 信息","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"$ git config --global user.name 'strongnine'\n$ git config --global user.email 'strongnine@163.com'","category":"page"},{"location":"git/git_notebook/#.2.-config-的三个作用域","page":"Git 学习笔记","title":"1.2. config 的三个作用域","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"$ git config --global\n$ git config --local\n# 显示 config 设置\n$ git config --list --local\n$ git config --list --global","category":"page"},{"location":"git/git_notebook/#.3.-创建仓库","page":"Git 学习笔记","title":"1.3. 创建仓库","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"$ git init\n$ git init ./'git_learning'\n# 添加文件\n$ git add ./README.md\n$ git status\n$ git commit -m'Add README.md'\n$ git log","category":"page"},{"location":"git/git_notebook/#.4.-添加删除和重命名文件","page":"Git 学习笔记","title":"1.4. 添加删除和重命名文件","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"往仓库里面添加删除文件：参考项目 https://github.com/TTN-js/unforGITtable","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# status 会提示目前的状态，Untracked 代表文件从来没有被管理过\n$ git status\n# add 可以添加多个文件，例如：\n$ git add index.hrml images\n# 把变更变成一次正式的提交\n$ git commit -m'Add index + logo'\n$ git log\n\n# 新用法：把工作区上所有已经被 git 管理的文件一起放到暂存区\n# 将文件的修改、文件的删除，添加到暂存区\n$ git add -u\n\n# 正确删除文件的方法\n$ git rm <文件名>","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"网友「易风」的补充：","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git add -u：将文件的修改、文件的删除，添加到暂存区。git add .：将文件的修改，文件的新建，添加到暂存区。git add -A：将文件的修改，文件的删除，文件的新建，添加到暂存区。git add -A 相对于 git add -u 命令的优点 ： 可以提交所有被删除、被替换、被修改和新增的文件到数据暂存区，而 git add -u 只能操作跟踪过的文件。git add -A 等同于 git add -all。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"重命名的文件：git mv oldname newname","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 想要重命名一个文件，当你修改了之后用 status 会发现\n# 提示你有一个文件被删除，有另一个文件是新的 Untracked files\n$ git add\n$ git rm\n\n# 可以使用 reset 来对暂存区的文件进行重置\n# 注意这是一条相对危险的命令\n$ git reset --hard\n\n# 重命名操作可以有直接的方式\n$ git mv readme readme.md","category":"page"},{"location":"git/git_notebook/#.-版本管理","page":"Git 学习笔记","title":"2. 版本管理","text":"","category":"section"},{"location":"git/git_notebook/#.1.-查看历史","page":"Git 学习笔记","title":"2.1. 查看历史","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# git log 不带参数的时候是整个完整的日记\n# 如果加上 --oneline，就只显示每次提交的备注\n$ git log --oneline\n\n# 还可以指定最近的几个 commit，以 4 为例：\n$ git log -n4 --oneline\n\n# 查看本地有多少分支和创建分支\n$ git branch -v\n$ git checkout -b temp 415c5c...\n\n# git log 只显示当前分支的日志，--all 查看全部分支\n$ git log --all\n# 还可以图形化显示\n$ git log --all --graph\n\n# 通过图形界面查看版本历史：\n# 命令行输入 gitk 会弹出图形界面\n$ gitk","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"网友「夕夕熊」补充：","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"加上 –decorate 参数，部分同学才可以显示（master）（temp）等分支信息。","category":"page"},{"location":"git/git_notebook/#.2.-.git-目录的内容","page":"Git 学习笔记","title":"2.2. .git 目录的内容","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"cat 命令主要用来查看文件内容，创建文件，文件合并，追加文件内容等功能。 cat HEAD 查看 HEAD 文件的内容 git cat-file 命令 显示版本库对象的内容、类型及大小信息。 git cat-file -t b44dd71d62a5a8ed3 显示版本库对象的类型 git cat-file -s b44dd71d62a5a8ed3 显示版本库对象的大小 git cat-file -p b44dd71d62a5a8ed3 显示版本库对象的内容","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"HEAD：指向当前的工作路径 config：存放本地仓库（local）相关的配置信息。 refs/heads：存放分支 refs/tags：存放tag，又叫里程牌 （当这次 commit 是具有里程碑意义的，比如项目 1.0 的时候 就可以打 tag） objects：存放对象 .git/objects/ 文件夹中的子文件夹都是以哈希值的前两位字符命名 每个 object 由 40 位字符组成，前两位字符用来当文件夹，后 38 位做文件。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"commit、tree、blob 的关系","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"(Image: image-20200524215649644)","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"一个 commit 对应一颗 tree，tree 相当于文件夹，blob 相当于具体的文件（数据）。git 里面，文件内容相同， 就是视为同一个文件。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"当创建了新的空文件夹时，使用 status 不会检测到这个空的文件夹。","category":"page"},{"location":"git/git_notebook/#.3.-分离头指针","page":"Git 学习笔记","title":"2.3. 分离头指针","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"变更没有基于某个 branch，在分离头指针进行的 commit，如果没有及时合并到某个 branch，可能会被 git 当作垃圾清掉。如果这种变更是重要的，就要将其与某个 branch 绑在一起。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git checkout -b 可以创建新分支并且切换到该新的分支。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"HEAD 指针可以指向某个分支的最后一次提交，也可以不和某个分支挂钩，当处于分离头指针时，可以直接指向某个 commit。它只能够定位到某个 commit。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git diff [commit1] [commit2] 可以比较两个具体的 commit 的差异。git diff HEAD HEAD^1 将当前结点与其父亲结点进行对比。HEAD^1, HEAD~1, HEAD~, HEAD^ 都一样。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1、一个节点，可以包含多个子节点（checkout 出多个分支） 2、一个节点可以有多个父节点（多个分支合并） 3、\\^是 \\~ 都是父节点，区别是跟随数字时候，\\^2 是第二个父节点，而 \\~2 是父节点的父节点 4、\\^ 和 \\~ 可以组合使用,例如 HEAD\\~2\\^2","category":"page"},{"location":"git/git_notebook/#第二章-独自使用-Git","page":"Git 学习笔记","title":"第二章 独自使用 Git","text":"","category":"section"},{"location":"git/git_notebook/#.-删除无用分支","page":"Git 学习笔记","title":"1. 删除无用分支","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 查看所有分支\n$ git branch -av\n# 删除分支\n$ git branch -d 分支名\n# 如果分支还未被 merged 用强制删除\n# 要注意保证分支无用\n$ git branch -D 分支名","category":"page"},{"location":"git/git_notebook/#.-commit-的操作","page":"Git 学习笔记","title":"2. commit 的操作","text":"","category":"section"},{"location":"git/git_notebook/#.1.-修改-commit-的-message","page":"Git 学习笔记","title":"2.1. 修改 commit 的 message","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 修改最新 commit 的信息\n$ git commit --amend\n# 想要修改旧 commit 的信息，需要先选择其父节点\n# 运行后会弹出一个交互界面，在里面修改、保存之后\n# 还会继续弹出一个交互界面，提示要把 message 如何修改\n$ git rebase -i 父节点","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"这种操作只适用于还未合并到「主线」 的分支上，否则会影响到合作者的工作。","category":"page"},{"location":"git/git_notebook/#.2.-整理多个-commit","page":"Git 学习笔记","title":"2.2. 整理多个 commit","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 和上一个操作相似\n# 在弹出的交互界面进行不同的修改就行（会有提示）\n$ git rebase -i 父节点\n\n# 上面的是把「连续的」commit 合并，还有一种是把「间隔的」合并\n$ git rebase -i 父节点","category":"page"},{"location":"git/git_notebook/#.3.-对比差异","page":"Git 学习笔记","title":"2.3. 对比差异","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 对比暂存区和 HEAD 里面内容的差异（看看做了哪些改动）\n$ git diff --cached\n\n# 对比工作区和暂存区的不同\n$ git diff\n\n# 只比较某个文件\n$ git diff -- <文件名>\n\n# 查看不同提交的指定文件的差异\n$ git diff <指针 1> <指针 2> -- <文件名>","category":"page"},{"location":"git/git_notebook/#.4.-恢复变更","page":"Git 学习笔记","title":"2.4. 恢复变更","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 把暂存区里面的文件全部恢复成和 HEAD 一样的\n$ git reset HEAD\n\n# 让工作区的文件恢复为暂存区一样（变更工作区）\n$ git checkout -- index.html\n\n# 取消暂存区部分文件的更改\n$ git reset HEAD -- <文件名>...","category":"page"},{"location":"git/git_notebook/#.5.-消除最近几次提交","page":"Git 学习笔记","title":"2.5. 消除最近几次提交","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 将头指针指向特定的某次提交，并且删除这之前的提交\n# <危险指令> 慎用！！！\n$ git reset --hard <指针>","category":"page"},{"location":"git/git_notebook/#.6.-删除文件","page":"Git 学习笔记","title":"2.6. 删除文件","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 正确删除文件的方法\n$ git rm <文件名>","category":"page"},{"location":"git/git_notebook/#.7.-临时加塞的紧急任务-——-stash-的使用","page":"Git 学习笔记","title":"2.7. 临时加塞的紧急任务 —— stash 的使用","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 把当前状态存放\n$ git stash\n# 列出状态区\n$ git stash list\n# 恢复暂存区（弹出之前放进 stash 顶的），但是 stash 堆栈里的信息还会在\n$ git stash apply\n# 恢复的基础上还会丢掉 stash 里面的信息\n$ git stash pop","category":"page"},{"location":"git/git_notebook/#.-Git-管理","page":"Git 学习笔记","title":"3. Git 管理","text":"","category":"section"},{"location":"git/git_notebook/#.1.-指定不需要-Git-管理的文件","page":"Git 学习笔记","title":"3.1. 指定不需要 Git 管理的文件","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":".gitignore 文件上的内容就是表示指定类型的文件不给 Git 进行管理。","category":"page"},{"location":"git/git_notebook/#.2.-Git-的备份","page":"Git 学习笔记","title":"3.2. Git 的备份","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"(Image: image-20200531173028196)","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"哑协议传输进度不可看见，智能协议可见。智能协议比哑协议快。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# --bare 代表不带工作区的裸仓库\n# 哑协议\n$ git clone --bare /path/to/repo.git <拷贝路径.git>\n# 智能协议\n$ git clone --bare / file:///path/to/repo.git <拷贝路径.git>\n\n# 把本地的变更同步到远端\n$ git remote -v\n$ git remote add <名称> <协议地址>\n# 查看分支\n$ git branch -av\n$ git push <名称>\n$ git push --set-upstream <  > <  >","category":"page"},{"location":"git/git_notebook/#第三章-Github-同步","page":"Git 学习笔记","title":"第三章 Github 同步","text":"","category":"section"},{"location":"git/git_notebook/#**配置公私钥**","page":"Git 学习笔记","title":"配置公私钥","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 Github 首页上，寻找 help，在上面有关于如何 connecting to github with SSH 的做法。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 打开 git bash 在里面输入下面命令\n# 若干存在 id_rsa 和 id_rsa.pub 文件则代表已经有公私钥\n# 否则应该要根据 Help 上的提示进行生成\n$ ls - al ~/.ssh\n# 查看 id_rsa.pub 的内容\n$ cd ~/.ssh\n$ cat id_rsa.pub\n# 复制里面的内容，前往 github 账户设置里面添加 SSH keys","category":"page"},{"location":"git/git_notebook/#**把本地仓库同步到-Github**","page":"Git 学习笔记","title":"把本地仓库同步到 Github","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 添加一个新的 remote\n$ git remote add <名称> <SSH>\n# 查看已有的 remote\n$ git remote -v\n\n# 把所有内容 push\n$ git push <name> --all\n# 如果远端有某些文件是本地未包含的，这个分支会被拒绝 push\n# 需要把远端的先「拉」下来\n$ git fetch <name> master\n# 切换到 master 分支\n$ git checkout master\n# 与远端的 .../master 的分支合并\n$ git merge <远端分支>\n# 但注意如果两个分支都是独立的，没有共同的历史，那么会拒绝合并\n# 查看 merge 帮助\n$ git merge -h\n$ git merge --allow-unrelated-histories <远端分支>\n# 现在进行 push 就不会报错了\n$ git push <name> master","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"注：在之后为了方便学习，将一些命令与视频里面的进行同步，<name> 会用 github 来代替，因为我们把远端的仓库 fetch 下来并且命名为 gitHub 了","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"个人笔记总结git remote -v 查看远程版本库信息\ngit remote add <name> <url>添加 githup 远程版本库\ngit fetch <name> 拉取远程版本库\ngit merge -h 查看合并帮助信息\ngit merge --allow-unrelated-histories githup/master 合并 <name> 上的 master 分支（两分支不是父子关系，所以合并需要添加 –allow-unrelated-histories）\ngit push <name> 推送同步到 <name> 仓库—— by DriveMan_邱佳源","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"fast forward 到底是什么？举个例子，本地分支往远端分支做 push，如果远端分支不是本地分支的祖先，那它俩就不是 fast forward 了。反之，它俩就是 fast forward 的关系。","category":"page"},{"location":"git/git_notebook/#第四章-Git-多人单分支集成协作","page":"Git 学习笔记","title":"第四章 Git 多人单分支集成协作","text":"","category":"section"},{"location":"git/git_notebook/#.-多个人对文件修改","page":"Git 学习笔记","title":"1. 多个人对文件修改","text":"","category":"section"},{"location":"git/git_notebook/#.1.-不同人修改了不同文件","page":"Git 学习笔记","title":"1.1. 不同人修改了不同文件","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# \n# 会出现 Non fast_forwards 的报错，远端仓库会拒绝这个 push\n# 先把远端的 fetch 下来\n$ git fetch <name>(github)\n# 然后查看 branch 会发现有 [ahead 1, behind 1] 这样的信息，\n# 代表远端有的这里没有和这里有的远端没有\n$ git branch -av\nfeature/add_git_commands     07c85df [ahead 1, behind 1] ......\n\n# 有时候会考虑合并\n$ git merge (github/feature/add_git_commands)","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"老师你好，我有个问题哈，clone 命令 git clone git@github.com:git2019/gitlearning.git 既然已经把远程仓库所有内容都克隆到本地了，为什么还需要 git checkout -b feature/addgitcommands origin/feature/addgit_command 命令基于远程分支在本地建立分支，不是从远程clone下来了嘛，为什么还要新建，难道 clone 命令不能克隆分支吗？作者回复：我们在本地无法直接在 clone 下来的远程分支上做变更的，只能基于远程分支建本地分支后，才能创建 commit。","category":"page"},{"location":"git/git_notebook/#.2.-不同人修改同一文件的不同区域","page":"Git 学习笔记","title":"1.2. 不同人修改同一文件的不同区域","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# pull 会把远端的内容拉下来，并且本地的也会进行更新\n# 简介的方法就是直接 pull，还有一种是 fetch + merge\n# 多查看 branch ，看看 ahead 和 behind 的数目\n$ git branch -av\n\n# 当只有 ahead 没有 behind 的时候，肯定是 fast-forward 可以提交","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"fast-forword 看了英语翻译为快进，结合 git branch -av 中的 ahead 和 behind，ahead 是本地仓库比远端仓库多 commit，behind 是本地仓库比远端仓库少 commit。对正常的备份系统来说，我本地只能比备份多，备份不可能比我本地多才是。然而，git 由于多用户提交原因出现备份比本地多了，本地滞后了，所以需要 pull 一下，让本地比备份相等或多，这种情况就是 fast forward ，也就是我本地要比备份快进。不知理解对否？作者回复：其实就是两个分支的关系为 0|n 或者 n|0 ，如果两个分支直接为 n|m 的关系就不是 fast forward 。A 分支比 B 分支多 5 个 commit，B 比 A 分支多 3 个 commit。A 和 B 就不是 fast forward。","category":"page"},{"location":"git/git_notebook/#.3.-不同人修改同一文件的同一区域","page":"Git 学习笔记","title":"1.3. 不同人修改同一文件的同一区域","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 如果 push 不上去，使用 merge 又提示已经更新到最新了\n# 就说明远端变了，要及时更新\n$ git pull\nAuto-merging (index.html)\nCONFLICT(content): Merge conflict in (index.html)\n# 提示 CONFLICT(content) 说明文件有冲突，不能自动合并 index.html\n# 打开这个文件，会提示哪里出现冲突\n$ vi index.html\n# 编辑完成后查看状态\n$ git status\n\n# 如果这个分支有问题了，可以用 --abort 退出合并\n$ git merge --abort\n$ git commit -am'(commit text)'","category":"page"},{"location":"git/git_notebook/#.-更改了文件名","page":"Git 学习笔记","title":"2. 更改了文件名","text":"","category":"section"},{"location":"git/git_notebook/#.1.-同时变更了文件名和内容","page":"Git 学习笔记","title":"2.1. 同时变更了文件名和内容","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 其中有一个人变更了文件名\n# 另一个人只变更了文件内容\n# pull 的话会智能识别问题\n$ git pull","category":"page"},{"location":"git/git_notebook/#.2.-同一文件改成不同的文件名","page":"Git 学习笔记","title":"2.2. 同一文件改成不同的文件名","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 依旧是报冲突\n$ git pull\n# 查看工作目录，会出现未命名的文件，和两个重命名的文件\n# 如果使用 diff 查看两个文件的差异，不会显示差异\n$ diff <file-1> <file-2>\n# 使用 status，会提示：\nboth deleted:  <oldfilename>\nadded by us:   <filename-1>\nadded by them: <filename-2>\n# 可以先移除不要的文件，再加上想要保存的文件名\n$ git rm <filename-2>\n$ git add <filename-1>\n$ git commit -am'(commit text)'","category":"page"},{"location":"git/git_notebook/#第五章-集成使用禁忌","page":"Git 学习笔记","title":"第五章 集成使用禁忌","text":"","category":"section"},{"location":"git/git_notebook/#.-禁止向集成分支执行-push-f","page":"Git 学习笔记","title":"1. 禁止向集成分支执行 push -f","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"-f, --force 是强制更新，即使不是 fast-forward 也可以 push。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 把历史 reset 到某个 log\n$ git reset --hard (b3f390c)\n# 强制 push，就会把在 b3f390c 后面做的改变都删除\n$ git push -f (origin) (feature/add_git_commands)","category":"page"},{"location":"git/git_notebook/#.-禁止向集成分支执行变更历史的操作","page":"Git 学习笔记","title":"2. 禁止向集成分支执行变更历史的操作","text":"","category":"section"},{"location":"git/git_notebook/#第六章-GitHub","page":"Git 学习笔记","title":"第六章 GitHub","text":"","category":"section"},{"location":"git/git_notebook/#.-核心功能","page":"Git 学习笔记","title":"1. 核心功能","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"代码预览、项目管理、集成、团队管理、社交编码（开源）、文档、存放代码。","category":"page"},{"location":"git/git_notebook/#.-寻找开源项目","page":"Git 学习笔记","title":"2. 寻找开源项目","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"使用高级搜索：光标放在搜索框里，按回车就会出现 advanced search 了。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"可以在 Help 上查看有哪些高级搜索的语法。  ","category":"page"},{"location":"git/git_notebook/#.-搭建个人博客","page":"Git 学习笔记","title":"3. 搭建个人博客","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"通过高级搜索在搜索框中输入 blog easily start in:readme stars:>5000 找到 jekyll-now 仓库。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"第一步就是 fork 一个到自己的账号里去。fork 完后修改工程名称：<username>.github.io","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"第二步修改 _config.yml。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 _posts 里面新增文件格式为：2018-12-24-<title>.md","category":"page"},{"location":"git/git_notebook/#第七章-团队协作","page":"Git 学习笔记","title":"第七章 团队协作","text":"","category":"section"},{"location":"git/git_notebook/#.-创建团队项目","page":"Git 学习笔记","title":"1. 创建团队项目","text":"","category":"section"},{"location":"git/git_notebook/#.-挑选合适的分支集成策略","page":"Git 学习笔记","title":"3. 挑选合适的分支集成策略","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在仓库的 Insights => Network 里可以看到特性分支演变历史。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 Options 的 Merge button 可以设置允许哪种合并。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"merge 把分支最后合并到 master 上去；\nsquash merging 把分支的所有 commits 变成一个，再放到主线上去。（在当前主线后面加上）\nrebase merging 把分支的所有 commits 添加到主线后面去。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"后面两种适合于线性开发的情况。","category":"page"},{"location":"git/git_notebook/#.-issue-跟踪","page":"Git 学习笔记","title":"4. issue 跟踪","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"issue 上有标签管理，对不同的问题进行分类。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"还可以对 issue 进行模型管理，自定义一些问题报告的模板。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"有 Bug report、Feature request 等。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"使用 Projects 的看板来管理 issue","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"点击 Pojects 进行看板（Board）的设置。","category":"page"},{"location":"git/git_notebook/#.-Code-review","page":"Git 学习笔记","title":"5. Code review","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 Settings 的 Branches 上可以设置特殊分支的保护规则。比如对于 master 分支进行 push 保护，每次 push 都要有特定人数去检查才能通过。","category":"page"},{"location":"git/git_notebook/#.-多分支的集成","page":"Git 学习笔记","title":"6. 多分支的集成","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"特性分支往主干合，要发 Pull requests。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git rerere 是一个隐藏功能，允许你让 Git 记住解决一个块冲突的方法，在下一次看到相同冲突时，自动解决。","category":"page"},{"location":"git/git_notebook/#第八章-GitLab","page":"Git 学习笔记","title":"第八章 GitLab","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"这两章先看视频过一遍，等到应用的时候可以复习。目前不知道具体的使用需求，先大概看个印象。","category":"page"},{"location":"git/git_notebook/#其它问题","page":"Git 学习笔记","title":"其它问题","text":"","category":"section"},{"location":"git/git_notebook/#.-在-Windows-上如何支持中文","page":"Git 学习笔记","title":"1. 在 Windows 上如何支持中文","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"参考解决 Git 在 windows 下中文乱码的问题.md。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"有一个注意的点：目前无法解决输入中文字符会显示乱码的问题解决方案：git commit 时，不用 -m 参数，直接回车让 vim 来处理\n进 vim 后按 i 进入编辑模式，完成后再保存退出","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"LeetCode 刷题会用到的知识点，包括语法、函数等等；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"各种数据类型的范围：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"int: -2147483648 2147483647，大约等于 -2times 10^9sim 2times 10^9.","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"位运算符：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"运算符 描述 实例\n& 按位「与」运算 \n| 按位「或」运算 \n^ 按位「异或」运算 \n~ 按位「取反」运算 \n<< 二进制左移运算 \n>> 二进制右移运算 ","category":"page"},{"location":"leetcode/leetcode/#数据结构","page":"LeetCode 刷题","title":"数据结构","text":"","category":"section"},{"location":"leetcode/leetcode/#向量（vector）","page":"LeetCode 刷题","title":"向量（vector）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"// 给向量 x 分配 size 个 value 值\nx.assign(int size, int value);\t\n// 给向量 x 分配从迭代器初始位置到最终位置的值\nx.assign(InputIterator first, InputIterator last);\t\n\n// 后面添加元素\nx.push_back();\n// 将最后元素弹出\nx.pop_back();","category":"page"},{"location":"leetcode/leetcode/#栈（stack）","page":"LeetCode 刷题","title":"栈（stack）","text":"","category":"section"},{"location":"leetcode/leetcode/#队列（queue）","page":"LeetCode 刷题","title":"队列（queue）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"// 生成方式\nstd::queue<std::string> q;\nstd::queue<std::string> q {arr};\n// 操作\n// 返回第一个元素的引用，如果 q 为空，返回值是未定义的\nq.front();\n// 返回最后一个元素的引用\nq.back();\n// 在尾部添加一个元素的副本\nq.push(const T& obj);\n// 在尾部生成对象\nq.emplace();\n// 删除第一个元素\nq.pop();\n// 返回元素个数\nq.size();\n// 判断是否为空\nq.empty();","category":"page"},{"location":"leetcode/leetcode/#链表（linked-list）","page":"LeetCode 刷题","title":"链表（linked-list）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"在 LeetCode 中链表节点的定义为：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"哑节点（Dummy node）：在操作链表时常用的技巧，它的 next 指针指向链表头节点。好处是不用对头节点进行特殊判断。","category":"page"},{"location":"leetcode/leetcode/#常用函数","page":"LeetCode 刷题","title":"常用函数","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"__builtin_popcount()：返回输入数据，二进制中「1」的个数，只对 int 类型；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"如果想要对 long int 和 long long 类型使用，可以分别用 __builtin_popcountl() 和 __builtin_popcountll","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"lower_bound(ForwardIterator first, ForwardIterator last, const T& val)：返回一个迭代指针，该指针指向在 [first, last) 中不小于 val 的第一个元素。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"isalpha(c)：判断 c 是否为一个字母。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"tolower(c)：将字母转为小写字母；toupper(c)：将字母转为大写字母；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"to_string(c)：将 c 转化为字符；","category":"page"},{"location":"leetcode/leetcode/#算法","page":"LeetCode 刷题","title":"算法","text":"","category":"section"},{"location":"leetcode/leetcode/#最高有效位","page":"LeetCode 刷题","title":"最高有效位","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"如果正整数 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位为 1，其余都是 0，因此 y (y-1)=0. 如果 yle x，则称 y 为 x 的「最高有效位」。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"题目 338. 比特位计数 利用这样的一个方式，动态地维护最高有效位 highBit，然后算出所有小于给定整数 n 的整数二进制表示包含 1 的数量。","category":"page"},{"location":"leetcode/leetcode/#最低有效位","page":"LeetCode 刷题","title":"最低有效位","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"对于正整数 x，将其二进制表示右移一位，得到 $","category":"page"},{"location":"leetcode/leetcode/#Brian-Kernighan-算法","page":"LeetCode 刷题","title":"Brian Kernighan 算法","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"记 f(x) 表示 x 和 x-1 进行「与」运算所得的结果（即 f(x)=x(x1)），那么 f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。参考 LeetCode 题目 461. 汉明距离。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"例如 x=10001000，x-1=10000111，那么 x(x-1)=10000000. ","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"利用 Brian kernighan 算法计算出一个数的二进制表示有多少个 1 的方法如下。不断让 s=f(s)，直到 s=0。每循环一次 s 都会删除二进制表示中最右侧的 1，最终的循环次数即为 s 二进制表示中的 1 的数量。","category":"page"},{"location":"leetcode/leetcode/#广度优先搜索（Breadth-First-Search）","page":"LeetCode 刷题","title":"广度优先搜索（Breadth-First Search）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"广度优先搜索 C++ 模板：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"private:\n\tstatic constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\npublic:\n\tvector<vector<int>> BFS(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size(0);\n        vector<vector<int>> seen(m, vector<int>(n));\n        queue<pair<int, int>> q;\n\n        // 广度优先搜索\n        while (!q.empty()) {\n            auto [i, j] = q.front();\n            q.pop();\n\t\t\tfor (int d = 0; d < 4; ++d) {\n                int ni = i + dirs[d][0];\n                int nj = j + dirs[d][1];\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && !seen[ni][nj]) {\n                    // ...;\t// 写某些具体的操作\n                    q.emplace(ni, nj);\n                    seen[ni][nj] = 1;\n                }\n            }\n        }\n        return ...;\t\t\t// 返回结果\n    }\n","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"Python3 模板","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"def BFS(self, matrix: List[List[int]]) -> ...:\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    m, n = len(matrix), len(matrix[0])\n    q = collections.deque(...);\t\t# 队列\n    seen = set(...)\t\t\t\t\t# 将见过的位置坐标放进集合里面\n    \n    while q:\n        i, j = q.popleft()\n        for d in range(4):\n            ni = i + dirs[d][0]\n            nj = j + dirs[d][1]\n            if (0 <= ni < m) and (0 <= nj < n) and ((ni, nj) not in seen):\n                # ...\t\t\t\t# 写某些具体操作\n                q.append((ni, nj))\n                seen.add((ni, nj))\n    return ...\t\t\t\t\t\t# 返回结果 ","category":"page"},{"location":"leetcode/leetcode/#深度优先搜索（Depth-First-Search）","page":"LeetCode 刷题","title":"深度优先搜索（Depth-First Search）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"// C++ 深度优先搜索 的框架\nvector<int> temp;\nvoid dfs(int cur, int n) {\n    if (cur == n + 1) {\n        // 记录答案\n        // ...\n        return;\n    }\n    // 考虑选择当前位置\n    temp.push_back(cur);\n    dfs(cur + 1, n, k);\n    temp.pop_back();\n    // 考虑不选择当前位置\n    dfs(cur + 1, n, k);\n}","category":"page"},{"location":"leetcode/leetcode/#回溯算法（Backtrack）","page":"LeetCode 刷题","title":"回溯算法（Backtrack）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"适用问题：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"解决一个问题有多个步骤\n每个步骤有多种方法\n需要找出所有的方法","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"原理：在一棵树上的深度优先遍历","category":"page"},{"location":"leetcode/leetcode/#做题记录","page":"LeetCode 刷题","title":"做题记录","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"时间复杂度：O(n)，空间复杂度：O(n).","category":"page"},{"location":"leetcode/leetcode/#二分搜索（Binary-Search）","page":"LeetCode 刷题","title":"二分搜索（Binary Search）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"二分查找的题目，就看 liweiwei 的题解就行了：写对二分查找不能靠模板，需要理解加练习 （附练习题）","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"一般情况下，边界设置为 left = mid + 1 与 right = mid，这个时候中点是下取整，即偏向于左边取：mid = (right - left) / 2 + left。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"当看到边界设置行为是 left = mid 与 right = mid - 1 的时候，需要将 mid = (right - left + 1) / 2 + left，即调整为上取整，即偏向于右边取。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"34. 在排序数组中查找元素的第一个和最后一个位置，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"33. 搜索旋转排序数组，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"81. 搜索旋转排序数组 II，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"153. 寻找旋转排序数组中的最小值，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"154. 寻找旋转排序数组中的最小值 II，我的题解；","category":"page"},{"location":"leetcode/leetcode/#栈","page":"LeetCode 刷题","title":"栈","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"剑指 Offer 09. 用两个栈实现队列，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"剑指 Offer 30. 包含min函数的栈，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"剑指 Offer 06. 从尾到头打印链表，我的题解；","category":"page"},{"location":"leetcode/leetcode/#树","page":"LeetCode 刷题","title":"树","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"前序遍历、中序遍历、后序遍历基本写法：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"144. 二叉树的前序遍历，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"94. 二叉树的中序遍历，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"145. 二叉树的后序遍历，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"关于前中后序三种遍历，极客时间王争的课程给了三个对应的递推代码","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"// 前序遍历\nvoid preOrder(Node* root) {\n  if (root == null) return;\n  print root // 此处为伪代码，表示打印root节点\n  preOrder(root->left);\n  preOrder(root->right);\n}\n\n// 中序遍历\nvoid inOrder(Node* root) {\n  if (root == null) return;\n  inOrder(root->left);\n  print root // 此处为伪代码，表示打印root节点\n  inOrder(root->right);\n}\n\n// 后序遍历\nvoid postOrder(Node* root) {\n  if (root == null) return;\n  postOrder(root->left);\n  postOrder(root->right);\n  print root // 此处为伪代码，表示打印root节点\n}","category":"page"},{"location":"leetcode/leetcode/#双指针","page":"LeetCode 刷题","title":"双指针","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"简单题：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"350. 两个数组的交集 II，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"中等题：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"82. 删除排序链表中的重复元素 II；","category":"page"},{"location":"leetcode/leetcode/#链表","page":"LeetCode 刷题","title":"链表","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"剑指 Offer 24. 反转链表，我的题解；","category":"page"},{"location":"leetcode/leetcode/#动态规划（Dynamic-Programming）","page":"LeetCode 刷题","title":"动态规划（Dynamic Programming）","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"动态规划的 liweiwei 有一个关于买卖股票问题的题解：暴力解法、动态规划（Java），还有股票问题系列通解（转载翻译）。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"简单题：","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"53. 最大子序和，我的题解；","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"经典股票系列问题","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"121. 买卖股票的最佳时机，简单题，我的题解。","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"122. 买卖股票的最佳时机 II，中等题，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"123. 买卖股票的最佳时机 III，困难题，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"188. 买卖股票的最佳时机 IV，困难题，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"309. 最佳买卖股票时机含冷冻期，中等题，","category":"page"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"714. 买卖股票的最佳时机含手续费，中等题，","category":"page"},{"location":"leetcode/leetcode/#哈希","page":"LeetCode 刷题","title":"哈希","text":"","category":"section"},{"location":"leetcode/leetcode/","page":"LeetCode 刷题","title":"LeetCode 刷题","text":"350. 两个数组的交集 II，我的题解；","category":"page"},{"location":"leetcode/leetcode/#/-题解草稿","page":"LeetCode 刷题","title":"0/ 题解草稿","text":"","category":"section"},{"location":"#Docs","page":"Home","title":"9Docs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"我是强劲九，9Docs 是我的个人笔记文档，记录了在编程学习上的记录，目的是方便自己查看。","category":"page"},{"location":"","page":"Home","title":"Home","text":"微信：strongnine；","category":"page"},{"location":"","page":"Home","title":"Home","text":"公众号：strongnine；","category":"page"},{"location":"#学习历程","page":"Home","title":"学习历程","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Git 学习笔记\nLeetCode 刷题笔记\n人工智能\n......","category":"page"}]
}
