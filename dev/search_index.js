var documenterSearchIndex = {"docs":
[{"location":"develop/#开发-and-程序设计","page":"-","title":"开发 & 程序设计","text":"","category":"section"},{"location":"develop/","page":"-","title":"-","text":"学习资料：博览网李建忠老师的课","category":"page"},{"location":"develop/#测试","page":"-","title":"测试","text":"","category":"section"},{"location":"develop/","page":"-","title":"-","text":"功能测试：最基本的测试，保证可用性和正确性。\n编写测试用例常用方法：等价类划分、边界值分析、错误推测、因果图、判断表驱动、正交试验法、功能图；\n分析业务逻辑、用户操作场景、异常场景、关联业务；\n掌握常用 Linux 命令、查看后台日志、掌握 SQL 语句；\n测试报告，体现测试价值，总结风险点；\n接口测试：\n网络协议：http, https, soup, rpc, ssh, telnet；\n抓包协议：fiddler, wireshark, burpsuit；\n接口测试工具：postman, soupui, Java 语言调用（httpclient 包、jmeter 包）、Python 语言调用（request 库）；\n自动化测试：\nUI 功能自动化、接口自动化、接口参数化；\n调试能力：打断点；\n做好分析设计，将维护成本不高的业务做成自动化，设计相关的测试用例，原则是还原用户操作；\n性能测试：\n常用软件：jmeter, loadrunner，测试报告中的细节才能体现报告中指示的问题；\n由于系统的特殊性，例如 jmeter 调用 dubbo 接口、打印日志都需要用语言完成；\n深入理解 Linux，系统配置会影响测试结果，要监控 CPU、磁盘、内存、网络；\n熟悉各种数据结构和算法；\n使用辅助工具解决内存溢出、CPU 占用过高、读写数据库、网络长短连接；\n熟悉使用各种中间件：Tomcat, Nginx node, Redis, MySQL；\n敏捷开发：就是快速开发，具体要团队间了解彼此之间的进度，遇到问题共同讨论，促进问题快速解决，保证项目按期完成\n持续集成（CI）和持续交互（CD）：一个项目由项目负责人拆分成多个模块，分给团队的每个人合作完成，其中一部分功能模块完成要做持续集成以便进行测试，持续集成部分完成测试即可持续交互，敏捷测试过程中最重要的是保证持续交互","category":"page"},{"location":"develop/#问题","page":"-","title":"问题","text":"","category":"section"},{"location":"develop/","page":"-","title":"-","text":"❓C++ 与设计模式的关系是什么？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"这些文章对于 C++ 设计模式的讲解很详细：C++ 各类设计模式及实现详解、C++ 常用设计模式、知乎专栏：C++ 设计模式","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓为什么要有设计模式？什么是单例模式和工厂模式？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"设计模式（Design Patterns）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。","category":"page"},{"location":"develop/","page":"-","title":"-","text":"设计模式分类：","category":"page"},{"location":"develop/","page":"-","title":"-","text":"创建类模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式（共五种）；\n结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式（共七种）；\n行为型模式：模板方式模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式（共十一种）；\n另外还有并发型模式和线程池模式；","category":"page"},{"location":"develop/","page":"-","title":"-","text":"单例模式：采取方法，使整个软件系统中，对某个类只存在一个对象实例。并且该类只提供一个取得其对象实例的方法（静态方法）。","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓什么是设计模式的六大原则？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"总原则：开闭原则（Open Close Principle, OCP），对外扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现热插拔的效果。因此，要使用接口和抽象类等；","category":"page"},{"location":"develop/","page":"-","title":"-","text":"六大原则：","category":"page"},{"location":"develop/","page":"-","title":"-","text":"单一职责原则（Single Responsibility Principle, SRP）：不要存在多于一个导致类变更的原因，每个类应该实现单一的职责，如果不这样就应该把类拆分；\n里氏替换原则（Liskov Substitution Principle, LSP）：是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响的时候，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。LSP 是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以 LSP 是对实现抽象化的具体步骤的规范。LSP 中子类对父类的方法尽量不要重写和重载，因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏；\n依赖倒转原则（Dependence Inversion Principle, DIP）：是 OCP 的基础。面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互；\n接口隔离原则（Interface Segregation Principle, ISP）：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好；\n最少知道原则（The Least Knowledge Principle, LKP）：又称迪米特法则（Law of Demeter, LOD），就是说一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过 Public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。LOD 的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中；\n合成复用原则（Composite Reuse Principle, CRP）：尽量首先使用合成/聚合的方式，而不是使用继承；","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓五个设置原则是什么？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓怎么去决定项目中的存储结构的，有什么考量？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓什么是内存池？怎么去设计？怎么去测试性能会提升多少？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓如果是线上的一个系统，怎么直接用线上数据来进行测试？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓设计一个系统要考虑的指标有什么？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓如果用户说，访问服务的时候偶尔会延迟，怎么去找问题？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"可能出现的问题：","category":"page"},{"location":"develop/","page":"-","title":"-","text":"服务器系统能力不足： 当用户量上升时导致服务器提供服务能力下降，数据处理时间冗余，导致用户延迟；\n需要分析系统的瓶颈在哪？一般系统的瓶颈都在于 IO 问题上和并发处理请求上。最大的问题可能都是在于 IO 阻塞。\n数据是否可以分为冷热分离？ 是否有最近一周或者一段时间数据访问量达到百分之九十而之前的数据很少被访问到。\n网络问题：是否因为用户距离服务器部署地的网络延迟很高，导致在链路上产生了延迟；\n用户和服务器部署地距离长，网络延迟高，丢包率高。\n系统之间的网络调用次数过多导致网络延迟。","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓看日志里的什么指标，怎么定你要看的指标？","category":"page"},{"location":"develop/","page":"-","title":"-","text":"❓","category":"page"},{"location":"dataStruc&algo/interview/#笔试","page":"-","title":"笔试","text":"","category":"section"},{"location":"dataStruc&algo/interview/#笔试：Python-输入输出的处理","page":"-","title":"笔试：Python 输入输出的处理","text":"","category":"section"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"Python 的输出输出处理：","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"在 Python 中调用 print 时，实际上是调用 sys.stdout.write(obj + '\\n')。sys.stdin.readline() 会将标准输入全部获取，包括末尾的换行符 \\n，因此用 len 计算长度是包含了换行符的，用这种方法输入时可以用 strip() 来去掉换行符（或者用 sys.stdin.readline()[:-1]）。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"sys.stdin.readline().trip() 就等价于 input()。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"注意：Python 2 和 Python 3 的输入输出稍微有区别。在使用 Python 2 的时候最好用 sys.stdin 的方式读取，用 input() 对于字符串和数字相混合的输入会报错。例如对于 S 0 这种数据，Python 2 要求对于字符串需要用引号，如 “S” 0，否则无法识别。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"import sys\n# strip() 去掉两端的空白符，返回 str\n# split() 按照空白符分割，返回 List[str]\n# map(type, x) 把列表 x 中的元素映射成类型 type\n# 1. 题目没有告知多少组数据时，用 while True\nwhile True:\n    try:\n        # ...\n    except:\n        break\n        \n# 2. 题目告知有 T 组数据时，用 For loop\nT = int(input().strip())\nfor _ in range(T):\n    # ...\n    \n    \n# 3. 不同的输入\ns = input().strip()  # 输入一个字符\nstr_ = sys.stdin.readline().strip()  # 读取一行\nnum = int(input().strip())  # 输入一个整数\nnums = list(map(int, input().strip().split()))  # 输入一个整数列表","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"要是想要写完整一点可以：","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"import sys\n\nif __name__ == \"__main__\":\n    # 读取一个整数\n    n = int(sys.stdin.readline().strip())\n    matrix = list()\n    # 读取多行保存到一个列表中, 组成一个矩阵\n    for _ in range(n):\n        line = sys.stdin.readline().strip()\n        row = list(map(int, line.split()))\n        matrix.append(row)","category":"page"},{"location":"dataStruc&algo/interview/#C：输入输出的处理","page":"-","title":"C++：输入输出的处理","text":"","category":"section"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"#include <iostream>\nusing namespace std;\n\nint main() {\n    int a;  // 先声明一个数的类型\n    float b;\n    char c;\n    string s;\n    cin >> a;  // 输入一个数\n    cout << a << endl;  // 输出一个数\n    \n    return 0;\n}","category":"page"},{"location":"dataStruc&algo/interview/#通过排除法找质数个数","page":"-","title":"通过排除法找质数个数","text":"","category":"section"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"给定以下代码一个数，返回该数范围内的素数个数。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"import math\ndef sieve(size):\n    sieve = [True] * size\n    sieve[0] = False\n    sieve[1] = False\n    for i in range(2, int(math.sqrt(size)) + 1):\n        k = i * 2\n        while k < size:\n            sieve[k] = False\n            k += i\n    return sum(1 for x in sieve if x)","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"质数：又称素数，在大于 1 的自然数中，除了 1 和该数自身之外，无法被其他自然数整除的数，即只有 1 于其本身两个正因数。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"","category":"page"},{"location":"dataStruc&algo/interview/#下一个字典序","page":"-","title":"下一个字典序","text":"","category":"section"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"给你一个整数数组 nums ，找出 nums 在字典序中的下一个排列。必须 原地 修改，只允许使用额外常数空间。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"需要找到一个左边的「较小数」和右边的「较大数」，同时要求「较小数」尽量靠右，「较大数」尽可能小。具体做法如下：","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"从后向前查找第一个顺序对 (i, i + 1)，满足 a[i] < a[i + 1]，a[i] 即为想要的「较小数」，此时 (i + 1, n) 必然是下降序列；\n在区间 [i + 1, n - 1] 中从后向前查找第一个元素 j 满足 a[i] < a[j]，a[j] 即为想要找的「较大数」；\n交换 a[i] 与 a[j]，可以证明区间 [i + 1, n - 1] 必为降序，我们可以直接使用双指针反转区间 [i + 1, n - 1] 使其变为升序；","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"如果步骤 1 找不到满足条件的顺序对，说明当前序列已经是一个降序序列，是最大的序列，可以直接跳过步骤 2 执行步骤 3。","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"def nextPermutation(self, nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    i = len(nums) - 2\n    # Step 1. 找到满足 a[i] < a[i + 1] 的顺序对\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:  # 找不到顺序对，说明当前序列已经是一个降序序列\n        j = len(nums) - 1\n        # Step 2. 在区间 [i + 1, n) 中查找第一个满足 a[i] < a[j] 的 j\n        while j >= 0 and nums[i] >= nums[j]:\n            j -= 1\n        # 交换 a[i], a[j], 可以证明区间 [i + 1, n) 一定是降序的\n        nums[i], nums[j] = nums[j], nums[i]\n        \n    # Step 3. 用双指针的方式去反转区间 [i + 1, n) 使其变为升序\n    left, right = i + 1, len(nums) - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1","category":"page"},{"location":"dataStruc&algo/interview/#双十一购物（动态规划）","page":"-","title":"双十一购物（动态规划）","text":"","category":"section"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"这个题目的基础是 0 - 1 背包：","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"def double11advance(items: List[int], n: int, w: int, th: int) -> None:\n    # w 是预算, th 是满减的门槛\n    states = [[False for _ in range(w + 1)] for _ in range(n)]\n    states[0][0]  # True 不买立省 100%\n    if items[0] <= w:\n        states[0][items[0]] = True\n    \n    for i in range(1, n):\n        for j in range(w + 1):  # 不买第 i 个物品\n            if states[i - 1][j] == True:\n                states[i][j] = states[i - 1][j]\n        \n        for j in range(w - items[i] + 1):  # 购买第 i 个物品\n            if states[i - 1][j] = True:\n                states[i][j + items[i]] = True\n\t\n    # 输出花费超过满减门槛又尽可能小的价格\n    j = th\n    while j < w:\n        if states[n - 1][j] == True:\n            print(\"薅羊毛最少花费： \", j)\n            break\n    \tj += 1\n    if j == w:\n        print(\"选的这些东西薅不到羊毛呀！\")\n    else:\n        print(\"可以薅到羊毛, 下面输出可以购买的物品清单.\")\n        for i in range(n - 1, 0, -1):\n            if j - items[i] >= 0 and states[i - 1][j - items[i]] == True:\n                print(i, end=\" \")\n                j = j - items[i]\n\t\tif j != 0:\n            print(items[0], end=\" \")\n        print(\"\\n\")","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"关于输出可以购买的物品清单，状态 [i][j] 只有可能从 [i - 1][j] 或者 [i - 1][j - value[i]] 两个状态推导过来。因此可以检查这两个状态是否可达，即 states 里面是否为 True。假如两个状态都为 True，那么就随便选择一个。","category":"page"},{"location":"dataStruc&algo/interview/#问题","page":"-","title":"问题","text":"","category":"section"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"❓海量数据处理：有一个十分大的数据库（例如是 1G），但是现有的内存很小（可能只有 1M），要怎么找到出现频数最高的 100 个词？","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"使用分治法，先用哈希映射把大文件分成很多个小文件。例如以此读取文件的每一个词，取 hash(x) % 5000，然后把该值存到 5000 个对应的小文件中，这样每个文件大概是 200k 左右。并且，每个相同的词一定被映射到了同一个文件中；\n对于每一个小文件，用 hash_map 对词和出现频率进行统计，取出频率大的前 100 个词（利用 Top-K 问题，建立一个 100 个节点的最小堆），把这 100 个词和出现频率再单独存入一个文件；\n上述处理完之后，得到 5000 个文件，归并文件取出 Top-100；","category":"page"},{"location":"dataStruc&algo/interview/","page":"-","title":"-","text":"如果不是用哈希映射将不同的单词分到同一个文件，而是随机分成多份小文件，相同的单词被分到了不同的文件中，后面的归并步骤就无法做了。参考：十道海量数据处理面试题与十个方法大总结","category":"page"},{"location":"AI/Transformer/#Transformer-知识总结","page":"Transformer","title":"Transformer 知识总结","text":"","category":"section"},{"location":"AI/Transformer/#原理","page":"Transformer","title":"原理","text":"","category":"section"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"Transformer 整个网络结构由 Attention 机制组成。在 RNN（包括 LSTM、GRU 等）中计算是顺序的，只能从左向右或者从右向左依次计算，这种机制带来的 2 个问题：","category":"page"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"时间片 t 的计算依赖 t-1 时刻的计算结果，限制了模型的并行能力；\n顺序计算的过程中信息会丢失。尽管 LSTM 使用门机制的结构来缓解长期依赖的问题，但是在特别长期时依旧表现不好；","category":"page"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"Transformer 通过以下方式来解决上面的问题：","category":"page"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"使用 Attention 机制，讲序列中的任意两个位置之间的距离缩小为一个常量；\n因为不是类似 RNN 的顺序结构，因此具有更好的并行性。也更为符合现有的 GPU 框架；","category":"page"},{"location":"AI/Transformer/#Encoder-和-Decoder-模块","page":"Transformer","title":"Encoder 和 Decoder 模块","text":"","category":"section"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"Encoder 模块将 Backbone 输出的 feature map 转换成一维表征，然后结合 positional encoding 作为 Encoder 的输入。每个 Encoder 都由 Multi-Head Self-Attention 和 FFN 组成。和 Transformer Encoder 不同的是，因为 Encoder 具有位置不变性，DETR 将 positional encoding 添加到每一个 Multi-Head Self-Attention 中，来保证目标检测的位置敏感性。","category":"page"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"Decoder 也具有位置不变性，Decoder 的 n 个 object query（可以理解为学习不同 object 的 positional embedding）必须是不同的，以便产生不同的结果，并且同时把它们添加到每一个 Multi-Head Attention 中。n 个 object queries 通过 Decoder 转换成一个 output embedding，然后 output embedding 通过 FFN 独立解码出 n 个预测结果，包含 box 和 class。对输入 embedding 同时使用 Self-Attention 和 Encoder-Decoder Attention，模型可以利用目标的相互关系来进行全局推理。","category":"page"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"和 Transformer Decoder 不同的是，DETR 的每个 Decoder 并行输出 n 个对象，Transformer Decoder 使用的是自回归模型，串行输出 n 个对象，每次只能预测一个输出序列的一个元素。","category":"page"},{"location":"AI/Transformer/#多头注意力（Multi-Head-Attention）","page":"Transformer","title":"多头注意力（Multi-Head Attention）","text":"","category":"section"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"多头注意力的提出是为了对同一 key、value、query，希望抽取不同的信息，例如短距离和长距离，类似于 CV 中的感受野（field）。","category":"page"},{"location":"AI/Transformer/#参考","page":"Transformer","title":"参考","text":"","category":"section"},{"location":"AI/Transformer/","page":"Transformer","title":"Transformer","text":"[1] 知乎专栏：计算机视觉面试题 - Transformer 相关问题总结，作者：爱者之贻","category":"page"},{"location":"dataStruc&algo/leetcode_top100/#哈希","page":"-","title":"哈希","text":"","category":"section"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"1. 两数之和【简单】","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】整数数组 nums 和整数目标值 target","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】和为 target 的两个整数在 nums 中的下标（输入保证只会有一个答案）","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"建立哈希表 hashmap，保存 target - nums[i]: i；\n对于数组中的每一个数字 x：\n如果 target - x 存在于 hashmap 中，返回对应的下标以及当前的下标；\n否则将当前的键值对加入到 hashmap 中；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/#二分","page":"-","title":"二分","text":"","category":"section"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"4. 寻找两个正序数组的中位数【困难】","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】大小分别为 m 和 n 的正序数组 nums1 和 nums2","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】这两个数组的中位数","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"中位数：","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"当 m + n 是奇数，中位数是两个有序数组中的第 (m + n) // 2 个元素；\n当 m + n 是偶数，中位数是第 (m + n) // 2 和第 (m + n) // 2 + 1 个元素的平均值；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"这道题可以转化成寻找两个有序数组中的第 k 小的数，k 为 (m + n) // 2 和 (m + n) // 2 + 1。","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"对于两个有序数组 A 和 B，比较 A[k // 2 - 1] 和 B[k // 2 - 1]，它们前面都只有 k // 2 - 1 个元素，因此对于它们中的较小值，最多只会有 (k // 2 - 1) + (k // 2 - 1) <= k - 2 个元素比它小，因此 A[k // 2 - 1] 和 B[k // 2 - 1] 中的最小值以及其前面的数字都不可能是第 k 小的数，即不是中位数：","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"如果 A[k // 2 - 1] <= B[k // 2 - 1]，那么可以排除 A[0] 到 A[k // 2 - 1]；\n如果 A[k // 2 - 1] > B[k // 2 - 1]，那么可以排除 B[0] 到 B[k // 2 - 1]；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"我们在排除后的数组上继续进行二分查找，根据排除的个数，减少 k 的值，有三种情况要特殊处理：","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"如果 A[k // 2 - 1] 或者 B[k // 2 - 1] 越界，可以选取对应数组中的最后一个元素。这种情况下，根据排除数的个数减少 k 的值，而不是直接将 k 减去 k // 2；\n如果一个数组为空，直接返回另一个数组中第 k 小的元素；\n如果 k = 1 只需要返回两个数组首元素的最小值就可以；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"编写一个函数 getKthElement(k) 用于寻找第 k 个大小的数：","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"index1 和 index2 是两个数组的偏移指针，代表已经排除了之前的多少个元素，初始化为 0；\n特殊情况处理：\n如果其中一个偏移指针为数组长度，代表这个数组为空，那么返回另一个数组的第 k 小的元素（需要注意，k 在循环中是会根据已经排除的元素进行减少的）；\n如果当前的 k == 1，直接返回两个数组首元素的最小值；\n正常情况：得到指针，如果越界则指向数组最后一个数（用 min() 去做）：\n得到指针指向的元素 pivot1 和 pivot2；\n如果 pivot1 <= pivot2，k 减去排除的元素个数，更新数组 nums1 的偏移指针 index1；\n如果 pivot1 > pivot2，k 减去排除的元素个数，更新数组 nums2 的偏移指针 index2；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"如果 m + n 为奇数，使用函数 getKthElement() 返回 (m + n + 1) // 2 小的数；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"如果 m + n 为偶数，返回 (m + n) // 2 和 (m + n) // 2 + 1 两个数的平均值；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/#双指针","page":"-","title":"双指针","text":"","category":"section"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"3. 无重复字符的最长子串","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】一个字符串 s","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】不含有重复字符的最长子串的长度","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"右指针 r 的初始值为 -1，左指针 l 遍历 [0, n - 1]；\n左指针每向右移动一次，哈希集合 hashset 中要删除对应的字母；\n对于左指针的每个位置，判断右指针能到多远，如果下一个字母不存在于 hashset 中就可以继续往后走","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"11. 盛最多水的容器【中等】","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】长度为 n 的整数数组 height，其中每个数可以代表容器壁的高度","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】返回最大容器的容量","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"两个指针初始化指向数组的两端；\n每次判断计算当前的容量，并且同步更新最大容量；\n每次都把较小值的指针向中间移动；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"15. 三数之和【中等】","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】整数数组 nums","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】返回所有和为 0 且不重复的三元组","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"对数组进行排序；\n首先选定第一个数字 a，并且保证 a 与上一次选择的数不一样；\n之后两个指针 second 和 third；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/#动态规划","page":"-","title":"动态规划","text":"","category":"section"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"5. 最长回文子串【中等】","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】字符串 s","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】s 中的最长回文子串","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"状态转移方程：","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"P(ij)=P(i + 1 j - 1)land (S_i==S_j)","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"边界条件：","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"长度为 1 的子串一定是回文串 P(i, i) = True；\n长度为 2 的子串，当且仅当两个字符是一样的才为回文串 P(i i + 1) = (S_i == S_i+1)；","category":"page"},{"location":"dataStruc&algo/leetcode_top100/#深广度优先搜索","page":"-","title":"深广度优先搜索","text":"","category":"section"},{"location":"dataStruc&algo/leetcode_top100/#未分类","page":"-","title":"未分类","text":"","category":"section"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"2. 两数相加【中等】","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输入】两个非空链表，按照逆序存储一个非负的整数（保证数字不以 0 开头）","category":"page"},{"location":"dataStruc&algo/leetcode_top100/","page":"-","title":"-","text":"【输出】返回一个链表存储输入的两个数的和","category":"page"},{"location":"AI/RS/#大规模分段线性模型（LS-PLM）","page":"-","title":"大规模分段线性模型（LS-PLM）","text":"","category":"section"},{"location":"AI/RS/","page":"-","title":"-","text":"早在 2012 年，大规模分段线性模型（Large Scale Piece-wise Linear Model）就是阿里巴巴的主流推荐模型，又被称为混合逻辑回归（Mixed Logistics Regression），可以看作在逻辑回归的基础上采用分而治之的思路，先对样本进行分片，再在样本分片中应用逻辑回归进行 CTR（Click Through Rate，点击率）预估。","category":"page"},{"location":"AI/RS/#Embedding-技术","page":"-","title":"Embedding 技术","text":"","category":"section"},{"location":"AI/RS/","page":"-","title":"-","text":"Embedding，中文译为「嵌入」，常被翻译为「向量化」或者「向量映射」。形式上讲，Embedding 就是用一个低维稠密的向量「表示」一个对象，可以是词、商品、电影。","category":"page"},{"location":"AI/RS/#搜索相关性","page":"-","title":"搜索相关性","text":"","category":"section"},{"location":"AI/RS/","page":"-","title":"-","text":"搜索相关性旨在计算 Query 和返回 Doc 之间的相关程度，也就是判断 Doc 中的内容是否满足用户 Query 的需求，对应 NLP 中的语义匹配任务（Semantic Maching）。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"早期文本匹配：仅仅考虑 Query 与 Doc 的字面匹配程度，通过 TF-IDF、BM25 等基于 Term 的匹配特性来计算相关性。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"优点：线上计算效率高\n缺点：（1）基于 Term 的关键词匹配泛化性能较差，缺少语义和词序信息；（2）无法处理一词多义或多词一义的问题，漏匹配和误匹配现象严重。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"传统语义匹配模型：主要包括（1）隐式空间的匹配：将 Query 和 Doc 都映射到同一个空间的向量，再用向量距离或相似度作为匹配分，如 Partial Least Square (PLS)；（2）基于翻译模型的匹配：将 Doc 映射到 Query 空间后进行匹配或计算 Doc 翻译成 Query 的概率。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"深度语义匹配模型：实现方法上分为基于表示（Representation-based）和基于交互（Interaction-based）的方法。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"基于表示的深度语义匹配模型：分别学习 Query 和 Doc 的语义向量表示，再基于两个向量计算相似度。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"DSSM 模型 [微软]：提出经典的双塔结构的文本匹配模型，分别使用相互独立的两个网络结构构建 Query 和 Doc 的向量表示，用余弦相似度衡量两个向量的相关程度。\nNRM [微软 Bing 搜索]：针对 Doc 表征问题，除了基础的 Doc 标题和内容，还考虑了其他多源信息（每类信息称为一个域 Field），如外链、用户点击过的 Query 等，考虑一个 Doc 中有多个 Field，每个 Field 内又有多个实例（Instance），每个 Instance 对应一个文本，如一个 Query 词。模型首先学习 Instance 向量，将所有 Instance 的表示向量聚合起来就得到一个 Field 的表示向量，将多个 Field 的表示向量聚合起来得到最终 Doc 的向量。\nSentenceBERT：将预训练模型 BERT 引入到双塔的 Query 和 Doc 的编码层，采用不同的 Pooling 方式获取双塔的句向量，通过点乘、拼接等方式对 Query 和 Doc 进行交互。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"基于交互的深度语义匹配模型：不直接学习 Query 和 Doc 的语义表示向量，而是在底层输入阶段就让 Query 和 Doc 进行交互，建立一些基础的匹配信号，再将基础匹配信号融合成一个匹配分。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"ESIM：是预训练模型引入之前被业界广泛使用的经典模型，首先对 Query 和 Doc 进行编码得到初始向量，再用 Attention 机制进行交互加权后与初始向量进行拼接，最终分类得到相关性得分。引入预训练模型 BERT 进行交互计算时，通常将 Query 和 Doc 拼接作为 BERT 句间关系任务的输入，通过 MLP 网络得到最终的相关性得分。\nCEDR：在 BERT 句间关系任务获得 Query 和 Doc 向量之后，对 Query 和 Doc 向量进行拆分，进一步计算 Query 与 Doc 的余弦相似矩阵。","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"参考","category":"page"},{"location":"AI/RS/","page":"-","title":"-","text":"[1] 王喆，《深度学习推荐系统》2020","category":"page"},{"location":"math/#概率论与数理统计","page":"-","title":"概率论与数理统计","text":"","category":"section"},{"location":"math/#各种分布","page":"-","title":"各种分布","text":"","category":"section"},{"location":"math/","page":"-","title":"-","text":"正态分布","category":"page"},{"location":"math/","page":"-","title":"-","text":"Gamma 分布","category":"page"},{"location":"math/","page":"-","title":"-","text":"Gibbs 采样","category":"page"},{"location":"math/","page":"-","title":"-","text":"MCMC 采样","category":"page"},{"location":"math/","page":"-","title":"-","text":"Pearson 要求连续性，Spearman 只要求单调就可以了，不一定要连续性。","category":"page"},{"location":"math/","page":"-","title":"-","text":"Pearson 线性相关系数：","category":"page"},{"location":"math/","page":"-","title":"-","text":"必须假设数据是成对地从正太分布中取得的；\n数据至少在逻辑范围内是等距的；","category":"page"},{"location":"math/","page":"-","title":"-","text":"Spearman 秩相关系数是一种无参数（与分布无关）检验方法，用于度量变量之间联系的强弱。在没有重复数据的情况下，如果一个变量是另一个变量的严格单调函数，则 Spearman 秩相关系数就是 +1 或 -1，称变量完全 Spearman 秩相关。","category":"page"},{"location":"math/","page":"-","title":"-","text":"注意：只有当两个变量存在线性关系时，Pearson 相关系数才为 +1 或 -1.","category":"page"},{"location":"math/#线性代数","page":"-","title":"线性代数","text":"","category":"section"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"多模态数据：文本、图像、音频、视频、结构化数据","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"自然语言处理发展的三个阶段：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"1950 ～ 1970 年：基于经验、规则的阶段；\n1970 ～ 2008 年：基于统计方法的阶段；\n2008 年至今：基于深度学习技术的阶段；","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"贝叶斯模型","category":"page"},{"location":"AI/NLP/#词袋模型","page":"自然语言处理","title":"词袋模型","text":"","category":"section"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"词袋模型（Bag-of-words, BOW）：假设词与词之间是上下文独立的，即不考虑词之间的上下文关系；","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"优点：\n简单易用速度快；\n在丢失一定预测精度的前提下，很好地通过词出现的频率来表征整个语句的信息；\n缺点：仅考虑词在一个句子中是否出现，而不考虑词本身在句子中的重要性（使用 TF-IDF 可以考虑重要性）；","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"对于两个语句：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"\"We have noticed a new sign in to your Zoho account.\"\n\"We have sent back permission.\"","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"构造语料字典：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"{\n    'We': 2, 'have': 2, 'noticed': 1, 'a': 1,\n    'new': 1, 'sign': 1, 'in': 1, 'to': 1,\n    'your': 1, 'Zoho': 1, 'account': 1, 'sent': 1,\n    'back': 1, 'permission.': 1\n}\n# 上面两个语句生成的 BOW 特征分别为：\n[1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1]\n[0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0]","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"TF-IDF（Term Frequency-Inverse Document Frequency）：使用 textTFtimes textIDF 对每一个出现的词进行加权：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"textTF-IDF(td)=textTF(td)times textIDF(t)","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"其中 textTF(td) 为单词 t 在文档 d 中出现的频率，textIDF(t) 是逆文档频率，用来衡量单词 t 对表达语义所起的重要性，表示为：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"textIDF(t) = logfractextNum of articlestextNum of articles containing word t+1","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"直观解释为，如果一个单词在非常多的文章里面都出现，那么它可能是一个比较通用的词汇，对于区分谋篇文章特殊语义的贡献比较小，因此对权重做一定惩罚。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"优点：简单易用速度快；\n缺点：文本语料稀少、字典大小大于文本语料大小时，容易发生过拟合；","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"N-Gram 语言模型：假设有一个句子 S(w_1w_2w_3cdotsw_n)，其中 w_i 代表句子中的词，那么这个句子的出现概率就是所以单词出现概率的乘积 p(S)=p(w_1)times p(w_2)times p(w_3)timescdotstimes p(w_n). 在此基础上加上马尔科夫假设，即当前词的出现之和前 n 个词有关，则有：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"p(S) = p(w_1)times p(w_2mid w_1)timescdots times p(w_nmid w_n-1)","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"N-Gram 模型可以与 BOW、TF-IDF 模型相结合，构建 Bi-Gram、Tri-Gram 等生成额外的稀疏特征向量，构建出来的特征比使用 Uni-Gram 的 BOW、TF-IDF 特征更具有表征能力。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"词袋模型的问题：如果近义词出现在不同文本中，那么在计算这一类文本的相似度或者进行预测时，如果训练数据不含大量标注，就会出现无法识别拥有相似上下文语义词的情况；","category":"page"},{"location":"AI/NLP/#词嵌入模型","page":"自然语言处理","title":"词嵌入模型","text":"","category":"section"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"Word2Vec：常用的模型训练方式为 CBOW 和 Skip-Gram 两种算法。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"glove：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"fastText：","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"针对中文词向量的预训练，有腾讯公开的 AI Lab 词向量。","category":"page"},{"location":"AI/NLP/#深度学习","page":"自然语言处理","title":"深度学习","text":"","category":"section"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"TextCNN：模型结构简单，训练和预测速度快，同时拥有比传统模型更高的精度。采用多尺度卷积来模拟 N-Gram 模型在文本上的操作，最终合并之后进行呢预测。适合短文本以及有明显端与结构的语料。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"DPCNN：从 ResNet 结构中借鉴了残差块（residual block）的理念，模拟 CV 任务中对于图像特征进行逐层提取的操作。相比较于 TextCNN 能够在文本结构复杂、语义丰富或者上下文依赖性强的文本上有更好的表现。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"LSTM 类模型：包括典型双向循环神经网络结构 LSTM、Bi-LSTM、Bi-GRU + Attention，LSTM 和 GRU 层具有非常好的时序拟合能力。Attention 机制对不同时间的状态值进行加权，能够进一步提升模型的预测能力，适合具有复杂语义上下文的文本。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"Attention 机制：从原理上分析，是一种对词在句子中的不同状态进行加权的操作，从最原始的加权平均，逐步发展到 Self-Attention。通过使用词的相似度矩阵进行计算，调整词在句子中对应的权重，从而允许将词的加权求和作为输出或者下一层的输入。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"现有的上下文相关的预训练模型包括：ELMo、GPT、BERT、BERT-wwm、ERNIE_1.0、XLNet、ERNIE_2.0、RoBERTa、ALBERT、ELECTRA","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"ELMo：是一个采用自回归语言模型方式训练的语言模型。自回归语言模型的本质是通过输入的文本序列，对下一个词进行预测，通过不断优化预测的准确率，使模型逐步学到上下文的语义关系。ELMo 的结构包括正向 LSTM 层和反向 LSTM 层，通过分别优化正向下一次词和反向下一个词达到更好的预测效果。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"GPT：将 Multi-Head Attention 和 Transformer 结构应用到了语言模型的预训练上，采用正向 Transformer 结构，去除了其中的解码器，同 ELMo 模型一样，采用自回归语言模型的方式进行训练。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"BERT：使用自编码器模式进行训练，模型结构中包含正向和反向 Transformer 结构。为了减少由双向 Transformer 结构和自编码器造成的信息溢出影响，BERT 在训练中引入了 MLM，防止 BERT 模型因双向 Self-Attention 而导致的过拟合。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"MLM（Masked Language Model，遮蔽语言模型）：预训练中 15% 的词条（token）会被遮蔽，对于这 15% 的词条，有 80% 的概率会使用 [MASK] 替换，10% 的概率随机替换，10% 的概率保持原样，这个替换策略在模型训练中起到正则作用。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"RoBERTa：是 Facebook 提出的模型，在 BERT 的基础上移除了 NSP（Next Sentence Prediction）机制，并且修改了 MLM 机制，调整了其参数。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"ERNIE：是百度提出的模型，在 BERT 的基础上优化了对中文数据的预训练，增加了三个层次的预训练：Basic-Level Masking（第一层）、Phrase-Level Masking（第二层）、Entity-Level Masking（第三层），分别从字、短语、实体三个层次上加入先验知识，提高模型在中文语料上的预测能力。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"RoBERTa-wwm：由哈工大讯飞联合实验室发布，并不是一个严格意义上的新模型，wwm（whole word mask）是一种训练策略。BERT 所用的 MLM 具有一定的随机性，会将原始词的 word pieces 遮蔽掉，而 wwm 策略中，相同词所属的 word pieces 被遮蔽之后，其同属其他部分也会一同被遮蔽，在保证词语完整性的同时又不影响其独立性。","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"卷积神经网络","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"循环神经网络","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"自注意力机制（Self-Attention ）","category":"page"},{"location":"AI/NLP/","page":"自然语言处理","title":"自然语言处理","text":"Transformer","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"C++ 的最小学习包：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"运算符；\n基本语法；\n关键字；\n常用类型、容器、标准库类型：字符串、向量、数组\n类与函数：\n指针与引用：\n模板与泛型：","category":"page"},{"location":"lang/C++Primer/#运算符","page":"-","title":"运算符","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.147｜运算符优先级表，总结了全部的运算符和它们之间的优先级。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"作用域操作符 ::：告诉编译器应该从操作符 :: 左边名字所示的作用域中寻找右侧的名字。","category":"page"},{"location":"lang/C++Primer/#语法","page":"-","title":"语法","text":"","category":"section"},{"location":"lang/C++Primer/#循环语句","page":"-","title":"循环语句","text":"","category":"section"},{"location":"lang/C++Primer/#范围-for-语句","page":"-","title":"范围 for 语句","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"lambda 表达式：","category":"page"},{"location":"lang/C++Primer/#关键字","page":"-","title":"关键字","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"constexpr","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"auto","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"decltype","category":"page"},{"location":"lang/C++Primer/#常用类型","page":"-","title":"常用类型","text":"","category":"section"},{"location":"lang/C++Primer/#引用","page":"-","title":"引用","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.45｜引用（reference）分为左值引用（lvalue reference）和右值引用（rvalue reference）。引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。使用方法为 &refername，其中 refername 是声明的变量名，& 是取地址运算符。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"引用必须被初始化。一旦初始化完成，引用将会和它的初始值对象绑定在一起。\n无法令引用重新绑定到另外一个对象。\n引用本身不是一个对象，不能够定义引用的引用。\n所有引用的类型都要和与之绑定的对象严格匹配。\n引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❗️注意：对于第  4 条，有两个例外：（1）const  的引用和（2）基类对派生类的引用。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.55｜const  的引用：又称为对常量的引用（reference to const），也可以简称为常量引用。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"对常量的引用不能够用于修改所绑定的对象。\n在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可。\n允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式。\n非常量引用不可以指向常量对象，常量引用可以指向非常量对象。\n常量引用只对引用可参与的操作做出了限定，对于引用的对象本身是否为一个常量并未做出限定。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"对于第  4 条：假设变量 ci 是一个常量对象 const int ci = 1024，那么用一个非常量引用 r2 绑定到 ci 上（即 int &r2 = ci）是非法的。假设 i 是一个非常量对象 int i = 42，那么用一个常量引用 r1 绑定到 i 上（即 const int &r1 = i）是可以的。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.55｜临时量（temporary）：临时量对象就是当编译器需要在一个空间来暂存表达式的求值结果时创建的一个未命名的对象。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❓当一个常量引用被绑定到不同的一种类型时，编译器会做什么？","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"下列的代码尝试将一个 int 型的常量引用绑定到 double 型的：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"double dval = 3.14;\nconst int &ri = dval;","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"答：实际上编译器会将 double 型转换为一个 int 型的临时量：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"const int temp = dval;  // 又双精度浮点数生成一个临时的整型常量\nconst int &ri = temp;","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.534｜基类引用绑定派生对象：存在继承关系的类中，可以将基类的引用绑定到派生类对象中。","category":"page"},{"location":"lang/C++Primer/#指针","page":"-","title":"指针","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.47｜指针（pointer）是「指向」另外一种类型的复合类型。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"指针本身就是一个对象，允许对指针赋值和拷贝。 \n指针在其生命周期内可以先后指向几个不同的对象。\n指针无须在定义时赋初值，如果在块作用域内没有被初始化，会拥有一个不确定的值。\n指针的类型必须与其所指定对象的类型一致。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❗️注意：对于第  4 条，有两个例外：（1）允许指向常量的指针指向一个非常量对象和（2）。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.56｜指向常量的指针（pointer to const）不能用于改变其所指向的对象。要想存放常量对象的地址，只能用指向常量的指针。其用法是 const double *cptr = &pi，其中 const 表明改指针是指向常量的指针。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"指向常量的指针可以指向非常量对象。\n指向常量的指针仅仅要求不能通过指针改变对象的值，没有规定那个对象的值不能通过其它途径改变。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.56  常量指针（const pointer）：指针本身是一个常量，也就是它所指向的地址永远不会变。其用法为 *const 代表指针是一个常量。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"常量指针必须初始化，一旦初始化完成，它的值（也就是存放在指针中的那个地址），就不能再改变。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"注意区分：指针类型 地址是否可变 对象是否可变\n指向非常量的一般指针 ✅ ✅\n指向常量的一般指针 ✅ ❌\n指向非常量的常量指针 ❌ ✅\n指向常量的常量指针 ❌ ❌","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❓有很多的变量声明，应该用什么方法去搞清楚不同的声明呢？","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"答：最好的方法就是对于变量声明部分，从右往左读，例如：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"const double *cptr = &pi;  // cptr 是一个指针，指向双精度常量\nint *const curErr = &errNumb;  // curErr 是一个常量指针，指向 int  型\nconst double *const pip = &pi;  // pip 是一个常量指针，指向双精度浮点型常量","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.400｜动态内存的管理：在 C++ 中动态内存的管理通过一对运算符 new 和 delete 来进行：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"new 在动态内存中为对象分配空间并返回一个指向该对象的指针；\ndelete 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存；","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❓动态内存的使用容易碰到什么问题？","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"忘记释放内存，产生内存泄露。\n在尚有指针引用内存的情况下就释放了指针，产生引用非法内存的指针。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.400｜智能指针：其行为类似常规指针，重要的区别是智能指针负责自动释放所指向的对象。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❓智能指针是否是线程安全的？","category":"page"},{"location":"lang/C++Primer/#数组","page":"-","title":"数组","text":"","category":"section"},{"location":"lang/C++Primer/#多维数组","page":"-","title":"多维数组","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"严格来说，C++ 没有多维数组，通常所说的多维数组其实是数组和数组。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"int ia[3][4];\nint arr[10][20][30];\n\n// int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\nint ia[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n}","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"用两层嵌套的 for 循环来处理多维数组的元素：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"constexpr size_t rowCnt = 3, colCnt = 4;\nint ia[rowCnt][colCnt];\nfor (size_t i = 0; i != rowCnt; ++i) {\n    for (size_t j = 0; j != colCnt; ++j) {\n        ia[i][j] = i * colCnt + j;\n    }\n}","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"如果使用范围 for 语句来迭代：","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"size_t cnt = 0;\nfor (auto &row : ia) {\n    for (auto &col : row) {\n        col = cnt;\n        cnt++;\n    }\n}","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❓请思考一下为什么下面的语句（没有对 row 指定为引用），会编译报错？","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"for (auto row : ia) {\n    for (auto col : row) {\n        // ...\n    }\n}","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"P.114 要使用范围 for 语句处理多位数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"❓说一下下面不同声明代表的意思。","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"int *ip[4];\nint (*ip)[4];","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"int *ip[4]：代表整型指针的数组；","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"int (*ip)[4]：代表指向含有  4  个整型的数组；","category":"page"},{"location":"lang/C++Primer/#哈希","page":"-","title":"哈希","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"map","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"unordered_map","category":"page"},{"location":"lang/C++Primer/#类与函数","page":"-","title":"类与函数","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"分离式编译（Separate Compilation）：允许把程序分割到几个文件中去，每个文件独立编译。","category":"page"},{"location":"lang/C++Primer/#继承","page":"-","title":"继承","text":"","category":"section"},{"location":"lang/C++Primer/#其它概念","page":"-","title":"其它概念","text":"","category":"section"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"左值","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"右值","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"内存管理","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"参考资料","category":"page"},{"location":"lang/C++Primer/","page":"-","title":"-","text":"[1]《C++ Primer》[美] Staley B. Lippman, Josee Lajoie, Barbara E. Moo. ","category":"page"},{"location":"AI/GAN/#变分自编码器","page":"生成对抗网络","title":"变分自编码器","text":"","category":"section"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"变分自编码器（Variational Autoencoder，VAE）与自编码器（Autoencoder，AE）在建模方面存在着很大的区别，本质上讲，VAE 是一种基于变分推断（Variational Inference）又叫变分贝叶斯方法（Variational Bayesian Methods）的概率模型，它属于无监督的生成模型。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"在变分推断中，除了已知的数据（观测数据、训练数据）之外，还存在一个隐含变量。假设有一个数据集 mathbfX=x^(i)，由 N 个连续变量或者离散变量 x 组成，还未观测的随机变量记为 z，那么数据产生包含两个过程：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"从一个先验分布 p_theta(z) 中采样一个 z^(i)；\n根据条件分布 p_theta(xmid z)，用 z^(i) 生成 x^(i)；","category":"page"},{"location":"AI/GAN/#生成对抗网络","page":"生成对抗网络","title":"生成对抗网络","text":"","category":"section"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"2014 年，加拿大蒙特利尔大学的 Ian Goodfellow 和他的导师 Yoshua Bengio 提出生成对抗网络（Generative Adversarial Networks, GANs）。在 GANs 被提出来之后，发展迅速，出现了各种变种网络，包括 WGAN、InfoGAN、f-GANs、BiGAN、DCGAN、IRGAN 等。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"对于 GANs 的理解，可以想象成假币者与警察间展开的一场猫捉老鼠游戏，造假币者试图造出以假乱真的假币，警察试图发现这些假币，对抗使得二者的水平都得到提高。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"GANs 包括生成器（Generator）和判别器（Discriminator）两个部分。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（1）生成器的作用是合成「假」样本。它从先验分布中采样随机信号，通过神经网络得到模拟样本。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（2）判别器的作用是判断输入的样本是真实的还是合成的。它同时接收来自生成器的模拟样本和实际数据集的真实样本，并且判断当前接收的样本是「真」还是「假」。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"GANs 实际上是一个二分类问题，判别器 D 试图识别实际数据为真实样本，识别生成器生成的数据为模拟样本。它的损失函数写成负对数似然 （Negative Log-Likelihood），也称为 Categorical Cross-Entropy Loss，即：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"mathcalL(D) = -int p(x) left p(data mid x) log D(x) + p(g mid x) log(1-D(x))  righttextdxqquad text(1)","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"其中 D(x) 表示判别器预测 x 为真实样本的概率，p(data mid x) 和 p(g mid x) 表示 x 分属真实数据集和生成器这两类的概率。即理解为，在给定样本 x 的条件下，该样本来自真实数据集 data 的概率和来自生成器的概率。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"样本 x 的来源应该各占实际数据集和生成器一半，即 p_textsrc(data)=p_textsrc(g)= 05。用 p_textdata(x)doteq p(xmid data) 表示从实际数据集得到 x 的概率，p_textg(x)doteq p(xmid g) 表示从生成器得到 x 的概率，有 x 的总概率：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"p(x) = p_textsrc(data)p(xmid data) + p_textsrc(g)p(xmid g)","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"注：doteq 和 approx 是等价的，都是表达约等于的意思。一般写完等号之后，发现不是等于，而是约等于，所以就懒得涂抹写成 approx，所以就添加一个点。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"将损失函数 (1) 式中的 p(x)p(datamid x) 替换为 p_textsrc(data)p_textdata(x)，以及将 p(x)p(gmid x) 替换为 p_textsrc(g)p_textg(x)，就可以得到最终的目标函数","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"mathcalD=-frac12left( mathbbE_xsim p_textdata(x)left log D(x) right + mathbbE_xsim p_textg(x)left log (1 - D(x)) rightright)","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"在此基础上可以得到值函数","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"V(GD) = mathbbE_xsim p_textdata(x)left log D(x) right + mathbbE_xsim p_textg(x)left log (1 - D(x)) right","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"在训练的时候，判别器 D 的目标就是最大化上述值函数，生成器 G 的目标就是最小化它，因此整个 MinMax 问题可以表示为 undersetGminundersetDmax V(GD)。","category":"page"},{"location":"AI/GAN/#GANs-的训练方式","page":"生成对抗网络","title":"GANs 的训练方式","text":"","category":"section"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"我们知道 GANs 的值函数为","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"V(GD) = mathbbE_xsim p_textdata(x)left log D(x) right + mathbbE_xsim p_textg(x)left log (1 - D(x)) right","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"在训练的时候，判别器 D 的目标就是最大化上述值函数，生成器 G 的目标就是最小化它，因此整个 MinMax 问题可以表示为 undersetGminundersetDmax V(GD)。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"GANs 在训练的时候是采用生成器和判别器交替优化的方式进行的。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"判别器 D 的训练：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（1）先固定生成器 G(cdot)；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（2）利用生成器随机模拟产生样本 G(z) 作为负样本（z 是一个随机向量），并从真实数据集中采样获得正样本 X；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（3）将正负样本输入到判别器 D(cdot) 中，根据判别器的输出 D(X) 和 D(G(z)) 和样本标签来计算误差；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（4）最后利用误差反向传播算法来更新判别器 D(cdot) 的参数；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"判别器的训练是这样的一个问题：给定生成器 G，寻找当前情况下的最优判别器 D^*_G 。对于单个样本 x，最大化 undersetDmax p_textdata(x)log D(x) + p_textg(x)log(1-D(x)) 的解为 hatD(x)=p_textdata(x)p_textdata(x)+p_textg(x)，外面套上对 x 的积分就得到 undersetDmax V(GD)，解由单点变成一个函数解：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"D^*_G=fracp_textdatap_textdata+p_textg","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"此时 undersetGminV(GD^*_G)=undersetGminleft-log 4 + 2cdot textJSD(p_textdata p_textg)right，其中 textJSD(cdot) 是 JS 距离。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"优化生成器 G 实际上是在最小化生成样本分布与真实样本分布的 JS 距离。最终达到的均衡点是 textJSD(p_textdata p_textg) 的最小值点，即 p_textg=p_textdata 时，textJSD(p_textdata p_textg) 取到零，最优解 G^*(z)=xsim p_textdata(x)，D^*(x)equiv frac12，值函数 V(G^*D^*)=-log 4。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"生成器 G 的训练：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（1）先固定判别器 D(cdot)；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（2）然后利用当前生成器 G(cdot) 随机模拟产生样本 G(z)，输入到判别器 G(cdot) 中；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（3）根据判别器的输出 D(G(z)) 和样本标签来计算误差；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"（4）最后利用误差反向传播算法来更新生成器 G(cdot) 的参数；","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"假设 G^prime 表示前一步的生成器，D 是 G^prime 下的最优判别器 D^*_G^prime。那么求解最优生成器 G 的过程为：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"undersetGargminV(GD^*_G^prime)=undersetGargmintextKLleft( p_textg  fracp_textdata+p_textg^prime2 right) - textKL(P_textg P_textg^prime)","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"由此可以知道（1）优化 G 的过程是让 G 远离前一步的 G^prime，同时接近分布 (p_textdata+p_textg^prime)2；（2）达到均衡点时 p_textg^prime=p_textdata，有 undersetGargminV(GD^*_G^prime)=undersetGargmin()，如果用这时的判别器去训练一个全新的生成器 G_textnew，理论上可能啥也训练不出来。","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"参考：","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"[1] 诸葛越，葫芦娃，《百面机器学习》，中国工信出版集团，人民邮电出版社","category":"page"},{"location":"AI/GAN/","page":"生成对抗网络","title":"生成对抗网络","text":"[2] Goodfellow I. J., Pouget-Abadie J., Mirza M., et al. Generative adversarial networks[J]. Advances in Neural Information Processing Systems, 2014, 3: 2672-2680. ","category":"page"},{"location":"AI/CNN/#卷积神经网络","page":"卷积神经网络","title":"卷积神经网络","text":"","category":"section"},{"location":"AI/CNN/#深度卷积神经网络","page":"卷积神经网络","title":"深度卷积神经网络","text":"","category":"section"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"感受野（Receptive Field），指的是神经网络中神经元「看到的」输入区域，在卷积神经网络中，feature map 上某个元素的计算受输入图像上某个区域的影响，这个区域即该元素的感受野。感受野是个相对概念，某层 feature map 上的元素看到前面不同层上的区域范围是不同的，通常在不特殊指定的情况下，感受野指的是看到输入图像上的区域。","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"例如两个级联的卷积核大小为 3times 3，stride = 2 的卷积层的感受野为 7times 7，如图所示","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"(Image: 感受野)","category":"page"},{"location":"AI/CNN/#卷积详解","page":"卷积神经网络","title":"卷积详解","text":"","category":"section"},{"location":"AI/CNN/#卷积","page":"卷积神经网络","title":"卷积","text":"","category":"section"},{"location":"AI/CNN/#因果卷积（Causal-Convolution）","page":"卷积神经网络","title":"因果卷积（Causal Convolution）","text":"","category":"section"},{"location":"AI/CNN/#空洞卷积","page":"卷积神经网络","title":"空洞卷积","text":"","category":"section"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"空洞卷积具有更大的感受野，有助于构建长期记忆功能。","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"变形卷积","category":"page"},{"location":"AI/CNN/#CNN-历史","page":"卷积神经网络","title":"CNN 历史","text":"","category":"section"},{"location":"AI/CNN/#从-LeNet-5-到-ResNet","page":"卷积神经网络","title":"从 LeNet-5 到 ResNet","text":"","category":"section"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"LeNet-5","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"AlexNet 首次亮相是在 2012 年的 ILSVRC 大规模视觉识别竞赛上，它的主要成果是将图像分类任务的 Top-5 错误率降低到 15.3%。AlexNet 主要的网络结构是堆砌的卷积层和池化层，最后在网络末端加上全连接层和 Softmax 层来处理多分类任务。AlexNet 的改进：","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"采用修正线性单元（Rectified Linear Unit，ReLU）作为激活函数（在此之前常用 Sigmoid 函数），缓解了深层网络训练时的梯度消失问题。\n引入局部响应归一化（Local Response Normalization，LRN）模块。\n应用 Dropout 和数据扩充（data augmentation）技术来提升训练效果。\n用分组卷积来突破当时 GPU 的显存瓶颈。","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"AlexNet 输入的图片大小为 227times 227，每个批次只有 1 张图片。","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"VGGNet 出现在2014 年的 ILSVRC 上，单个模型就将图像分类任务的 Top-5 错误率降低到 8.0%；如果采用多模型集成（ensemble），则可以将错误率进一步降至 6.8%。VGGNet 的改进：","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"VGGNet-16 输入的图片为 224times 224，每个批次有 10 张图片。","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"ResNet 的提出是为了解决网络退化（degeneration）的问题。退化是指随着网络层数的加深，网络的训练误差和测试误差都会上升。而过拟合是训练误差降低而测试误差反而升高的现象。ResNet-152 模型在 ImageNet 2012 数据集的图像分类任务上，单模型使得 Top-5 错误率降至 4.49%，采用多模型集成可以进一步将错误率降低到 3.57%。ResNet 的改进：","category":"page"},{"location":"AI/CNN/","page":"卷积神经网络","title":"卷积神经网络","text":"增加了跳跃连接（shortcut connection），在网络中构筑多条「近道」：\n缩短误差反向传播到各层的路径，有效抑制梯度消失的现象，使得网络在不断加深时性能不会下降。\n若网络在层数加深时性能退化，则它可以通过控制网络中「近道」和「非近道」的组合比例来退回到浅层时的状态，即「近道」具备自我关闭的能力。","category":"page"},{"location":"database/#数据库","page":"-","title":"数据库","text":"","category":"section"},{"location":"database/#问题总结","page":"-","title":"问题总结","text":"","category":"section"},{"location":"database/","page":"-","title":"-","text":"❓如何设计账户余额字段？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓MySQL 索引结构，引申 B 树与 B+ 树，为什么选择自增整数 ID 做主键？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓分库分表、主从复制？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓字符串如何建立索引？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓什么是幻读？InnoDB 如何解决？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓死锁形成条件？如何避免死锁？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓延时与吞吐率的区别是什么？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓什么是多路复用？为什么要用？引申 epoll 与 select 的比较；epoll 底层原理：红黑树、就绪链表？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓epoll 如何判断接收到了数据？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓什么是 mesi 协议？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓设计数据库的话，如何保证事务的原子性？","category":"page"},{"location":"database/","page":"-","title":"-","text":"❓有了这undo和redo日志有没有可能还是会有问题？这俩日志的写入顺序是怎么样的？","category":"page"},{"location":"AI/CV/#快速索引目录","page":"计算机视觉","title":"快速索引目录","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"常见神经网络结构：\nLeNet、AlexNet、VGGNet、GoogLeNet、ResNet、DenseNet、FPN\n两阶段检测算法：\nR-CNN 系列：R-CNN、Fast R-CNN、Faster R-CNN、Light-Hear R-CNN、Mask R-CNN\nSPPNet\n一阶段检测算法：\nYOLO、SSD、FCOS、RetinaNet、SENet\nATSS、Focal Loss、GFL","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"计算机视觉的任务有：图像分类、物体检测、语义分割、文字识别、人脸识别等","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"CV Baseline 数据：https://deepshare.feishu.cn/docx/doxcnDDF7Kmz7pGjfE7IY2Noppf","category":"page"},{"location":"AI/CV/#目标检测","page":"计算机视觉","title":"目标检测","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"目标检测学习路径：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"理论：要求能够复现经典论文的代码","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"图像分类：VGG、Inception、ResNet、MobileNet、SENet\n图像分割：UNet、DeepLab 系列、FCN、SegNet、BiSeNet\n目标检测：YOLOv3、Faster R-CNN\nGAN：GAN、DCGAN、Pix2Pix","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"实践：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"数据增强技巧：MixUp、Label Smoothing\n长尾分布（Long-Tail）、渐进式采样（PB-sampling, Progressively-balanced Sampling）\n数据爬取与筛选：常规筛选方法（经典图像处理和分析方法）、高阶筛选方法（model-base，基于内容的筛选）\n语义分割：\n自动驾驶语义分割：CamVid 数据集，训练 UNet、SegNet；deeplabv3+ 进行模型评估和推理\n人像分割：Portrait 数据集；训练 BiseNet；Dice-Loss、CE Dice Loss、Focal Loss\n数据增强工具：Albumentations\n目标检测：\nYOLOX：Neck、Head、正负样本分配方式\nCOCO 数据集：Mosaic、Mixup、Affine 变化等数据增强方法\n轻量级目标检测器：NanoDetPlus\n算法终端部署：OpenVINO","category":"page"},{"location":"AI/CV/#基础概念","page":"计算机视觉","title":"基础概念","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"计算特征图大小：计算经过卷积、池化等操作之后的特征图大小，这是一个十分常见的考题。假设特征图的输入尺寸为 l_i，Padding 大小为 p，卷积核或者池化核大小为 k，步长为 s，那么特征图的输出尺寸 l_o 计算公式为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"l_o=lfloorfracl_i+2p-ksrfloor+1","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 lfloorcdotrfloor 代表向下取整。很多深度学习框架会采取向下取整的方式，放弃输入特征图的一部分边界数据。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"计算感受野：假设网络的原始输入特征图的尺寸为 L，第 i 层卷积核（池化核）尺寸 k_i，第 j 层的步长为 s_j，则第 i 层的感受野大小 R_i 计算如下","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"R_i=minleft( R_i-1 + (k_i-1)prod_j=0^i-1s_j L right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中对于原始输入层 R_0=1 s_0=1. ","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"目标检测（Object Detection）是计算机视觉中极为重要的基础问题，是实例分割（Instance Segmentation)、场景理解（Secne Understanding）、目标跟踪（Object Tracking）、图像标注（Image Captioning）等问题的基础。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"目标检测任务：给定一张图片，将图片中的每个物体识别出来并且提出一个置信度，用矩形方框（Bounding Box）或者不规则的区域标识出来。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"目标检测模型分为单步（one-stage）模型和两步（two-stage）模型两大类。单步模型在计算效率上有优势，两步模型在检测精度上有优势。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"单步模型是指没有独立地、显式地提取候选区域（region proposal），直接由输入图像得到其中存在的物体的类别和位置信息的模型。例如 OverFeat、SSD（Single Shot multibox-Detector）、YOLO（You Only Look Once） 等模型。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"两步模型是指有独立的、显式的候选区域提取过程，即先在输入图像上筛选出一些可能存在物体的候选区域，然后针对每个候选区域，判断其是否存在物体，如果存在就给出物体的类别和位置修正信息。例如 R-CNN、SPPNet、Fast R-CNN、Faster R-CNN、R-FCN、Mask R-CNN 等模型。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"交并比（Intersection-over-Union，IoU）：即两个 Bounding Boxes 之间交集与并集的比值。对于预测 Bounding Box 与 Ground-truth Box 来说，比值越大代表预测的 Bounding Box 结果越好。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"可以学习一下 IoU 的 Python 代码 IoU_demo.py。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"# 这六行短短的代码可以囊括所有 pred bbox 和 gt bbox 之间的关系。包括相交、不相交、各种相交形式等等\nixmin = max(pred_bbox[0], gt_bbox[0])\niymin = max(pred_bbox[1], gt_bbox[1])\nixmax = min(pred_bbox[2], gt_bbox[2])\niymax = min(pred_bbox[3], gt_bbox[3])\niw = np.maximum(ixmax - ixmin + 1., 0.)\nih = np.maximum(iymax - iymin + 1., 0.)\n\ninters = iw * ih  # 交集\nuni = ((pred_bbox[2] - pred_bbox[0] + 1.) * (pred_bbox[3] - pred_bbox[1] + 1.) +\n           (gt_bbox[2] - gt_bbox[0] + 1.) * (gt_bbox[3] - gt_bbox[1] + 1.) -\n           inters)  # 并集 union = S1 + S2 - inters\n\noverlaps = inters / uni  # IoU","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"均交并比（Mean Intersection over Union, MIoU）：MIoU 是语义分割的标准度量，其计算两个集合的交集和并集之比。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textMIoU=frac1k+1sum^k_i=0fracp_iisum_j=0^kp_ij+sum_j=0^kp_ji-p_ii","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 p_ij 表示真实值为 i，被预测为 j 的数量。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"橙色是真实值，蓝色是预测值，中间是两个部分的相交部分。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"均像素精度（Mean Pixel Accuracy, MPA）：预测正确的部分占整个真实值的比例，或者说真正例占假负例的比例，即面积 3 和面积 1 的比例。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"而 MIoU 就是两个部分交集部分与并集部分的比，越接近 1 证明预测结果越好，最理想的情况是 1. ","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"非极大值抑制（Non-Maximum Suppression，NMS）：目标检测过程中在同一个目标的位置上会产生大量的候选框，这些候选框之间可能会有重叠，NMS 的作用就是消除冗余的边界框，找到最佳的目标边界框。NMS 的流程如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"步骤 1. 根据置信度得分进行排序；\n步骤 2. 选择置信度最高的边界框添加到最终输出列表中，将其从边界框列表中删除；\n步骤 3. 计算所有边界框的面积；\n步骤 4. 计算置信度最高的边界框与其他候选框的 IoU；\n步骤 5. 删除 IoU 大于给定阈值的边界框；\n步骤 6. 重复上述过程，直到边界框列表为空；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"NMS 中的阈值给得越大，则越有可能出现同一个物体有多个边界框的情况。步骤 4 中如果置信度最高的边界框与其他候选框的 IoU 比较大的话，就可以认为这两个边界框中是同一个物体，因此只要留下最大的那一个，把其他的删除了。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"代码：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"out = net(x)  # forward pass, 将图像 x 输入网络，得到 pred cls + reg\nboxes, scores = detector.forward(out, priors)  # 结合 priors，将 pred reg（即预测的 offsets）解码成最终的 pred bbox\nboxes = boxes[0]\nscores = scores[0]\n\n# scale each detection back up to the image\nboxes *= sca;e  # (0, 1) 区间坐标的 bbox 做尺度反正则化\nboxes = boxes.cpu().numpy()\nscores = scores.cpu().numpy()\n\nfor\tj in range(1, num_classes):  # 对每一个类 j 的 pred bbox 单独做 NMS\n    # 因为第 0 类是 background，不用做 NMS，因此 index 从 1 开始\n    inds = np.where(scores[:, j] > thresh)[0]  # 找到该类 j 下，所有 cls score 大于 thresh 的 bbox\n    # score 小于阈值的 bbox 直接过滤掉，不用进行 NMS\n    if len(inds) == 0:  # 没有满足条件的 bbox，返回空，跳过\n        all_boxes[j][i] = np.empty([0, 5], dtype=np.float32)\n        continue\n    c_bboxes = boxes[inds]\n    c_scores = scores[inds, j]  # 找到对应类 j 下的 score 即可\n    c_dets = np.hstack((c_bboxes, c_scores[:, np.newaxis])).astype(np.float32, copy=False)  # 将满足条件的 bbox + cls score 的 bbox 通过 hstack 完成合体\n    \n    keep = nms(c_dets, 0.45, force_cpu=args.cpu)  # NMS，返回需要保存的 bbox index: keep\n    c_dets = c_dets[keep, :]\n    all_boxes[j][i] = c_dets  # i 对应每张图片，j 对应图像中类别 j 的 bbox 清单","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"True Positive (TP)：textIoU  05 的检测框数量（同一个 Ground Truth 只计算一次）","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"False Positive (FP)：textIoUle 05 的检测框（检测到同一个 Ground Truth 的多余检测框的数量","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"False Negative (FN)：没有检测到的 Ground Truth 的数量","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"True Negative (TN)：在 mAP 评价指标中不会使用到","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"查准率（Precision）：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textPrecision = fractextTP(textTP + textFP) = fractextFPtextall detections","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"查全率、查全率（Recall）：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textRecall = fractextTP(textTP+textFN)=fractextTPtextall ground truths","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"PR 曲线（Precision-Recall Curve）：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"平均精确度（Average Precision）：PR 曲线下面积","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mAP（mean Average Precison）：各类别 AP 的平均值。在 VOC2010 以前（VOC07），只要选择当 textRecallge 0 01 02 dots 1 共 11 个点时的 Precision 最大值，然后 AP 就是这 11 个 Precision 的平均值；在 VOC2010 开始，需要针对每一个不同的 Recall 值（包括 0 和 1），选取其大于等于这些 Recall 值时的 Precision 最大值，然后计算 PR 曲线下面积作为 AP 值。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"通常 VOC10 标准下计算的 mAP 值会高于 VOC07，原因如下：插值平均精度（Interpolated Average Precision）：一些作者选择了另一种近似值，称为插值平均精度。 通常，他们仍然称其为平均精度。 这种方法不使用 P(k)，在 k 个图像的截止处的精度，插值平均精度使用：max_tildekge kP(tildek)换句话说，插值平均精度不是使用在截止 k 处实际观察到的精度，而是使用在所有具有更高召回率的截止上观察到的最大精度。计算插值平均精度的完整方程为：sum_k=1^Nmax_tildekge kP(tildek)Delta r(k)近似平均精度（Approximated Average）与实际观察到的曲线非常接近。 插值平均精度高估了许多点的精度，并产生比近似平均精度更高的平均精度值。此外，在计算插值平均精度时，在何处采集样本存在差异。 有些人在从 0 到 1 的固定 11 个点采样：0 01 02  09 10。 这称为 11 点插值平均精度。 其他人在召回率发生变化的每个 k 处采样。","category":"page"},{"location":"AI/CV/#目标检测历史","page":"计算机视觉","title":"目标检测历史","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"在一开始的 CNNs 上，把一张图片划分成为固定的区域，然后识别这些区域中是否有某个物体，有的话就把这个区域标识出来。但是在实际中，图片上的物体大小是不固定的，用这种固定大小的区域去识别物体显然是不合理的。人们想到，如果想要让框更加合适，可以增加框的数量，然后让每个区域都变得尽可能地小。但是这样框太多的时候，又会导致计算量的增加。","category":"page"},{"location":"AI/CV/#常见神经网络结构","page":"计算机视觉","title":"常见神经网络结构","text":"","category":"section"},{"location":"AI/CV/#LeNet","page":"计算机视觉","title":"LeNet","text":"","category":"section"},{"location":"AI/CV/#AlexNet","page":"计算机视觉","title":"AlexNet","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"首次出现在 2012 年，由 神经网络的坚守者 Hinton 和他的学生 Alex Krizhevsky 设计，在 ImageNet LSVRC-2010 测试集上的 Top-1 和 Top-5 错误率为 37.5% 和 17.0%。AlexNet 有 6 亿个参数和 650, 000 个神经元，5 个卷积层，3 个全连接层，最后一个全连接层通过 Softmax 产生的结果作为输入图像在 1000 个类别上的得分，在全连接层使用 Dropout 减少过拟合。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"整个网络的结构：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"输入为一个 (227 227 3) 的图像；\n第一层卷积由 96 个大小为 (11 11 3) 的卷积核组成，滑动步长 stride 为 4，无 padding，因此第一个卷积层输出层尺寸为 (55 55 96)；\n后接 Max Pooling，大小为 3times 3，步长为 2，无 padding，输出特征图的尺寸为 (27 27 96)；\n第二层卷积由  256 个大小为 (5 5 96) 的卷积核组成，步长为 1，padding 为 2，输出特征图尺寸为 (27 27 256)；\n后接 Max Pooling，大小为 3times 3，步长为 2，无 padding，输出特征图的尺寸为 (13 13 256)；\n第三层卷积由 384 个大小为 (3 3 256) 的卷积核组成，步长为 1，padding 为 1，输出特征图尺寸为 (13 13 384)；\n第四层卷积由 384 个大小为 (3 3 384) 的卷积核组成，步长为 1，padding 为 1，输出特征图尺寸为 (13 13 384)；\n第五层卷积由 256 个大小为 (3 3 384) 的卷积核组成，步长为 1，padding 为 1，输出特征图尺寸为 (13 13 256)；\n后接 Max Pooling，大小为 3times 3，步长为 2，无 padding，输出特征图尺寸为 (66256)；\n后面是三层全连接层，最后一层是 Softmax，有 1000 个类别；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"卷积输出层分辨率计算公式：(W+2times textpadding - textkernel)textstride + 1","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"AlexNet 的特点：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"是第一个使用卷积神经网络在 ILSVRC 比赛中获得冠军的网络结构；\n使用 ReLU 作为激活函数，替代传统神经网络神经元激活函数 Tanh 和 Sigmoid，提高了收敛速度；\n使用多种方法避免过拟合：\n数据增强：每个 (256 256) 的样本被裁剪成 (224 224) 的大小（可以有 (256-224)^2=1024 个），再做一次水平翻转，因此一个样本可以扩增为 2048 个；\n在测试集上，对 (256 256) 的图像做四个角和中间部分的裁剪，再做水平翻转，每个测试样本有 10 个 Patches，最终对模型的输出结果取平均；\n改变 RGB 图像的亮度；\n在前两个全连接层上使用 Dropout：使用 0.5 随机失活的 Dropout；在测试时将神经元的输出结果乘以 0.5；\n使用双 GPU 并行训练（这个是因为当时的计算力限制）；\n局部响应归一化：在第 1、2 个卷积层之后使用了局部响应归一化；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"数据增强的方法有随机裁剪、随机上下左右翻转、平移、缩放、旋转、修改图像饱和度、颜色、亮度等","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"局部响应归一化（Local Response Normalization，LRN）：是一种受生物学启发的归一化方法，通常用在基于卷积的图像处理上，LRN 对邻近的特征映射进行局部归一化。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"假设一个卷积层的输出特征映射 boldsymbolYinmathbbR^M^primetimes N^primetimes P 为三维张量，其中每个切片矩阵 boldsymbolY^pinmathbbR^M^primetimes N^prime 为一个输出特征映射，1le ple P，那么 LRN 计算如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"hatboldsymbolY^p=boldsymbolY^pleft( k + alphasum_j=max(1 p-fracn2)^min(P p+fracn2)(boldsymbolY^j)^2right)^beta triangleq textLRN_nkalphabeta(boldsymbolY^p)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中除和幂运算都是按元素运算，nkalphabeta 为超参，n 为局部归一化的特征窗口。在 AlexNet 中，n=5k=2 alpha=10e^-4beta=075","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"局部响应归一化（LRN）和层归一化（Layer Normalization，LN）的异同：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"都是对同层的神经元进行归一化；\nLRN 应用在激活函数之后，只是对邻近的神经元进行局部归一化，并且不减去均值；\nLN 是对一个中间层的所有神经元进行归一化；\nLRN 与生物神经元中的侧抑制（lateral inhibition）现象类似，即活跃神经元对相邻神经元具有抑制作用；当使用 ReLU 作为激活函数时，神经元的活性值是没有限制的，LRN 可以起到平衡和约束作用；\n如果一个神经元的活性值非常大，那么和它邻近的神经元就近似地归一化为 0，起到抑制作用，可以增强模型的泛化能力；\n最大汇聚（Max Pooling）也具有抑制作用，区别在于最大汇聚是对同一个特征映射中的邻近位置中的神经元进行抑制，LRN 是对同一个位置的邻近特征映射中的神经元进行抑制；","category":"page"},{"location":"AI/CV/#VGGNet","page":"计算机视觉","title":"VGGNet","text":"","category":"section"},{"location":"AI/CV/#GoogLeNet","page":"计算机视觉","title":"GoogLeNet","text":"","category":"section"},{"location":"AI/CV/#ResNet","page":"计算机视觉","title":"ResNet","text":"","category":"section"},{"location":"AI/CV/#DenseNet","page":"计算机视觉","title":"DenseNet","text":"","category":"section"},{"location":"AI/CV/#FPN","page":"计算机视觉","title":"FPN","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"特征金字塔网络（Feature Pyramid Networks，FPN）：低层的特征语义信息比较少，但是目标位置准确；高层的特征语义信息比较丰富，但是目标位置比较粗略。有些算法采用多尺度特征融合的方法，但是一般是采用融合后的特征做预测。这篇文章创新的点在于预测是在不同特征层独立进行的。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文中的图 1 展示了 4 种利用特征的方式：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"图像金字塔（Featurized image pyramid）：将图像 reshape 为不同的尺度，不同尺度的图像生成对应不同尺度的特征。这种方式缺点在于增加了时间成本；\n单个特征图（Single feature map）：像 SPPNet、Fast R-CNN、Faster R-CNN 等模型采用的方式，只使用最后一层的特征图；\n金字塔特征层次结构（Pyramidal feature hierarchy）：像 SSD 模型采用多尺度特征融合的方式，没有上采样的过程，从网络不同层抽取不同尺度的特征做预测。优点在于不会增加额外的计算量；缺点在于 SSD 没有用到足够底层的特征（SSD 中最底层的特征是 VGG 网络的 Conv4_3）；\n特征金字塔网络（Feature Pyramid Network）：顶层特征通过上采样和低层特征做融合，每层独立预测；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文的图 2 展示的是两种不同的金字塔结构，上面的结构将最顶部最小的特征图进行上采样之后与前面阶段的特征图相融合，最终只在最底层最大的特征图（自顶向下的最后一层也可以叫做 Finest Level）上进行预测。下面的结构预测是在每一层中独立进行的。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文的算法结构如图 3 所示，其结构包括一个自底向上的路径（bottom-up pathway）、自顶向下的路径（top-down pathway）以及横向连接（lateral connections），1times 1 卷积层的主要作用是减少卷积核的个数。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Bottom-Up Pathway 是网络的前向过程。论文将不改变 feature map 大小的层视为在同一个网络阶段（stage），每次抽取出来的 feature map 都是每个 stage 的最后一层输出，因为最后一层的特征是最强的，每个阶段的 feature map 记为 C_2 C_3 C_4 C_5。\nTop-Down Pathway 过程采用上采样（Upsampling）进行，生成的 feature map 记为 P_2 P_3 P_4 P_5。\nLateral Connections 是将上采样的结果和自底向上生成的相同大小的 feature map 进行融合（merge）。\n在融合过后会使用 3times 3 卷积对每个融合结果进行卷积，以消除上采样的混叠效应（Aliasing Effect）。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"将 FPN 用于 RPN 网络中生成 Region Proposal，在每一个 stage 都定义了不同大小的 anchor，对于 P_2 P_3 P_4 P_5 P_6 分别为 32^2 64^2 128^2 256^2 512^2，每种尺度的 anchor 有不同的比例 12 11 21，整个特征金字塔有 15 种 anchors。","category":"page"},{"location":"AI/CV/#两阶段检测算法","page":"计算机视觉","title":"两阶段检测算法","text":"","category":"section"},{"location":"AI/CV/#R-CNN","page":"计算机视觉","title":"R-CNN","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"基于区域的卷积神经网络（Region-based CNN，R-CNN）出现于 2014 年，是第一个将 CNN 用于目标检测的深度学习模型。它是是解决这种缺点的更好方法，它使用生成区域建议的方式来选择区域。R-CNN 的选框方式是根据选择性搜索来进行的，选框也叫做区域（regions）。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"首先使用无监督的选择性搜索（Selective Serch，SS）方法将图像中具有相似颜色直方图特征的区域进行合并，产生 2000 个大小不一样的候选区域。这个最后合成的区域就是物体在图片中的位置，即感兴趣区域（Region of Interest，RoI）；\n然后从输入图像中截取这些候选区域对应的图像，将其裁剪缩放 reshape 至合适的尺寸，并相继送入一个 CNN 特征提取网络进行高层次的特征提取；\n提取出的特征再被送入一个支持向量机（Support Vector Machine，SVM）来对这些区域进行分类，以及一个线性回归器进行边界框位置和大小的修正，即边界框回归（Bounding Box Regression）；\n最后对检测结果进行非极大值抑制（Non-Maximum Suppression，NMS），得到最终的检测结果；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"R-CNN 的不足：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"每一张图片都会生成很多个 RoI；\n整个过程用了三个模型：特征提取的 CNN、物体分类的 SVM、预测边界框的回归模型，让 R-CNN 变得非常慢，预测一张图片要几十秒；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"选择性搜索（Selective Serch，SS）：一个物体会包括四种信息：不同的尺度、颜色、纹理和边界，选择性搜索目标就是识别这些模式，提出不同的区域。首先，先生成最初的分割得很细的子分割，然后再将这些很细的小区域按照颜色相似度、纹理相似度、大小相似度和形状相似兼容性来合并成更大的感兴趣区域 RoI。","category":"page"},{"location":"AI/CV/#SPPNet","page":"计算机视觉","title":"SPPNet","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"SPPNet 出现于 2015 年，","category":"page"},{"location":"AI/CV/#Fast-R-CNN","page":"计算机视觉","title":"Fast R-CNN","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Fast R-CNN 出现于 2015 年，它添加了一个 RoI 池化层（RoI Pooling Layer）来把所有的建议区域转换成适合的尺寸，输入到后面的全连接层（Fully Connection）。Fast R-CNN 将 R-CNN 的三个独立的模型集合到一个模型中，因为减少了很多的计算量，Fast R-CNN 在时间花费大大地减少了。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"具体步骤为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"图片通过 CNN 得到 RoI，然后 RoI 池化层将 RoI 改变成相同的尺寸；\n再将这些区域输入到全连接层上进行分类，同时使用 softmax 和线性回归层（Linear Regression Layers）来输出 Bounding Boxes；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"RoI 池化层（RoI Pooling Layer）：目的是对非均匀尺寸的输入执行最大池化以获得固定尺寸的特征图。RoI 池化层的原型是何凯明提出的空间金字塔池化（Spatial Pyramid Pooling），RoI 池化是 SPP 只使用其中一层的特殊情况。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"RoI Pooling 接收卷积特征图作为输入；\n将 RoI 分割为 Htimes W 个网格（论文中为 7times 7），对每一个网格都进行 max pooling 得到最终 Htimes W 大小的特征图；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"下面是 RoI Pooling 的一个 GIF 示例：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Fast R-CNN 的优势和不足：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"依然在使用选择性搜索来作为寻找 RoI 的方法，虽然速度提高了，但是一张图片依旧需要花费 2 秒的时间。","category":"page"},{"location":"AI/CV/#Faster-R-CNN","page":"计算机视觉","title":"Faster R-CNN","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Faster R-CNN 出现于 2017 年，它使用一个区域建议网络（Region Proposal Network，RPN）来获得比 Fast R-CNN 更高的效率。RPN 将图片特征 map 作为输入，生成一系列带目标分数的建议，也就是告诉网络给出的区域有物体的可能性有多大，分数越高代表包含了物体的可能性越高。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"具体步骤：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"把图片作为输入放进卷积网络中去，返回的是一个特征映射（feature map）；\nRPN 处理这些 map，返回带分数的物体建议；\n接下来的 RoI pooling 把这些建议都 reshape 成相同的尺寸；\n最后，放到含有 softmax 层和线性回归层的全连接层上，来分类和输出 bounding boxes。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"RPN 被集成在了网络里面，等于从区域建议到最后的分类回归都在同一个网络，实现了端到端。即我们给这个网络输入一张图片，网络就会输出 bounding boxes 和分数。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"区域建议网络（Region Proposal Network，RPN）：可以输入任何大小的图片（或者特征映射图），然后输出一系列目标建议矩形框，每个矩形框都会有一个对应的分数，代表这个框里面有多大的概率是一个物体。在 Faster R-CNN 中 RPN 是一个全卷积网络（Fully-Convolutional Network，FCN）","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"图中的数据，在原论文中的具体值为：C_2=256 text or  512，H=W=16，k=9. ","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"RPN 实际上可以看成是一个小型的 CNN，原文说的是它在 feature map 上使用一个大小为 ntimes n 的滑动窗口（sliding window），在 Faster R-CNN 论文里 n=3：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"步骤 1：实际上 RPN 就是一个 3times 3 的卷积层，将维数（或者说通道数 Channel）为 C_1 的特征图 1 映射成维度为 C_2 的特征图 2（在 Faster R-CNN 论文中，在使用 ZF 模型时 C_2=256，在使用 VGG 模型时 C_2=512）；\n步骤 2：这个特征图 2 会分别进入两个 1times 1  卷积层，一个做矩形框分类（判断是否为物体），对应特征图 3-1，另一个做矩形框回归，对应特征图 3-2。1times 1 卷积的作用是压缩通道数（Channel），图中用于矩形框分类的特征图 3-1 通道数变为 2k，用于矩形框回归的特征图 3-2 通道数变为 4k，这里的 k 是 anchor boxes 的数量（在论文里取 k=9）。分类部分的维度为 2，分别表示框出的部分为「目标」与「非目标」的概率；回归部分的维度为 4，分别表征不同 anchor boxes 对 groud-truth 的长、宽、X 坐标、Y 坐标的预测；\n在训练的时候，只有 RPN 输出的区域建议与 groud-truth 的 textIoU07 的 anchor boxes 与 groud-truth 的位置大小误差才会对最终的损失 mathcalLoss 有贡献。\n对于特征图 1 中的每一个 ntimes n 的滑动窗口， RPN 输出 k 个区域建议，这 k 区域建议都是由 k 个 anchor boxes 作为基准调整得到的。特征图 1 中的每一个点都可以对应到原图的某个点，这个点称为锚点（anchor）。\n在论文中，对于每一个 anchor，以其为中心选择 9 个不同大小和不同长宽比的 anchor boxes，具体为 128^2 256^2 512^2 三种尺度，每个尺度按 11 12 21 的 3 种长宽比例进行缩放，因此一共有 9 个。\n实际上 RPN 并不是直接预测最终的区域建议，而是调节所有的 anchor boxes 并且经过非极大值抑制得到最终的区域建议。对于一个大小为 Htimes W 的特征图，会有 kHW 个 anchor boxes。\n对于每个 anchor，如果满足两种情况：（1）与 ground-truth box 有最大的 IoU（并不一定会大于 0.7）；（2）与 ground-truth 的 IoU 大于 0.7，那么给其分配正标签，表示预测的效果是好的；如果与 ground-truth 的 IoU 小于 0.3 那么给其分配负标签，表示预测的结果很差。除了这些情况，其他的 anchor 不会对对损失函数有贡献。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Faster RCNN 的损失函数由 4 个部分组成：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"RPN 分类损失：anchor 是否为 Ground Truth，二类交叉熵损失；\nRPN 位置回归损失：anchor 位置微调，bbox 的第一次修正；\nRoI 分类损失：RoI 所属类别，分类损失；\nRoI 位置回归损失：继续对 RoI 位置微调，第二次对 bbox 的修正；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"最终的损失是这 4 个损失相加。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"对于每一个图片，损失函数为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Lleft( p_it_i right) = frac1N_clssum_iL_cls(p_ip_i^*) + lambdafrac1N_regsum_ip_i^*L_reg(t_it_i^*)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中，i 是 mini-batch 中 anchor 的索引，p_i 是第 i 个 anchor 中为物体的预测概率。对于 ground-truth label  p_i^*，如果 anchor 是正标签那么其为 1，如果为负标签那么其为 0。t_i 为一个向量，表示所预测的边界框（Bounding Box）的 4 个坐标，t_i^* 表示正标签 anchor 所对应的 ground-truth box 的坐标。分类损失 L_cls 是两个类别（「目标」与「非目标」）的对数损失（Log Loss）；回归损失 L_reg(t_it_i^*)=R(t_it_i^*). ","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Faster R-CNN 的优势和不足：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"通过使用端到端的方式去进行，并且也不会考虑所有的 RoI，处理一张图片只需要 0.2 秒。","category":"page"},{"location":"AI/CV/#Light-Head-R-CNN","page":"计算机视觉","title":"Light-Head R-CNN","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Light-Head R-CNN 出现于 2017 年","category":"page"},{"location":"AI/CV/#Mask-R-CNN","page":"计算机视觉","title":"Mask R-CNN","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Mask R-CNN 出现于 2017 年","category":"page"},{"location":"AI/CV/#一阶段检测算法","page":"计算机视觉","title":"一阶段检测算法","text":"","category":"section"},{"location":"AI/CV/#YOLO","page":"计算机视觉","title":"YOLO","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"YOLO 出现于 2016 年","category":"page"},{"location":"AI/CV/#SSD","page":"计算机视觉","title":"SSD","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"SSD 出现于 2016 年","category":"page"},{"location":"AI/CV/#FCOS","page":"计算机视觉","title":"FCOS","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"发表于 ICCV2019 的论文：FCOS: Fully Convolutional One-Stage Object Detection 提出了 FCOS，与 YOLO 类似，它直接将 backbone 输出的 feature map 上的每一个像素当做预测起点，即把每一个位置都当做训练样本，只要该位置落入某个 Ground-Truth 框，就将其当做正样本进行训练。为了让一个目标在推理时不会在多个 feature map 上被重复输出，认为限制了每一层回归目标的尺度大小，超过该限制的目标，这一层就不检测。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文中图 2 展示了 FCOS 的具体结构：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"FCOS 在检测头增加一个中心度（Centerness）分支，保证回归框的中心和 GT 较为接近，同时和 FPN 结合，在每一层上只回归特定大小的目标，从而将不同尺度的目标分配到对应层级上","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textcenterness^*=sqrtfracmin(l^*r^*)max(l^*r^*)times fracmin(t^*b^*)max(t^*b^*)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 ","category":"page"},{"location":"AI/CV/#RetinaNet-(Focal-Loss)","page":"计算机视觉","title":"RetinaNet (Focal Loss)","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"推荐阅读：MMDetection；\nGitHub：MMDetection；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"何凯明在 ICCV2017 上的新作 Focal Loss for Dense Object Detection 提出了一个一个新的损失函数 —— Focal Loss，主要用于解决在单阶段目标检测场景上训练时前景（foreground）和背景（background）类别极端失衡（比如 1:1000）的问题。Focal Loss 可以抑制负样本对最终损失的贡献以提升网络的整体表现。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"将不含有待检测物体的区域称为负样本，含有待检测物体的区域称为正样本。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Focal Loss 的最终形式为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textFL(p_t)=-alpha_t(1-p_t)^gammalog(p_t)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"演变过程如下，一般来说，对于二分类问题，交叉熵损失为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textCE(py)=begincases-log(p)qquad textif  y=1 -log(1-p)quad textotherwise endcases","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 yinpm 1 是类别标签，pin0 1 是模型对于样本类别属于 y=1 的预测概率，定义","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"p_tbegincasesp qquad textif  y=1 1-p quad textotherwise endcases","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"因此交叉熵损失可以重写为 textCE(py)=textCE(p_t)=-log(p_t)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"这里应该区分的一个点是：难易样本不平衡和正负样本不平衡，Focal Loss 主要是在解决难易样本不平衡的问题上。一般解决正负样本不平衡的问题，会在交叉熵损失前面加上一个参数 alpha 得到","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textCE(p_t)=-alpha_tlog(p_t)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"只是这样的方案只能解决正负样本不平衡的问题，至于难易样本不平衡，Focal Loss 的思想就是降低高置信度样本的损失：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textFL(p_t)=-(1-p_t)^gammalog(p_t)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"假设 gamma=2 时，如果样本置信度为 p=0968，那么 (1-0968)^2approx 0001 就可以将这个高置信度样本的损失衰减 1000 倍。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"将增加参数 alpha 添加到 Focal Loss 上就可以同时解决正负以及难易样本不平衡的问题，最终 Focal Loss 的形式为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textFL(p_t)=-alpha_t(1-p_t)^gammalog(p_t)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"在 MMDetection 的 GItHub 开源代码中可以看到对于 Focal Loss 实现的 Python 代码，实际上真正使用的是 CUDA 版本代码，因此这里给出的代码只是供人学习的。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Focal Loss 存在的问题：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"模型过多地关注那些特别难分的样本 —— 离群点（outliers），即便是模型已经收敛了，但是这些离群点依旧是","category":"page"},{"location":"AI/CV/#SENet","page":"计算机视觉","title":"SENet","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"目标检测中的注意力机制","category":"page"},{"location":"AI/CV/#ATSS","page":"计算机视觉","title":"ATSS","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文 Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection 中提出了一种根据目标的统计信息自动选择正负样本的自适应样本选择机制（Adaptive Training Sample Selection，ATSS）。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文里提到无论是 anchor-based 方法还是 anchor-free 方法，","category":"page"},{"location":"AI/CV/#GFL","page":"计算机视觉","title":"GFL","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"推荐阅读：GFL 作者本人 李翔 的文章 知乎：大白话 Generalized Focal Loss；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"论文 Generalized Focal Loss: Learning Qualified and Distributed Bounding Boxes for Dense Object Detection 所提出的 广义焦点损失（Generalized Focal Loss，GFL）的具体形式如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textGFL(p_y_l p_y_r)=-y-(y_l p_y_l+y_rp_y_r)^betaleft( (y_r-y)log(p_y_l) + (y-y_l)log(p_y_r)right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"GFL 主要解决两个问题：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"在训练和推理的时候，分类和质量估计的不一致性；\n狄拉克分布针对复杂场景下（模糊和不确定性边界）存在不灵活的问题；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"解决这两个问题的方式是设计新的「表示」方法：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"通过联合质量估计和分类设计新的 Loss；\n定义一种新的边界框表示方式来进行回归；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"GFL 工作的核心是围绕表示（representation）的改进去进行的，表示具体是指检测器最终的输出，也就是 head 末端的物理对象，以 FCOS、ATSS 为代表的 one-stage anchor-free 检测器基本会包含 3 个表示：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"分类表示；\n检测框表示；\n检测框的质量估计。在 FCOS、ATSS 中采用 centerness，一些其他的工作会采用 IoU，这些 score 基本都在 0 到 1 之间；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"现有的表示主要存在的问题：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"classification score 和 IoU / centerness score 训练测试不一致，具体有：\n用法不一致。训练的时候，分类和质量估计是分开训练的，但是在测试的时候又是乘在一起作为 NMS score 排序的依据；\n对象不一致。质量估计通常只针对正样本训练，对于 one-stage 检测器而言，在做 NMS score 排序的时候，所有的样本都会将分类 score 和质量预测 score 相乘用于排序，这样会引发一个情况：一个分类 score 相对低的真正负样本，由于预测了一个不可信的高质量 score，导致到它可能排到一个分类 score 不高并且质量 score 较低的真正的正样本的前面；\nBounding Box 回归采用的表示不够灵活，没有办法建模复杂场景下的 uncertainty；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Focal Loss 支持 0 或者 1 类型的离散 label，而对于分类 - 质量联合表示，label 是 0～1 之间的连续值。如果对 Focal Loss 在连续 label 上进行拓展，就可以使其即保证平衡正负难易样本的特性，又支持连续数值的监督，因此得到 Quality Focal Loss（QFL），具体形式如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textQFL(sigma)=-y-sigma^betaleft((1-y)log(1-sigma)+ylog(sigma) right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 y 为 0～1 的质量标签，sigma 为预测，QFL 的全局最小解是 sigma=y。之后又增加了一个称为 Distribution Focal Loss（DFL）的 loss，目的是希望网络能够快速地聚焦到标注位置附近的数值，使得它们概率尽可能大，DFL 的具体形式如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"textDFL(S_iS_i+1)=-left((y_i+1-y)log(S_i)+(y-y_ilog(S_i+1)) right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"如果将 QFL 和 DFL 统一起来，就可以表示为 GFL。","category":"page"},{"location":"AI/CV/#人脸识别","page":"计算机视觉","title":"人脸识别","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"人脸识别中的模型 ArcFace……","category":"page"},{"location":"AI/CV/#SphereFace","page":"计算机视觉","title":"SphereFace","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"推荐阅读：人脸识别合集｜8 SphereFace 解析，作者：Mengcius：这篇文章写得十分好，十分详细地介绍了 SphereFace 以及介绍了 Softmax Loss 的进化路线。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"SphereFace（超球面），是佐治亚理工学院 Weiyang Liu 等在 CVPR 2017 年的论文 SphereFace: Deep Hypersphere Embedding for Face Recognition. 提出了将 Softmax Loss 从欧几里得距离转换到角度间隔，增加决策余量 m，限制 W=1 和 b=0. ","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"主要思想：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"开集人脸识别（Open-set face recognition）：通常，人脸识别可分为人脸识别和人脸验证。前者将一个人脸分类为一个特定的标识，而后者确定一对图片是否属于同一人。闭集（open-set）是测试图像在训练集中可能出现过；开集（close-set）是测试图像没有在训练集中出现过。开集人脸识别比闭集人脸识别需要更强的泛化能力。过拟合会降低性能。\n闭集的人脸识别：相当于分类问题，学习可分离的特征就可以了，人脸验证或识别时提取出标签。所有测试标识都在训练集中预先定义。很自然地将测试人脸图像分类为给定的身份。在这种情况下，人脸验证相当于分别对一对人脸图像进行识别。\n开集的人脸识别：测试集通常与训练集分离，因为不可能将所有人脸图像归纳在一个训练集中，我们需要将人脸映射到一个可辨别的本地特征空间。在这种情况下，人脸识别被视为在输入人脸图片和数据库中的每个身份之间执行人脸验证。它是度量学习问题，关键是学习有判别力的大间隔特征（discriminative large-margin features），人脸验证或识别时都要比较特征间的距离。\nOpen-set FR 对特征要求的准则：在特定的度量空间内， 需要类内的最大距离小于类间的最小距离。\nA-Softmax Loss (Angular Softmax Loss)：使得 CNN 能够学习角度识别特征，引入了角度间隔 m，以使人脸特征的最大类内距离要小于最小类间距离，使学习的特征将更具有判别力；\nL-Softmax Loss、A-Softmax Loss、CosFace、ArcFace、COCO Loss、Angular Triplet Loss等都是 angular margin learning 系列；\n预处理（人脸对齐）：人脸关键点由 MTCNN 检测，再通过相似变换得到了被裁剪的对齐人脸。RGB 图像中的每个像素范围在 [0, 255]，通过减去 127.5 然后除以 128 进行标准化；\n训练（人脸分类器）：CNN + A-Softmax Loss，CNN 使用 ResNet 中的残差单元；\nCNN 框架与传统的方法相同，可以兼容不同的网络架构（VGG/GoogLeNet/ResNet 等）；\n使用 m=4 的 Angular Softmax Loss，使得学习的特征更具有判别力；\n测试：\n从人脸分类器 FC1 层的输出中提取表示特征 SphereFace，拼接了原始人脸特征和其水平翻转特征获得测试人脸的最终表示；\n对输入的两个特征计算余弦距离（Cosine Similarity），得到角度度量（Angular Metric）；\n人脸验证：用阈值判断余弦距离；\n人脸识别：用最近邻分类器；\nLFW 上 99.42%，YTF 上 95.0%，训练集使用 CASIA-WebFace。2017 年在 MegaFace上 识别率在排名第一。","category":"page"},{"location":"AI/CV/#度量学习","page":"计算机视觉","title":"度量学习","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"度量学习（metric learning）：旨在学习一个相似的距离函数。传统的度量学习常常会学习一个距离度量矩阵 A ，在给定的特征 x_1x_2 上距离度量为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"x_1 - x_2_A=sqrt(x_1 - x_2)^top A (x_1 - x_2)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"最近流行的深度度量学习通常使用神经网络自动学习具有可区分性的特征 x_1x_2，然后是简单的进行距离度量，如欧几里得距离。用于深度度量学习的最广泛的损失函数是对比损失和三元组损失，两者都对特征施加了欧几里得距离。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"不同算分的度量学习：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"DeepFace、DeepID：通过 SoftMax Loss 学习面部特征，但只具有可分离性而不具有明显的可判别性。\nDeepID2：结合了 Softmax Loss 和 Contrastive Loss 以增强特征的判别能力。但它们产生不同的特征分布，Softmax 损失会产生一个角度的特征分布，对比损失是在欧几里得空间学习到的特征分布，所以特征结合时可能不是一个自然的选择。\nFaceNet：使用 Triplet Loss 来监督嵌入学习。但它需要非常大量数据（2 亿张人脸图像），计算成本很高。对比损失和三元组损失都不能限制在单个样本上，因此需要精心设计的双/三重挖掘过程，这既耗时又对性能敏感。\nVGGFace：先训练 CNN+Softmax Loss，再用 Triplet Loss 度量学习。\nA discriminative feature learning approach for deep face recognition. In ECCV2016：将 Softmax loss 与 Center loss 结合以增强特征的判别能力，但中心损失只起到缩小类间距离的作用，不具有增大类间距离的效果。\nL-Softmax Loss：作者和 A-Softmax Loss 是同一批人。L-Softmax Loss 也隐含了角度的概念。利用改进的 Softmax Loss 进行具有角度距离的度量学习。作为一种正则化方法，它在闭集分类问题上显示了很大的进步。A-Softmax Loss 简单讲就是在 Large-Margin Softmax Loss 的基础上添加了两个限制条件 W=1 归一化和 b=0，使得预测仅取决于 W 和 x 之间的角度。\n人脸识别的 DCNNs 有两个主要的研究方向：分类学习（对应 Softmax Loss）、度量学习（对应 Triplet Loss 等）。Contrastive Loss、Triplet Loss 等都将开集人脸识别问题视为度量学习问题，对比损失和三元组损失都是基于欧几里得距离的度量学习。","category":"page"},{"location":"AI/CV/#Softmax-Loss-的进化","page":"计算机视觉","title":"Softmax Loss 的进化","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Softmax 损失学习按角度分布的特征：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Softmax 损失可以自然地学习按角度分布的特征，如在训练集和测试集不同类别的特征只在角度上分离开，因此不会自然地促使包含任何欧几里德损失。\n从某种意义上说，基于欧几里德距离的损失与 Softmax 损失是不相容的，因此将这两种类型的损失结合起来并不是很好。\n学习特征时增大欧几里得距离，似乎是广泛认可的选择，但问题出现了：欧几里得距离是否总是适合于学习具有可判别性的面部特征？不适合，在 SphereFace 的文章中建议用角度距离代替。\n为什么用角度间隔？\n首先角度间隔直接与流形上的区别性联系在一起，流形上的区别性本质上与前面的一致，面也位于流形上。其次，由原始 Softmax Loss 获得的特征具有固有的角分布，将角度间隔与 Softmax Loss 结合起来实际上是更自然的选择。\n首先，它们只将欧几里得距离强加于学习到的特征，而我们的则直接考虑角度间隔。第二，contrastive loss、 triplet loss 在训练集中构成成对/三重集时都会受到数据扩展的影响，而我们的则不需要样本挖掘，并且对整个小批量都施加了可判别性约束（相比之下，对比损失和三重损失只会影响几个具有代表性的成对/三重集）。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"从一张图讲起：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(Image: )","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"（1）原始 Softmax Loss","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"如图 a, b，x 为学习到的特征向量，W_i 和 b_i 是最后一个全连接层对应类 i 的权值和偏置。Softmax 计算两个类的概率为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"hatboldsymboly=textsoftmax(boldsymbolW^top boldsymbolx)=fracexp(boldsymbolW^top boldsymbolx+boldsymbolb)boldsymbol1^top_Cexp(boldsymbolW^top boldsymbolx+boldsymbolb)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"如果以二分类为例：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"p_1=fracexp(W_1^top x + b_1)exp(W_1^top x + b_1) + exp(W_2^top x + b_2)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"p_2=fracexp(W_2^top x + b_2)exp(W_1^top x + b_1) + exp(W_2^top x + b_2)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Softmax 损失的让两个类别分开来的决策边界（Decision Boundary）是：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"(W_1 - W_2)x + b_1 - b_2 = 0","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"如果将 Softmax 重写成 W 和 x 的内积形式，就有了 cos 夹角：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL_i=-logleft(fracexpleft(W_y_i^top x_i + b_y_iright)sum_j expleft(W_j^top x_i + b_jright)right)=-logleft( fracexp left(W_y_i  x_i cos(theta_y_ii) + b_y_i right)sum_j exp left( W_jx_icos(theta_j i) + b_j right) right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"学习到的特征分布投射到一个球体上，就可以看到两类别间不能简单地通过角度分类。两类别是可以分离开的，但还是有一些误差，Softmax 只学习到了可分离的特征，但内聚性不好，判别性不够。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"（2）Modified Softmax Loss","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"如图 c, d，Modified softmax loss 能够直接优化角度，使 CNN 能够学习角度分布特征。为了实现角度决策边界，最终 FC 层的权重实际上是无用的。因此，首先对权重进行归一化并将偏置项归零（W_i=1 b_i=0），其公式为","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL_textmodified=frac1Nsum_i-logleft( fracexp(x_icos(theta_y_i i))sum_j exp(x_icos(theta_j i)) right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"后验概率为 p_1 = xcos(theta_1) p_2=x cos(theta_2)，决策边界变为","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"x(costheta_1 - costheta_2)=0","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"结果仅取决于 theta_1 和 theta_2. 这个改进的 Softmax Loss 可以学习带有角边界的特征，加强了角度可分性，但是这些特征还是没有判别性（discriminative）","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"（3）A-Softmax Loss","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"如图 e, f，进一步引入角度间隔（Angular Margin），让分类更加困难从而学习判别性。角度间隔更加大了，但分布的弧长变短了。A-Softmax loss（Angular Softmax Loss）针对不同的类别采用不同的决策边界（每个边界都比原边界更严格），从而产生角间隔。引入一个整数 m 来定量控制决策边界，二分类的类 1 和类 2 的决策边界分别变为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"从类别 1 正确分类，需要 cos(mtheta_1)cos(theta_2)，决策边界就是 cos(mtheta_1)=cos(theta_2)。从类别 2 则相反。\n从角度的观点来考虑，从标识 1 正确分类 x 需要 mtheta_1theta_2，而从标识 2 正确分类 x 则需要 mtheta_2theta_1。\n因为 m 是正整数，cos 函数在 0 到 pi 范围又是单调递减的，所以 mtheta_1 要小于 theta_2，m 值越大，theta_1 越聚合，则学习的难度也越大。因此通过这种方式定义损失会逼得模型学到类间距离更大的，类内距离更小的特征。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"x(cos(mtheta_1) - cos(theta_2)) = 0 text for class 1","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"x(cos(theta_1) - cos(mtheta_2)) = 0 text for class 2","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"A-Softmax Loss 公式是将改进的 Softmax Loss 中 theta 乘以系数 m 整数间隔值。即以乘法的方式惩罚深度特征与其相应权重之间的角度。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL_textang = frac1Nsum_i-logleft( fracexp(x_icos(mtheta_y_ii))exp(x_icos(mtheta_y_ii))+sum_jneq y_iexp(x_icos(theta_ji)) right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"上是中 theta 的范围是 0pim，为了摆脱这一限制，将 cos(mthetai) 推广到一个单调递减的角函数 psi(thetai). mge1 是控制角度间隔大小的整数，当 m=1 时它就是 Modified Softmax Loss。需要注意的是在每一次迭代中权重归一化为 1. A-Softmax Loss 的最终公式为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL_textang=frac1Nsum_i-logleft(fracexp(x_ipsi(theta_y_ii))exp(x_ipsi(theta_y_ii) + sum_jneq y_iexp(x_icos(theta_ji))) right)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 psi(theta_y_ii) = (-1)^kcos(mtheta_y_ii) - 2k theta_y_iiinfrackpimfrac(k+1)pim，且 kin0 m-1.","category":"page"},{"location":"AI/CV/#人脸识别中的损失函数","page":"计算机视觉","title":"人脸识别中的损失函数","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Softmax Loss：最常见的人脸识别函数，原理是去掉最后的分类层，作为解特征网络导出解特征向量用于人脸识别。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"hatboldsymboly=textsoftmax(boldsymbolW^top boldsymbolx)=fracexp(boldsymbolW^top boldsymbolx+boldsymbolb)boldsymbol1^top_Cexp(boldsymbolW^top boldsymbolx+boldsymbolb)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 boldsymbolW=boldsymbolw_1cdotsboldsymbolw_C 是由 C 个类的权重向量组成的矩阵，boldsymbol1^top_C 为 C 维的全 1 向量，hatboldsymbolyinmathbbR^C 为所有类别的预测条件概率组成的向量，第 c 维的值是第 c 类的预测条件概率。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL_textsoftmax=-frac1N_bsum_i=1^N_blog fracexp(boldsymbolw_y_iboldsymbolx+b_y_i)boldsymbol1^top_Cexp(boldsymbolW^top boldsymbolx+boldsymbolb)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 boldsymbolw_y_i b_y_i 代表实际标签 y_i 对应的权重和偏置。softmax 在训练的时候收敛迅速，但是精确度一般达到 0.9 时就不会再上升。一方面作为分类网络，softmax 不能像 metric learning 一样显式地优化类间和类内距离，所以性能不会特别好；另外，人脸识别的关键在于得到泛化能力强的 feature，与分类能力并不是完全等价的。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"L-Softmax Loss：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"SphereFace（A-Softmax）：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Focal Loss：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Triplet Loss：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Triplet Loss 是在谷歌 2015 年的 FaceNet 论文中的提出来的，用于解决人脸识别相关的问题，原文为：《FaceNet: A Unified Embedding for Face Recognition and Clustering》。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Triplet 三元组指的是 anchor, negative, positive 三个部分，每一部分都是一个 embedding 向量，其中","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"anchor 指的是基准图片；\npositive 指的是与 anchor 同一分类下的一张图片；\nnegative 指的是与 anchor 不同分类的一张图片；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Triplet Loss 的目的是让 anchor 和 positive 的距离变得越来越小，而与 negative 的距离变得越来越大，损失函数定义如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL=max(d(a p) - d(a n) + textmargin 0)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 a p n 分别代表 anchor，positive 和 negative。如果 negative example 很好识别时，anchor 与 negative 的距离会相对较大，即 d(an) 相比之下偏大，那么损失为 mathcalL=0；否则通过最小化损失函数，可以让 anchor 与 positive 的距离 d(ap) 更加接近 0，而与 negative 的距离 d(an) 更加接近给定的 margin。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"基于 triplet loss 的定义，可以将 triplet（三元组）分为三类：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"easy triplets（简单三元组）：triplet 对应的损失为 0 的三元组：d(an)d(ap) + textmargin；\nhard triplets（困难三元组）：negative example 与 anchor 距离小于 anchor 与 positive example 的距离，形式化定义为：d(an)d(ap)；\nsemi-hard triplets（一般三元组）：negative example 与 anchor 距离大于 anchor 与 positive example 的距离，但还不至于使得 mathcalLoss 为 0，即 d(ap)d(an)d(ap)+textmargin；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"PyTorch 实现：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"class TripletLoss(nn.Module):\n    \"\"\"Triplet loss with hard positive/negative mining.\n    \n    Reference:\n        Hermans et al. In Defense of the Triplet Loss for Person Re-Identification. arXiv:1703.07737.\n    \n    Imported from `<https://github.com/Cysu/open-reid/blob/master/reid/loss/triplet.py>`_.\n    \n    Args:\n        margin (float, optional): margin for triplet. Default is 0.3.\n    \"\"\"\n    \n    def __init__(self, margin=0.3,global_feat, labels):\n        super(TripletLoss, self).__init__()\n        self.margin = margin\n        self.ranking_loss = nn.MarginRankingLoss(margin=margin)\n \n    def forward(self, inputs, targets):\n        \"\"\"\n        Args:\n            inputs (torch.Tensor): feature matrix with shape (batch_size, feat_dim).\n            targets (torch.LongTensor): ground truth labels with shape (num_classes).\n        \"\"\"\n        n = inputs.size(0)\n        \n        # Compute pairwise distance, replace by the official when merged\n        dist = torch.pow(inputs, 2).sum(dim=1, keepdim=True).expand(n, n)\n        dist = dist + dist.t()\n        dist.addmm_(1, -2, inputs, inputs.t())\n        dist = dist.clamp(min=1e-12).sqrt()  # for numerical stability\n        \n        # For each anchor, find the hardest positive and negative\n        mask = targets.expand(n, n).eq(targets.expand(n, n).t())\n        dist_ap, dist_an = [], []\n        for i in range(n):\n            dist_ap.append(dist[i][mask[i]].max().unsqueeze(0))\n            dist_an.append(dist[i][mask[i] == 0].min().unsqueeze(0))\n        dist_ap = torch.cat(dist_ap)\n        dist_an = torch.cat(dist_an)\n        \n        # Compute ranking hinge loss\n        y = torch.ones_like(dist_an)\n        return self.ranking_loss(dist_an, dist_ap, y)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Center Loss：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"在 Triplet Loss 之后又提出了一个 Center Loss。Triplet 学习的是样本间的相对距离，没有学习绝对距离，尽管考虑了类间的离散性，但没有考虑类内的紧凑性。Center Loss 希望可以通过学习每个类的类中心，使得类内的距离变得更加紧凑，其公式如下：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"mathcalL_C=frac12sum_i=1^m x_i -c_y_i _2^2","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"其中 c_y_iinmathbbR^d 表示深度特征的第 y_i 类中心。理想情况下，c_y_i 应该随着深度特性的变化而更新。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"训练时：第一是基于mini-batch执行更新。在每次迭代中，计算中心的方法是平均相应类的特征（一些中心可能不会更新）。第二，避免大扰动引起的误标记样本，用一个标量 alpha 控制中心的学习速率，一般这个 alpha 很小（如 0.005）。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"计算 mathcalL_C 相对于 x_i 的梯度和 c_y_i 的更新方程为：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"fracpartial mathcalL_Cpartial x_i=x_i-c_y_i","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"Delta c_j = fracsum_i=1^m delta(y_i=j)cdot(c_j-x_i)1+sum_i=1^m delta(y_i=j)","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"class CenterLoss(nn.Module):\n    \"\"\"Center loss.\n    Reference:\n    Wen et al. A Discriminative Feature Learning Approach for Deep Face Recognition. ECCV 2016.\n    Args:\n        num_classes (int): number of classes.\n        feat_dim (int): feature dimension.\n    \"\"\"\n \n    def __init__(self, num_classes=751, feat_dim=2048, use_gpu=True):\n        super(CenterLoss, self).__init__()\n        self.num_classes = num_classes\n        self.feat_dim = feat_dim\n        self.use_gpu = use_gpu\n \n        if self.use_gpu:\n            self.centers = nn.Parameter(torch.randn(self.num_classes, self.feat_dim).cuda())\n        else:\n            self.centers = nn.Parameter(torch.randn(self.num_classes, self.feat_dim))\n \n    def forward(self, x, labels):\n        \"\"\"\n        Args:\n            x: feature matrix with shape (batch_size, feat_dim).\n            labels: ground truth labels with shape (num_classes).\n        \"\"\"\n        assert x.size(0) == labels.size(0), \"features.size(0) is not equal to labels.size(0)\"\n \n        batch_size = x.size(0)\n        distmat = torch.pow(x, 2).sum(dim=1, keepdim=True).expand(batch_size, self.num_classes) + torch.pow(self.centers, 2).sum(dim=1, keepdim=True).expand(self.num_classes, batch_size).t()\n        distmat.addmm_(1, -2, x, self.centers.t())\n \n        classes = torch.arange(self.num_classes).long()\n        if self.use_gpu: classes = classes.cuda()\n        labels = labels.unsqueeze(1).expand(batch_size, self.num_classes)\n        mask = labels.eq(classes.expand(batch_size, self.num_classes))\n        print(mask)\n \n        dist = []\n        for i in range(batch_size):\n            print(mask[i])\n            value = distmat[i][mask[i]]\n            value = value.clamp(min=1e-12, max=1e+12)  # for numerical stability\n            dist.append(value)\n        dist = torch.cat(dist)\n        loss = dist.mean()\n        return loss","category":"page"},{"location":"AI/CV/#光学字符识别","page":"计算机视觉","title":"光学字符识别","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"光学字符识别（Optical Character Recognition，OCR）：挖掘图像中的文本信息，需要对图像中的文字进行检测和识别。OCR 的确切定义是，将包含键入、印刷或场景文本的电子图像转换成机器编码文本的过程。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"OCR 算法通常分为两个基本模块，属于物体检测其中一个子类的文本检测以及文本识别。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"传统的文本检测：基于二值化的连通区域提取，基于最大极值稳定区域（Maximally Stable Extremal Regions，MSER），方向梯度直方图（Histogram of Oriented Gradient，HOG）可以提取特征；隐马尔可夫模型（Hidden Markov Model，HMM）对最终的词语进行预测。","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"文本检测框架的两种类型：","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"基于候选框：在通用物体检测的基础上，通过设置更多不同长宽比的锚框来适应文本变长的特性，以达到文本定位的效果。类似的模型包括：Rosetta、SegLink、TextBoxes++；\n基于像素分割：首先通过图像语义分割获得可能属于的文本区域的像素，之后通过像素点直接回归或者对文本像素的聚合得到最终的文本定位。类似的模型包括：TextSnake、SPCNet、MaskTextSpotter；\n不同方法的优缺点：\n基于候选框的文本检测对文本尺度本身不敏感，对小文本的检出率更高；但是对于倾斜角度较大的密集文本块，该方法很容易因为无法适应文本方向的剧烈变化以及对文本的包覆性不够紧密而检测失败。\n基于候选框的检测方法利用整体文本的粗粒度特征，而非像素级别的精细特征，因此其检测精度往往不如基于像素分割的文本检测。\n基于像素分割的文本检测往往具有更好的精确度，但是对于小尺度的文本，因为对应的文本像素过于稀疏，检出率通常不搞，除非以牺牲检测效率为代价对输入图像进行大尺度的放大。\n同时基于候选框和像素分割：将基于候选框的文本检测框架和基于像素分割的文本检测框架结合在一起，共享特征提取部分，并将像素分割的结果转换为候选框检测回归过程中的一种注意力机制，从而使文本检测的准确性和召回率都得到提高，例如云从科技公司提出的 Pixel-Anchor；","category":"page"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"检测文字所在位置（CTPN）和识别文本区域内容（CRNN）","category":"page"},{"location":"AI/CV/#EAST","page":"计算机视觉","title":"EAST","text":"","category":"section"},{"location":"AI/CV/","page":"计算机视觉","title":"计算机视觉","text":"一种高效准确的场景文本检测器（An Efficient and Accurate Scene Text Detector，EAST）：","category":"page"},{"location":"lang/Cpp/#基本知识","page":"C++","title":"基本知识","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"计算机系统：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"硬件：运算器、控制器、存储器、输入设备、输出设备\n软件：\n系统软件：操作系统、数据库系统、网络系统、程序设计语言与语言处理程序\n程序设计语言与语言处理程序：机器语言与汇编语言、高级语言（C 语言、Fortran 等）、面向对象的程序设计语言（C++ 等）\n应用软件","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"头文件：防卫式声明（guard）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"#inndef __NAME__  // 判断当前是否已经定义过\n#define __NAME__\n...;\n#endif","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓问：HelloWorld 程序从开始到打印到屏幕上的全过程是怎样的？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"用户通过键盘输入等方式告诉操作系统执行 HelloWorld 程序；\n进入「操作系统」部分：\n找到 HelloWorld 程序的相关信息，检查其类型是否为可执行文件；\n通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址；\n创建一个新进程，将 HelloWorld 可执行文件映射到该进程结构，表示由该进程执行 HelloWorld 程序；\n为 HelloWorld 程序设置 CPU 上下文环境，并跳到程序开始处；\n执行 Helloworld 程序的第一条指令，发生缺页异常；\n操作系统：分配一页物理内存，并将代码从磁盘读取内存，然后继续执行HelloWorld 程序；\nHelloWorld 程序执行 puts 函数（系统调用），在显示器上写出字符串；\n操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以操作系统将要写的字符串送给该进程；\n操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区；\n视频硬件将像素转换成显示器可接收的一组控制数据信号；\n显示器解释信号，激发液晶屏；\n在屏幕上出现 HelloWorld；","category":"page"},{"location":"lang/Cpp/#数据类型","page":"C++","title":"数据类型","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"(Image: image-20221104132336700)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类型 类型标识符 内存长度 数值范围 精度\n整型 [signed] int 4 -2147483648 ~ +2147483647 [-2^31, 2^31 - 1] \n无符号整型 unsigned [int] 4 0 ~ 4294967295 [0, 2^32 - 1] \n短整型 [signed] short [int] 2 -32768 ~ +32767 [-2^15, 2^15 - 1] \n无符号短整型 unsigned short [int] 2 0 ~ 65535 [0, 2^16 - 1] \n长整型 [signed] long [int] 8 [-2^63, (2^63 - 1)] \n无符号长整型 unsigned long [int] 8 [0, 2^64 - 1] \n字符型 [signed] char 1 -128 ~ +127 \n单精度型 float 4 [-2^128, 2^128] or [-3.4e+38, 3.4e+38] 7\n双精度型 double 8 [-2^1024, 2^1024] or [-1.79e+308, 1.79e+308] 16\n长双精度型 long double 同上/12 同上 19\n逻辑型 bool 1 0 或 1 ","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"浮点与整型同样的字节数，为什么前者可以表示的范围更大？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"float 和 double 的精度是由尾数位来决定的，而其范围是由指数位来决定的，float 的指数位有 8 位，double 的指数位有 11 位，它们的分布如下：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"float：1 bit [符号位] | 8 bits [指数位] | 23 bits [尾数位]，尾数位 2^23 = 8388608 一共 7 位，因此最多能够保证 7 位有效数字，但一定能够保证 6 位有效数字；指数位有 8 位，因此指数有 2^7 = 128。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"double：1 bit [符号位] | 11 bits [指数位] | 52 bits [尾数位]，尾数位 2^52 = 4503599627370496 一共 16 位，因此最多能够保证 16 位有效数字，但一定能够保证 15 位有效数字；指数位有 11 位，因此指数有 2^10 = 1024。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"常量（Constant）：程序中值不能被修改的数据。分为字面常量和符号常量。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"符号常量：定义形式 #define 标识符 常量","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"变量（Variable）：程序运行期间值可以改变的量。变量实际上就是计算机中的一个内存单元。变量类型 变量名列表;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"变量类型 变量名1 = 初值1, 变量名2 = 初值2, ...;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"(Image: image-20221104133915478)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"输入与输出：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"输入：从键盘、鼠标等外部输入设备向计算机输入数据；\n输出：向显示器、打印机等外部输出设备输出数据；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"#include <iostream>  // 标准输入输出流库的头文件\n#include <iomanip>  // 格式控制头文件\nusing namespace std;  ","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"cout 和 cin 对象的使用：cout << 表达式1 << 表达式2 << ...; 和 cin >> 变量1 >> 变量2 >> ...;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"cin 默认要求键盘输入数据之间使用空格、Tab 键、回车作为分隔符；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"格式控制：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"Switch 语句：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"switch (表达式) {\n    case 常量表达式1: 语句序列1;\n    case 常量表达式2: 语句序列2;\n    default: 默认语句序列;\n}","category":"page"},{"location":"lang/Cpp/#指针与引用","page":"C++","title":"指针与引用","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓问：指针和引用的区别是什么？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"指针和引用的区别：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。指针和引用都是一种内存地址的概念，区别在于指针是一个实体，而引用只是一个别名。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"指针时存储变量地址的变量；引用是变量的别名；\n指针变量定义时不必初始化；引用定义时必须初始化；\n指针变量定义时可以初始化为 NULL；引用不能初始化为 NULL；\nconst 修饰符：\nconst 修饰指针变量：const 放在之前，指针变量所指变量的值不可改变，指针值可以改变；const 放在之后，指针变量所指变量的值可以改变，指针值不可以改变；\nconst 修饰引用：const 放在 & 之前，不能修改引用所表示的变量的值；const 放在 & 之后，const 的作用被忽略，可以修改引用所表示的变量的值；\n非常指针在指针赋值后可以改变指针值；引用在初始化之后不能再作为别的变量的别名；\nsizeof 运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小；\n指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓问：指针参数传递和引用参数传递的区别？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放主调函数传递进来的实参值，从而形成实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。\n引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。\n引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。\n从编译的角度来讲，程序在编译时分别将指针的引用添加到符号表上，符号表中记录的是变量名以及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"智能指针：作用是管理一个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏的发生。智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"智能指针常用接口：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"T* get();\nT& operator*();\nT* operator->();\nT* operator=(const T& val);\nT& release();\nvoid reset (T* ptr = nullptr);","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"T 是模板参数，也就是传入的类型；\nget()用来获取 auto_ptr 封装在内部的指针，也就是获取原生指针；\noperator 重载了 ->, *, = 操作符；\nrelease() 将 auto_ptr 封装在内部的指针置为 nullptr，但并不会破坏指针所指向的内容，函数返回的是内部指针置空之前的值；\n直接释放封装的内部指针所指向的内存，如果制定了 ptr 的值，则将内部指针初始化为该值（否则将其设置为 nullptr；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 中的四种智能指针：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"1、auto_ptr：是 C++98 中的方案，C++11 中已经抛弃。采用所有权模式","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"auto_ptr<std::string> p1 (new string (\"hello\"));\nauto_ptr<std::string> p2;\np2 = p1;  // auto_ptr 不会报错","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"2、unique_ptr：实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄漏特别有用。采用所有权模式。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"unique_ptr<string> p3 (new string (auto));\nunique_ptr<string> p4; \np4 = p3;  // 此时会报错","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"编译器认为 p4 = p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更加安全。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"3、shared_ptr：共享型，强引用。实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在「最后一个引用被销毁」时候释放。从名字 share 就可以看出资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传入 auto_ptr、unique_ptr、weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性（auto_ptr 是独占的），在使用引用计数的机制上提供了可以共享所有权的智·能指针。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"4、weak_ptr：弱引用。是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"weak_ptr 只是提供了对管理对象的一个访问手段，其设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题，如果说两个 shared_ptr 相互引用，那么这两个指针的引用记数永远不可能下降为 0，也就是资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（析构函数没有被调用），解决办法：把其中一个改为 weak_ptr 就可以。","category":"page"},{"location":"lang/Cpp/#函数","page":"C++","title":"函数","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"函数：在调用一个函数之前必须有该函数的声明。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\n返回类型 函数名(形式参数列表)\n{\n    函数体声明部分\n    函数体执行语句\n}\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"内联函数（Inline Function）：在编译时将被调函数的代码直接嵌入到主调函数中，取消调用这个环节。内联函数中不允许使用循环语句和 Switch 语句，内联函数的声明必须出现在内联函数第一次调用之前。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\ninline 返回类型 函数名(形式参数列表)\n{\n\t函数体\n}\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"函数原型（Function Prototype）：作用是提供函数调用所必须的借口信息，使编译器能够检查函数调用中可能存在的问题，有两种形式：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"默认参数（Default Argument）：默认值可以是常量、全局变量、函数调用，不能是局部变量。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\n形式一：\n返回类型 函数名(类型1 形参1, 类型2 形参2, ..., 默认参数名1=默认值1, ...);\n\n形式二：\n返回类型 函数名(类型1, 类型2, ...);\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"函数重载（Function Overloading）：在同一个域中用同一个函数名来定义多个函数，但函数参数列表彼此不同（参数个数和参数类型至少有一个不同）。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓问：重载、重写和重定义的区别是什么？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"重载（overload）：是指同一可访问区域内被声明的几个具有不同参数列表的同名函数，依赖于 C++ 函数名字的修饰会将参数加在后面，可以是参数类型、个数、顺序的不同。根据参数列表决定调用哪个函数，重载不关心函数的返回类型；\n重写（override）：派生类中重新定义父类中除了函数体外完全相同的虚函数，注意被重写的函数不能是 static 的，一定要是虚函数，且其他一定要完全相同。重写和被重写的函数在不同的类当中，重写函数的访问修饰符是可以不同的，例如 virtual 中是 private 的，派生类中重写可以改为 public；\n重定义：派生类重新定义父类中相同名字的非 virtual 函数，参数列表和返回类型都可以不同，即父类中除了定义成 virtual 且完全相同的同名函数才不会被派生类中的同名函数所隐藏（重定义）；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"函数模板（Function Template）：一个独立于类型的函数，可作为一种模式，产生函数的特定类型版本。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\ntemplate<模板形参表>返回类型 函数名(形参列表)\n{\n\t函数体\n}\n\n模板形参表（Template Parameter List）的两种形式：\n形式一：typename 类型参数名1, typename 类型参数名2, ...\n形式二：class 类型参数名1, class 类型参数名2, ...\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"库函数：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"作用域：是程序中的一段区域，在同一个作用域上，C++ 程序中每个名字都与唯一的实体对应。在不同的作用域上，程序中可以多次使用同一个名字，对应不同作用域中的不同实体。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件作用域（File Scope）\n函数作用域（Function Scope）\n块作用域（Block Scope）\n类型声明作用域（Declaration Scope）\n函数原型作用域（Function Prototype Scope）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 实体可见规则：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"同一个作用域内不允许有相同名字的实体，不同作用域的实体可以有相同名字；\n实体在包含它的作用域内，从定义或声明的位置开始，按文件行的顺序往后（往下）直到该作用域结束均是可见的，包含作用域内的所有子区域及其嵌套；\n若实体 A 在包含它的作用域内的子区域中出现了相同名字的实体 B，则实体 A 被屏蔽；\n可以使用 extern 声明将变量或函数实体的可见区域往前延伸，称为前置声明（Forward Declaration）\n在全局作用域中，变量或函数实体若使用 static 修饰，则该实体对于其他源文件是屏蔽的，称为私有的（Private）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nextern 类型 变量名, ....\nextern 返回类型 函数名(类型1 参数名1, ...);\nextern 返回类型 函数名(类型1, ....);\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nstatic 类型 变量名[=初值], ...\nstatic 返回类型 函数名(类型1 参数名1, ...);\nstatic 返回类型 函数名(类型1, ...);\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"局部变量（Local Variable）：在函数内部或复合语句中（简称区域）定义的变量，又称内部变量","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在一个函数内部定义的变量\n函数的形式参数\n在某个符合语句中定义的变量","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓在函数中为什么返回局部变量会非法？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"全局变量（Global Variable）：在原文件中，但在函数外部定义的变量，其有效区域是从定义变量的位置开始到源文件结束","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"实体：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"变量或对象：变量、数组等\n函数\n类型：结构体类型、共用体类型、类类型等","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"生命期（Lifetimes）：每个名字都有作用域，每个对象都有生命期，即在程序执行过程中对象存在的时间。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"动态存储（Dynamic Storage Duration）：程序运行期间，系统为对象动态地分配存储空间。动态存储的特点是存储空间的分配和释放是动态的，要么由函数调用来自动分配释放，要么由程序指令来人工分配释放，这个生命期是整个程序运行期的一部分。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"其优点是对象不持久地占有存储空间，释放后让出空闲空间给其他对象的分配。动态存储在分配和释放的两种形式：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"自动存储（Automatic Storage）：由函数调用来自动完成\n自由存储（Free Storage）：由程序员通过指令的方式来人工完成","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"静态存储（Static Storage Duration）：对象在整个程序运行期持久占有存储空间，其生命期与程序运行期相同。特点是对象的数据可以在程序运行期始终保持直到修改为止，或者程序结束为止，静态存储的分配和释放在编译完成时就决定好了。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"除非有必要，尽量少使用静态存储","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"自动对象（Automatic Object）：默认情况下，函数或复合语句中的对象（包含形参）称为自动对象，其存储方式是自动存储，程序中大多数对象是自动存储：auto 类型 变量名[=初值], ...","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"寄存器变量：用 CPU 的寄存器来存放的局部变量 register 类型 变量名[=初值], ...","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"静态局部变量（Static Local Object）：在局部对象的前面加上 static 存储类别修饰 static 类型 变量名[=初值], ...","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"内部函数：在多文件的程序中，在连接时会检查函数在全局作用域内是否名字唯一，如果不是则出现连接错误。在函数定义前加上 static 修饰，则函数称为内部函数。内部函数仅在包含它的文件中有效，连接检查时就不会出现该函数名不唯一的连接错误。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nstatic 返回类型 函数名(形式参数列表)\n{\n\t函数体\n}\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"外部函数：在函数定义前加上 extern 声明，则函数称为外部函数，extern 可以省略，因为 C++ 中所有的函数本质上都是外部函数","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nextern 返回类型 函数名(形式参数列表)\n{\n\t函数体\n}\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"头文件：将每个源文件中外部函数的函数声明等信息集中写到一个文件中，称为头文件。别的源文件只需用文件包含命令将这个头文件包含，则编译时编译器自然就有了函数声明。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"数组：C++ 中数组的名字存储的就是数组的首地址。如果实参使用数组名调用，本质上是将这个数组的首地址传递到形参中。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\n元素类型 数组名[常量表达式];  // 一维数组\n元素类型 数组名[常量表达式] = {初值列表};\n\n元素类型 数组名[常量表达式1][常量表达式2];  // 二维数组\n元素类型 数组名[常量表达式1][常量表达式2]...[常量表达式n];  // 多维数组\n元素类型 数组名[常量表达式1][常量表达式2]...[常量表达式n] = {{初值列表1}, {初值列表2}, ...};\n\n初值列表元素个数可以小于等于数字长度，不够的位置初始化为 0\n如果定义时没有给定数组长度，那么会根据初值列表自动确定数组长度\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字符数组：用来存放字符型数据的数组，元素是一个个的字符。C++ 中字符串是以空字符 \\0 作为结束符的字符数组。字符串数组的长度为字符串长度加 1. 字符串常量是字符串的常量形式，以一对双引号括起来的字符序列，会自动在最后增加一个空字符。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nchar 字符数组名[常量表达式], ...;\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"使用标准输入输出流可以将整个字符串一次输入或输出\ngets 函数输入一个字符串到字符数组中\nputs 函数输出字符串，遇到空字符结束，输出完后再输出一个换行符\n字符串复制函数 strcpy(str1, str2)\n字符串复制函数 strncpy(str1, str2, n)\n字符串连接函数 strcat(str1, str2)\n字符串连接函数 strncat(str1, str2, n)\n字符串比较函数 strcmp\n字符串长度 strlen(str)\n字符串转换成数值函数 atof 和 atoi","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"string 对象没有初始化则一律是空字符串。允许使用运算符进行操作，实现类似 C 风格字符串的处理，比如复制、连接、比较","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"#include <string>\nstring str1;\nstr1 = \"Java\";  // C 风格字符串直接赋值给 string\nstr1.c_str();  // string 转换为 C 风格字符串，返回 char 指针\nstr1.copy(S1, n, pos);  // 把 str1 中从 pos 开始的 n 个字符复制到 S1字符数组\n\nstrcpy(S1, \"Pascal\");  // C 风格字符串复制到字符数组中\nstr1.assign(S1, n);  // C 风格字符串 S1 开始的 n 个字符赋值给 str1\n\nstr1.size();\nstr1.length();\nstr1.empty();\nstr1.substr(n, m);\nstr1.find(str, pos);  // 从 pos 开始查找字符串 str 在 str1 中的位置\nstr1.erase(n, m);  // 从下标 n 开始往后删除 m 个字符\nstr1.append(str, n, m);  // 在 str1 末尾增加 str 从 n 开始的 m 个字符\nstr1.replace(p0, n0, S1, n);  // 删除从 p0 开始的 n0 个字符，然后在 p0 处插入字符串 S1 前 n 个字符\nstr1.replace(p0, n0, str2, pos, n);  // 删除从 p0 开始的 n0 个字符，然后在 p0 处插入字符串 str2 中 pos 开始的前 n 个字符\nstr1.insert(p0, S1, n);  // 在 p0 位置插入字符串 S1 前 n 个字符\nstr1.insert(p0, str2, pos, n);  // 在 p0 位置插入字符串 str2 中 pos 开始的前 n 个字符","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字符串对象数组：定义数组元素是字符串对象，定义形式与数组类似","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义一个类时，也就是定义了一个具体的数据类型。若要使用类，需要将类实例化，即定义该类的对象。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"先定义类类型再定义对象：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"将类的名字直接用作类型名 类名 对象名列表;\n指定关键字 class 或 struct 后面跟着类的名字 class 类名 对象名列表; 或 struct 类名 对象名列表;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义类类型的同时定义对象：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nclass 类名 {  // 类体\npublic: ...  // 公有的数据成员和成员函数\nprivate: ...  // 私有的数据成员和成员函数\n\t成员列表\n} 对象名列表;\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"直接定义对象","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nclass {  // 无类名类体\n\t成员列表\n} 对象名列表\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"一般来说，定义类型时不进行存储空间的分配，当定义一个对象时，将为其分配存储空间。利用 new 运算符可以动态地分配对象空间，delete 运算符释放对象空间。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"动态分配对象的一般形式为：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\n类名 * 对象指针变量\n对象指针变量 = new 类名;\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"用 new 运算动态分配得到的对象是无名的，它返回一个指向新对象的指针的值，即分配得到是对象的内存单元的起始地址。程序通过这个地址可以间接访问这个对象，因此需要定义一个指向类的对象的指针变量类存放该地址。用 new 建立的动态对象是通过指针来引用的。在执行 new 运算时，如果内存不足，无法开辟所需的内存空间，C++ 编译器会返回一个 0 值指针。因此，只要检测返回值是否为 0，就可以判断动态分配对象是否成功，只有指针有效才能使用对象指针。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当不再需要使用由 new 建立的动态对象时，必须使用 delete 运算进行撤销。new 建立的动态对象不会自动被撤销，即使程序运行结束，必须认为使用 delete 撤销。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"动态分配数组：通过指针管理数组。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义指针 p\n分配数组空间，用来存储数组元素，空间大小按元素个数计算\n按一维数组的方式使用这个数组。一维数组 p[i]，二维数组 p[i*M + j]，其中 M 为列元素个数\n释放数组空间","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"动态分配字符串：由字符指针管理字符串","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义字符指针\n分配字符串空间，用来存储字符串\n使用这个字符串\n释放字符串空间","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓函数能不能返回对象？","category":"page"},{"location":"lang/Cpp/#结构体","page":"C++","title":"结构体","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"结构体：将不同类型的成员组合起来。结构体类型声明一般放在程序文件开头，声明是全局的，同作用域内的所有函数都可以使用它。如果放在函数内部，那么这个结构体的声明就是局部的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"结构体类型和普通数据类型一样是类型名称，而不是该类型的一个实体，因此不会为结构体类型分配存储空间\n结构体类型声明时成员也可以是结构体类型，即可以嵌套使用","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"结构体类型实例化：定义结构体对象称为结构体类型实例化（Instance），实例化会根据数据类型为结构体对象分配内存单元","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"不能够将一个结构体对象作为整体输入或输出，只能对结构体对象中的成员逐个进行输入或输出。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"结构体对象可以进行赋值运算，但是不是进行算术运算、关系运算","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nstruct 结构体类型名 {\n\t成员列表\n}\n\n定义：\n结构体类型名 结构体对象名列表;\n\n可以声明的同时定义对象\n\n结构体对象成员引用：在多级嵌套结构体时可以逐级引用\n结构体对象名.成员名\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"结构体数组：数组的元素是结构体类型 struct 结构体类型名 结构体数组名[常量表达式];","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"假设 p 是指向结构体对象的指针，通过 p 引用结构体对象成员有两种方式：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对象法：(*p).成员名\n指针法：p->成员名，这种方式更为常用 -> 为指针成员引用运算符","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"共用体（Union）：一种成员共享存储空间的结构体类型。是抽象的数据类型，因此程序中需要事先声明具体的共用体类型：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"共用体与 union 一起作为类型名称，成员列表是该类型数据元素的集合，大括号 {} 是成员列表边界符，后面必须用分号 ; 结束","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"结构体的内存长度是所有成员内存长度之和；而共用体的内存长度是所有成员内存长度的最大值。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"先声明共用体类型再定义共用体对象：union 共用体类型名 共用体对象名列表\n同时声明共用体类型和定义：union 共用体类型名 {成员列表} 共用体对象名列表\n直接定义共用体对象：union {成员列表} 共用体对象名列表","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"共用体对象成员特点：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"修改一个成员会使其他成员发生改变，所有成员存储的总是最后一次修改的结果；\n所有成员的值是相同的，区别是不同的类型决定了使用这个值的全部或者是部分；\n所有成员的起始地址是相同的，因此通常只按一个成员输入、初始化；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\nunion 共用体类型名 {\n\t成员列表\n};\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"枚举类型：由用户自定义的由多个命名枚举常量构成的类型 enum 枚举类型名 {命名枚举常量列表}，默认时枚举常量从 0 开始，后续的枚举常量总是前一个的枚举常量加 1. ","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以在（仅仅在）声明枚举类型时，为命名枚举常量指定值；\n命名枚举常量是一个整型常量值，也称为枚举器，在枚举类型范围内必须是唯一的。命名枚举常量是右值不是左值。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以用 typeof 声明一个新类型名来代替已有类型名 typeof 已有类型名 新类型名。新类型名习惯上用大写标识。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"链表：存储空间能动态进行增长或缩小的数据结构。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以建立不定长度的数组；\n可以在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数据元素","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// 单链表\nstruct LNode {  // 单链表结点数据类型\n    ElemType data;  // 数据域\n    LNode *next;  // 指针域：指向直接后继结点\n};\ntypedef LNode* LinkList;  // LNode 为单链表结构体类型，LinkList 为单链表指针类型","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"创建链表常用的两种方法：头插法和尾插法","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"头插法 CreateLinkF(&L, n, input())：先建立一个头结点 *L，然后产生新结点，设置新结点的数据域；再将新结点插入到当前链表的表头，直至指定数目的元素都增加到链表中为止","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"创建头结点 *L，设置 *L 的 next 为 0\n动态分配一个结点 s，输入 s 的数据域\n将 s 插入到开始结点之前，头结点之后\n重复 2. 到 4. 步","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"编译、连接处理过程：含有预处理命令的 C 源程序，经过预处理器预处理之后，得到不含预处理命令的 C 源程序，经过编译器编译之后得到目标代码，然后通过连接器连接之后得到可执行文件。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"预处理命令不是 C++ 本身的组成部分，更不是 C++ 语句，是 C++ 标准规定的可以出现在 C++ 源程序文件中的命令。这些命令必须以 # 开头，结尾不加分号，可以放置在源程序中的任何位置，其有效范围是从出现位置开始到源程序文件末尾。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"宏是由宏定义命令事先定义的，预处理时，对程序中所有后续的宏名实例（称为宏引用），预处理器都用字符文本去替换，称为宏替换或宏展开。宏定义通常用于定义程序中的符号常量、类型别名、运算式代换、语句代换等，其命令为 #define，分为不带参数的宏定义和带参数的宏定义。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"不带参数的宏定义 #define 宏名 字符文本\n带参数的宏定义 #define 宏名(参数表) 字符文本，引用形式为 宏名(引用参数表)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"需要注意的是，宏只是简单地做替换，因此应在宏串或实参字串中加入必要的括号","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"# 运算符的作用是文本参数「字符串化」，即出现在宏定义字符文本中的 # 把跟在后面的参数转换成一个 C++ 字符串常量。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"## 运算符的作用是将两个字符文本连接成一个字符文本，如果其中一个字符文本是宏定义的参数，连接会在参数替换后发生。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件包含命令：把指定的文件插入到该命令所处的位置上取代该命令，然后再进行编译处理，相当于将文件的内容「嵌入」到当前的源文件中一起编译。#include <头文件名> 或者 #include \"头文件名\"","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件包含命令中的投文件名可以写成绝对路径的形式也可以写成相对路径的形式\n头文件避免重复包含的两个办法：使用条件编译、使用特殊预处理命令 #pragma","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"条件编译命令 #ifdef","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\n#ifdef 条件字段\n\t......  // 程序代码段 1\n#endif\n\n#ifdef 条件字段\n\t......  // 程序代码段 1\n#else\n    ......  // 程序代码段 2\n#endif\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"条件编译命令 #if","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"/*\n#if 常量表达式 1\n\t......  // 程序代码段 1\n#elseif 常量表达式 2\n\t......  // 程序代码段 2\n#else\n\t......  // 程序代码段 3\n#endif\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C 语言是面向过程的程序设计思想，自顶向下，逐步求精，是由一个 main 函数加若干个子函数组成；C++ 语言是面向对象的程序设计思想，实现软件设计的产业化，自然界是由实体（对象）组成的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"抽象：对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程，包括数据抽象和行为抽象\n封装：将抽象出的数据成员、行为成员相结合，将他们视为一个整体 —— 类。使用者不需要了解具体的实现细节，只需要通过借口使用类的成员即可；\n继承与派生：保持原有类特性的基础上，进行更具体的说明","category":"page"},{"location":"lang/Cpp/#类","page":"C++","title":"类","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类（Class）：用户自定义数据类型。如果程序中要使用类类型（Class Type），必须根据实际需要定义，或者使用已设计好的类。其中成员列表（Member List）是类成员的集合，数目可以任意多，由具体应用确定。一对大括号 {} 是成员列表边界符，与成员列表一起称为类体（Class Body）。类体后必须使用分号 ; 结束。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"每个类可以没有成员，也可以有多个成员\n类成员可以是数据或函数\n所有成员必须在类的内部声明，一旦类定义完成后，就没有任何其他方式可以再增加成员\n成员函数能够访问类自身的所有成员\n外部不能够直接访问类内数据，把成员函数作为对外界的接口，通过成员函数访问数据。数据成员是属性，成员函数是方法，通过方法存取属性\n如果类中有成员函数，则声明成员函数是必需的，而定义成员函数则是可选的，因此类的成员函数有两种形式","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 类名 {  // 类体\n    成员列表\n    static 返回类型 函数名(形式参数列表);  // 静态成员函数\n    \npublic:  // 公有访问权限\n\t// ...\nprotected:  // 保护访问权限\n\t// ...\nprivate:  // 私有访问权限\n\t// ...\n\n\t\n\t返回类型 函数名(形式参数列表)  // 在类中定义（也是声明）成员函数\n\t{\n\t\t函数体\n\t}\n\t返回类型 函数名1(形式参数列表);\n};\n\n// 外部定义\n返回类型 类名::函数名(形式参数列表) {  // 成员函数定义在类外部实现\n\t函数体\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓问：类和结构体的区别","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 和 struct 的唯一区别，是访问权限（包括继承的访问权限）默认是 private 还是 public。其他方面 class 和 struct 完全一样。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 规定，在局部作用域中声明的类，成员函数必须是函数定义形式，不能是原型声明。一般来说很少有将类放到局部作用域中去定义。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对类的成员进行访问，来自两个访问源：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类成员：类本省的成员函数\n类用户：类外部的使用者，包括全局函数、另一个类的成员函数等","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"无论数据成员还是函数成员，类的每个成员都有访问控制属性，由以下三种访问标号说明：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"公有的 public ：类成员和类用户都可以访问公有成员，任何一个来自类外部的类用户都必须通过公有成员来访问。public 实现了类的外部接口。\n私有的 private：只有类成员可以访问私有成员，类用户的访问是不允许的。private 实现了私有成员的隐蔽。\n保护的 protected：在不考虑继承的情况下，protected 的性质和 private 的性质一致，但保护成员可以被派生类的类成员访问。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":":: 是作用域限定符（Field Qualifed），如果在作用域限定符的前面没有类名，或者函数前面既无类名又无作用域限定符，则表示函数不属于任何类，这个函数不是成员函数，而是全局的普通函数。此时的 :: 不是类作用域限定符的含义，而是命名空间域限定符的含义。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在成员函数中可以访问这个类的任何成员，无论它是公有的还是私有的，是类内部声明的还是外部定义的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虽然成员函数在类的外部定义，但在调用成员函数时会根据在类中声明的函数原型找到函数的定义（即函数代码），从而执行该函数。因此类的成员函数原型声明必须出现在成员函数定义之前，否则编译时会出错。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在类的内部声明成员函数，而在类的外部定义成员函数，是一个良好的编程习惯。不仅可以减少类体的长度，使类体结构清晰，便于阅读，而且有助于类的接口和实现分离。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类的成员函数可以指定为 inline 内联函数，在默认情况下，类体中定义的成员函数若不包括循环等控制结构，符合内联函数要求时，C++ 会自动将它们作为内联函数处理，隐式 inline。 ","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"成员函数重载及默认参数：可以对成员函数重载或使用默认参数。声明成员你函数的多个重载版本或者指定成员函数的默认参数，只能够在类内部中进行。类定义中的声明先于成员函数的外部实现，根据重载或默认参数函数的要求，必须要在第 1 次出现函数声明或定义时就明确函数是否重载或有默认参数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"由于不论调用哪一个对象的函数代码，实际上调用的都是同样内容的代码。因此，若像上图那样存放相同代码的多份副本，既浪费空间又无必要。实际上，成员函数代码只有公用的一段存储空间，调用不同对象的成员函数时都是执行同一段函数代码。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类不能具有自身类型的数据成员。然而，只要类名一经出现就可以认为该类已声明。因此，类的数据成员可以是指向自身类型的指针或引用。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"构造函数（constructor）：每个类都分别定义了它的对象。构造函数初始化对象的非 static 数据成员，还可能做些其他工作；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"委托构造函数：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓什么是委托构造函数？怎么使用委托构造函数？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"析构函数释放对象使用的资源，并销毁对象的非 static 成员，执行与构造函数相反的操作。析构函数不接受参数，无法被重载。构造函数的名称要与类名一样。一般来说，不带指针的类可以不用指定析构函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓问：C++ 中的构造函数都有哪些？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"无参数构造函数：即默认构造函数，如果没有明确写出无参数构造函数，编译器会自动生成默认的无参数构造函数，函数为空，什么也不做。如果不想使用自动生成的无参数构造函数，必须要自己写出一个无参数构造函数；\n一般构造函数：也称重载构造函数，一般构造函数可以有各种参数形式，一个类可以有多个一般构造函数，前提是参数的个数或者类型不同，创建对象时根据传入参数不同调用不同的构造函数。\n拷贝构造函数：拷贝构造函数的函数参数为对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在的对象的数据成员的值一一复制到新创建的对象中。如果没有显式地写出拷贝构造函数，则系统会默认创建一个拷贝构造函数，但当类中有指针成员时，最好不要使用编译器提供的默认的拷贝构造函数，最好自己定义并且在函数中执行深拷贝；\n类型转换构造函数：根据一个指定类型的对象创建一个本类的对象，也可以算是一般构造函数的一种，这里提出来，是想说有的时候不允许默认转换的话，要记得将其声明为 explict 的来阻止一些隐式转换的发生；","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"赋值运算符的重载：这个类似拷贝构造函数，将 = 右边的本类对象的值复制给 = 左边的对象，它不属于构造函数，左右两边的对象必须已经被创建。如果没有显式地写出赋值运算符重载，系统也会生成默认的赋值运算符，做一些基本的拷贝工作。注意区分：A a1, A a2;\na1 = a2;  // 调用赋值运算符，a1 和 a2 都存在\nA a3 = a1;  // 调用拷贝构造函数，因为进行的是初始化工作，a3 并未存在","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓深拷贝与浅拷贝的区别是什么？如何自定义拷贝构造函数？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对象数组：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在建立对象数组时，需要调用构造函数。如果对象数组有 100 个元素，就需要调用 100 次构造函数；\n如果对象数组所属类有带参数的构造函数时，可用初始化列表按顺序调用构造函数，使用复制初始化来初始化每个数组元素\n如果对象数组所属类有单个参数的构造函数时，定义数组时可以直接在初值列表中提供实参\n对象数组创建时若没有初始化，则其所属类要么有合成默认构造函数（此时无其他的构造函数），要么定义无参数的构造函数或全部参数为默认参数的构造函数（此时编译器不再合成默认构造函数）\n对象数组的初始化式究竟是什么形式，本质上取决于所属类的构造函数。因此，需要明晰初始化实参与构造函数形参的对应关系，避免出现歧义性；\n如果对象数组所属类含有析构函数，那么每当建立对象数组时，按每个元素的排列顺序调用构造函数；每当撤销数组时，按相反的顺序调用析构函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以定义一个指针变量，用来存放对象的指针，指向类对象的指针变量的定义：类名 *对象指针变量名 = 初值;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对象的成员要占用存储空间，因此也有地址，可以定义指向对象成员的指针变量：数据成员类型 *指针变量名 = 初值;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 相比较于 C 语言有更加严格的静态类型，更加强调类型安全和编译时检查。因此，C++ 的指针被分成数据指针、函数指针、数据成员指针、成员你函数指针四种，而且不能相互装换。前两种是 C 语言的普通指针（ordinary pointer），后两种是 C++ 专门为类扩展的成员指针（pointer to member）。成员指针与类的类型和成员的类型相关，它只应用于类的非静态或成员。由于静态类成员不是任何对象的组成部分，所以静态成员指针可用普通指针。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"数据成员指针：数据成员类型 类名::*指针变量名 = 成员地址初值;\n成员函数指针：返回类型 (类名::*指针变量名)(形式参数列表) = 成员地址初值; 或 返回类型 (类名::*指针变量名)(形式参数列表) const = 成员地址初值;，定义成员函数的指针时必须确保在三个方面与它所指函数的类型相匹配：\n函数形参的类型和数目，包括长远是否为 const；返回类型；所属类的类型；\n类成员指针：\n通过对象成员指针引用 .* 可以从类对象或引用及成员指针间接访问类成员\n通过指针成员指针引用 ->* 可以从指向类对象的指针及成员指针访问类成员\n对象成员指针引用运算符左边的运算对象必须是类类型的对象，指针成员指针引用运算符左边的运算对象必须是类类型的指针，两个运算符的右边运算对象必须是成员指针","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"除了静态成员函数外，每个成员函数都有一个额外的、隐含的形参 this，在调用成员函数时，编译器向形参 this 传递调用成员函数的对象的地址。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"void Point::set(int a, int b) {  // 成员函数定义\n    x = a;\n    y = b;\n}\n\n// 编译器实际上会重写这个函数为\nvoid Point::set(Point* const this, int a, int b) {\n    this->x = a;\n    this->y = b;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在类的非静态成员函数中返回类对象本省的时候，直接使用 return *this。this 指针的指向不允许改变，其原本就是一个 const 指针。既不允许改变 this 指针的指向，也不允许改变 this 指向的内容。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当参数与数据成员名相同时，类自身的成员要写成 this->n","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类作用域中的名字查找（name lookup），即寻找与给定的名字相匹配的声明的过程","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"首先，在使用该名字的块中查找名字的声明，且只考虑在该名字使用之前声明的名字；\n如果找不到该名字，则在包围的作用域中查找\n如果找不到任何声明，则编译错误","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"嵌套类（nested class）：在一个类 A 内部定义的类 B 称为嵌套类，或者嵌套类型（nested type），称类 A 为外围类（enclosing class）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"局部类：在函数体内定义的类称为局部类，一个局部类定义了一个类型，该类型只在定义它的局部作用域中可见。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"局部类的所有成员（包括函数）必须完全定义在类体内\n局部类可以访问的外围作用域中的名字是有限的。局部类只能访问在外围作用域中定义的类型名、静态变量和枚举成员，不能使用定义该类的函数中的变量\n外围函数对局部类的私有成员没有特殊访问权，当然，局部类可以将外围函数设为友元。实际上，局部类中 private 成员几乎是不必要的，通常局部类的所有成员都为 public 成员\n可以访问局部类的程序部分是非常有限的。局部类封装在它的局部作用域中，进一步通过信息隐藏进行封装通常是不必要的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"按生命期的不同，对象可以分为四种：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"局部对象：在运行函数时被创建，调用构造函数；当函数运行结束时被释放，调用析构函数\n静态局部对象：在程序执行函数第一次经过该对象的定义语句时被创建，调用构造函数。这种对象一旦被创建，在程序结束前都不会撤销。即使定义静态局部对象的函数结束时，静态局部对象也不会撤销。在该函数被多次调用的过程中，静态局部对象会持续存在并保持它的值。静态局部对象在程序运行结束时被释放，调用析构函数。\n全局对象：在程序开始运行时，main 运行前创建对象，并调用构造函数，在程序运行结束时被释放，调用析构函数\n自由存储对象：用 new 分配的自由存储对象在 new 运算时创建对象，并调用构造函数。在 delete 运算时被释放，调用析构函数。自由存储对象一经 new 运算创建，就会始终保持直到 delete 运算时，即使程序运行结束它也不会自动释放。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"const 限定：既要使得数据能在函数间共享，又要保证它不被任意修改，可以使用 const 限定，即把数据定义为只读的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"常对象中的数据成员均是 const 的，因此必须要有初值。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"如果一定要修改对象中的某个数据成员的值，可以将数据成员声明为 mutable（可变的）来修改它的值：mutable 数据成员类型 数据成员列表;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"常成员函数：在定义成员函数时使用 const 限定，称它为常成员函数。const 的位置在函数头和函数体之间。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 类名 {\t// 类体\n    // ...\n    返回类型 函数名(形式参数列表) const  // 常成员函数定义\n    {\n        函数体\n    }\n    // ...\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"(Image: image-20221106100453517)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在一个类中，如果有些数据成员的值允许修改，另一些数据成员的值不允许修改，那么可以将一部分数据成员声明为 const（常数据成员），使得其值不能被修改。而普通的成员函数可以修改普通的数据成员，但只能访问常数据成员的值。\n如果要求所有数据成员的值都不允许改变，可以将对象声明为 const（常对象），那么只能用 const 成员函数访问数据成员，且不能修改其值。这样，数据成员无论如何也不会被修改。\n如果定义了一个常对象，只能调用其中的 const 成员函数，而不能调用非 const 成员函数。如果需要访问对象中的数据成员，可以将常对象中所有成员函数都声明为 const 成员函数，但应确保在函数中不会修改对象中的数据成员。\n常对象中的成员函数不一定是常成员函数。如果在常对象中的成员函数未加 const 声明，C++ 把它作为非常成员函数处理\n常成员函数不能调用另一个非常成员函数","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"指向对象的常指针：类名 * const 指针变量名 = 对象地址; 虽然常指针是 const 的不能改变指向，但常指针所指向的对象却不一定是 const 的。使用常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。如果在函数执行过程中试图修改常指针形参的值，就会出现编译错误。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"指向常对象的指针变量：const 类名 * 指针变量名; 指针变量指向的对象是 const 的常对象，不能够通过该指针改变所指对象的值，但是指针变量本身的值是可以改变的，因此可以在定义时不初始化","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"如果一个对象已被声明为常对象，只能用指向常对象的指针变量指向它\n如果定义了一个指向常对象的指针变量，即使它指向一个非 const 的对象，其指向的对象也是不能通过指针来改变的\n指向常对象的指针常用作函数形参，目的是在保护形参指针所指向的对象，使它在函数执行过程中不被修改","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对象的常引用：在 C++ 程序中，经常用对象的常指针和常引用作函数参数。这样既能够保证数据安全，使数据在函数中不能被随意修改，又在调用函数时不必传递实参对象的副本，大幅减少函数调用的空间和时间的开销。const 类名 & 引用变量名;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以定义类的静态成员，能够实现同类的多个对象之间数据共享。使用类的静态成员的优点：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"静态成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突\n静态成员可以实施封装，可以是私有成员，而全局对象不可以\n静态成员是与特定类关联的，结构清晰","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"静态数据成员：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"通常，非静态数据成员存在于类类型的每个对象中，静态数据成员则独立于该类的任何对象，在所有对象之外单独开辟空间存储。在为对象所分配的空间中不包括静态数据成员所占的空间。\n如果只声明了类而未定义对象，则类的非静态数据成员时不占存储空间的，只有在定义对象时，才为对象的数据成员分配空间。但只要在类中定义了静态数据成员，即使不定义任何对象，也为静态数据成员分配空间，它可以在尚未建立对象时就被引用。\n访问静态成员时同样需要遵守公有及私有访问规则\n静态数据成员必须在类外部定义一次（仅有一次），静态成员不能通过类构造函数进行初始化，而是在类外定义时进行初始化。定义静态数据成员 数据成员类型 类名::静态数据成员名 = 初始化式;\n静态数据成员可以用作默认实参，非静态数据成员不能用作默认实参，因为它的值不能独立于所属的对象而使用。\n有了静态数据成员，各对象之间实现了数据共享，因此可以不使用全局变量","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"静态成员函数：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 类名 {\n    // ...\n    static 返回类型 函数名(形式参数列表);\n    // ...\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"静态成员函数与非静态成员函数的根本区别：非静态成员函数有 this 指针，而静态成员函数没有 this 指针。因此静态成员函数不能访问本类中的非静态成员。静态成员函数就是专门为了访问静态数据成员的。静态成员函数不能被声明为 const。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"友元（friend）：如果在一个类以外的某个地方定义了一个函数，在类定义中用 friend 对其进行声明，此函数就称为这个类的友元函数。友元函数可以访问这个类中的私有成员。友元允许一个类将其非公有成员的访问权授予指定的函数或类。友元的声明只能出现在类定义的内部的任何地方，由于友元不是授予友元关系（friendship）的那个类的成员，所以它们不受访问控制的影响。通常，将友元声明放在类定义的开始或结尾。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"友元可以是普通的函数，或已定义的其他类的成员函数，或整个类。将一个函数设为友元，称为友元函数（friend function），将一个类设为友元，称为友元类（friend class）。友元类的所有成员函数都可以访问授予友元关系的那个类的非公有成员。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"因此，访问类非公有成员可以有两个用户：类成员和友元。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"友元成员函数：当友元函数是另一个类的成员函数时，称为友元成员函数","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"友元类：不仅可以将一个函数声明为友元，还可以将一个类 B 声明为另一个类 A 的友元，这个时候类 B 就是类 A 的友元类。友元类 B 中的所有成员函数都是 A 类的友元函数，可以访问 A 类中的所有成员。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的私有数据\n友元的关系不能传递或继承，如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。如果想让类 C 是类 A 的友元类，必须显式地在类 A 中另外声明。\n面向对象程序设计的一个基本原则是封装性和信息隐蔽，友元类突破了封装原则，可以访问其他类中的私有成员。友元的使用有助于数据共享，能提高程序的效率","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 类名 {\n    // ...\n    friend 友类名;\n};\nclass 类名 {\n    // ...\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"继承（inheritance）：在一个已存在的类的基础上建立一个新的类。已存在的类称为基类（base class），又称为父类，新建立的类称为派生类（derived class），又称为子类。一个新类从已有的类那里获得其特性，这种现象称为类的继承。继承是面向对象程序设计的一个重要特性，是软件复用（software reusability）的一种重要形式。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生：从已有的父类产生一个新的子类，称为类的派生。派生类继承了基类的所有数据成员和成员函数，具有基类的特性，派生类还可以对成员做必要的增加或调整，定义自己的新特性。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类函数重新写时加不加 override 的区别：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"一个基类可以派生出多个派生类，每一个派生类又可以作为基类再派生出新的派生类，因此基类和派生类是相对而言的。派生分为单机派生和多级派生。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"单一继承（single inheritance）：只从一个基类派生出的派生类。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"多重继承（multiple inheritance）：从两个及两个以上的基类派生。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 派生类别:类派生列表 {\n    // ...\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类派生列表（class derivation list）：指定了一个或多个基类（base class），具体形式 访问标号1 基类名1, 访问标号2 基类名2，访问标号表示继承方式可以是公有继承 public 、保护继承 protected、私有继承 private，继承方式决定了对继承成员的访问权限。如果未给出访问标号默认为私有继承。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"公有继承：基类的公有成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有\n私有继承：基类的公有成员和保护成员在派生类中变为私有成员，私有成员仍为基类私有\n保护继承：基类的公有成员和保护成员在派生类中变为保护成员，私有成员仍为基类私有","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"无论是什么样的继承方式，基类的私有成员对于派生类及其友元来说都是私有的，即无法访问。一般来说，保护继承和私有继承在实际编程中极少使用，它们只在技术理论上有意义","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"基类是对派生类的抽象，派生类是对基类的具体化。基类抽取了它与派生类的公共特征，而派生类通过增加信息将抽象的基类变为某种具体的类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类是基类的组合，可以把多重继承看作是多个单一继承的简单组合。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"继承允许在原有类的基础上创建新的类，新类可以从一个或多个原有类中继承数据成员和成员函数，并且可以重新定义或增加新的成员，从而形成类的层次。继承具有传递性，不仅支持系统的可重用性，而且还促进系统的可扩充性。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"继承避免了类对象中数据、函数的大量重复，克服了程序无法重复使用的缺点。通过继承，可以吸收现有类的数据和函数来创建新类，并增添新的成员增强此类，这样可以节约程序开发的时间。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"友元关系不能继承。\n如果基类定义了静态成员，则整个继承层次中只有一个这样的成员。无论从基类派生出多少个派生类，每个静态成员只有一个实例。\n静态成员遵循常规访问控制：如果静态成员在基类中为私有的，则派生类不能访问它。如果该静态成员在基类是公有的，则基类可以访问它，派生类也可以访问它。\n可以使用作用域运算符 ::、对象成员引用运算符 .、指针成员引用运算符 -> 访问静态成员","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"设计一个派生类包括 4 个方面的工作：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"从基类接受成员：除了构造函数和析构函数，会把基类全部的成员继承过来。\n调整基类成员的访问：派生类接收基类成员是程序员不能选择的，但是程序员可以对这些成员做出策略\n修改基类成员：可以在派生类中声明一个与基类成员同名的成员，则派生类中的新成员会覆盖基类的同名成员，就实现了修改基类成员功能的效果\n在定义派生类时增加新的成员：一般还应该自己定义派生类的构造函数和析构函数","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在继承之下，派生类有三种类型的访问者：类成员、类用户、派生类成员。派生类通常需要访问（一般为私有的）基类成员，为了允许这种访问而仍然禁止外部对基类的一般访问，可以使用 protected 访问标号。类的 protected 部分仍然不能够被类用户访问，但可以被派生类访问。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"只有基类类成员及其友元可以访问基类的 private 部分，派生类不能访问基类的私有成员。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对基类成员和派生类自身的成员按照不同的原则需要考虑 6 中形式：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"基类的成员和友元访问基类成员\n派生类的成员和友元访问派生类自己新增的成员\n基类的类成员和友元可以访问基类成员，派生类的类成员和友元可以访问派生新增的类成员。\n私有成员只能被同一类中的类成员访问，公有成员可以被类用户访问。\n基类的成员访问派生类新增的成员：基类的成员能不能直接访问派生类的成员（有基类不一定有派生类），但可以通过虚函数间接访问派生类的成员\n类用户访问派生类的成员：类用户可以访问派生类的公有成员，不能访问派生类任何私有的或保护的成员\n派生类新增的成员访问基类的类成员\n类用户访问派生类的基类成员\n内部访问：由派生类中新增成员对基类继承来的成员的访问\n对象访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"赋值兼容规则：在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能够解决的问题，公有派生类都可以解决。赋值兼容规则中所指的替代包括：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类的对象可以赋值给基类对象\n派生类的对象可以初始化基类的引用\n派生类对象的地址可以赋值给指向基类的指针","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义派生类时，派生类没有把基类的构造函数和析构函数继承下来，对继承的基类成员初始化的工作要由派生类的构造函数承担，同时基类的析构函数也要被派生类的析构函数来调用","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类构造函数的定义：执行派生类的构造函数式，使派生类的数据成员和基类的数据成员同时都被初始化。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类名(形式参数列表): 基类名(基类构造函数实参列表), 派生类初始化列表 {\n    派生类初始化函数体\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"基类名(基类构造函数实参列表) 即是调用基类构造函数，而派生类新增加的数据成员可以在 派生类初始化列表 初始化，也可以在派生类初始化函数体中初始化。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类构造函数的调用顺序：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"调用基类构造函数\n执行派生类初始化列表\n执行派生类初始化函数体","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"组合关系的派生类的构造函数：假定派生类 A 和类 B 的关系是组合关系，即类 A 中有类 B 的子对象。如果类 B 有默认构造函数，或者参数全是默认参数的构造函数，或者有无参数的构造函数，那么类 A 的构造函数可以不用显式初始化于对象。编译器总是会自动调用 B 的构造函数进行初始化。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以在一个类的构造函数中显式地初始化其子对象，初始化式只能在构造函数初始化列表中，形式为：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类名(形式参数列表): 子对象名(子对象构造函数实参列表), 类初始化列表 {\n    类初始化函数体\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"调用顺序：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"调用基类构造函数\n调用子对象构造函数，各子对象时按其声明的次序先后调用\n执行派生类初始化列表\n执行派生类初始化函数体","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"多重继承派生：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 派生类别: 访问标号1 基类名1, 访问标号2 基类名2, ... {\n    成员列表\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"多重继承派生类的构造函数：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"调用基类构造函数，各个基类按定义时的次序先后调用\n调用子对象构造函数，各个子对象按声明时的次序先后调用\n执行派生类初始化列表\n执行派生类初始化函数体","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类名(形式参数列表): 基类名1(基类1构造函数实参列表),\n\t\t\t\t    基类名2(基类2构造函数实参列表),\n\t\t\t\t\t...,\n\t\t\t\t\t子对象名1(子对象1属类构造函数实参列表),\n\t\t\t\t\t...,\n\t\t\t\t\t派生类初始化列表\n                    {\n                        派生类初始化函数体\n                    }","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"二义性问题：多重继承时，多个基类可能出现同名的成员，在派生类中如果使用一个表达式的含义能解释为访问多个基类成员，则这种对基类成员的访问就是不确定的，称这种访问具有二义性。C++ 要求派生类对基类成员的访问必须是无二义性的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"名字支配规则：如果存在两个或多个具有包含关系的作用域，外层声明了一个名字，而内层没有再次声明相同的名字，那么外层名字在内层可见；如果在内层声明了相同的名字，则外层名字在内层不可见，这时称内层名字隐藏（或覆盖）了外层名字，这种现象称为隐藏规则。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虚基类（virtual base class）：在派生类定义时，指定继承方式时声明，使得在继承间接共同基类时只保留一份成员。为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 派生类名: virtual 访问标号 虚基类名, ... {\n    成员列表\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虚基类的初始化：如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在其所有派生类（包括直接派生和间接派生）中，都要通过构造函数的初始化表对虚基类进行初始化。在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"一个类可以在一个类族中既被用作虚基类，也被用作非虚基类\n派生类的构造函数的成员初始化列表中必须列出对虚基类构造函数的调用；如果未列出，则表示使用该虚基类的默认构造函数\n在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行","category":"page"},{"location":"lang/Cpp/#多态","page":"C++","title":"多态","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"多态：同样的消息被不同类型的对象接收时导致不同的行为。所谓消息是指对类成员函数的调用，不同的行为是指不同的实现，也就是调用了不同的函数。多态性是指一段程序能够处理多种类型对象的能力。在 C++ 中，这种多态性可以通过重载多态（函数和运算符重载）、强制多态（类型强制转换）、类型参数化多态（模板）、包含多态（继承及虚函数）四种形式来实现。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"重载是多态性的最简单形式，分为函数重载和运算符重载。重定义已有的函数称为函数重载。在 C++ 中既允许重载一般函数，也允许重载类的成员函数。如对构造函数进行重载定义，可使程序有几种不同的途径对类对象进行初始化。C++ 允许为类重定义已有运算符的语义，使系统预定义的运算符可操作于类对象。如流插入 << 运算符和流提取 >> 运算符。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"强制多态：也称类型转换。如 C++ 定义了基本数据类型之间的转换规则。即 char => short => int => unsigned => long => unsigned => long => float => double => long double。同时，可以在表达式中使用 3 中强制类型转换表达式：（1）static_cast<T>(E)；（2）T(E)；（3）(T)E，其中 E 代表运算表达式，T 代表一个类型表达式。上述任意一种都可改变编译器所使用的规则，以便按自己的意愿进行所需的类型强制。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类型参数化多态：将类型作为函数或类的参数，避免了为各种不同的数据类型编写不同的函数或类，减轻了设计者负担，提高了程序设计的灵活性。模板是 C++ 实现参数化多态性的工具，分为函数模板和类模板。类模板中的成员函数均为函数模板，因此函数模板是为类模板服务的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"联编（binding）：又称绑定，就是将模块或者函数合并在一起生成可执行代码的处理过程。同时对每个模块或者函数分配内存地址，并且对外部访问也分配正确的内存地址。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在编译阶段就将函数实现和函数调用绑定起来称为静态联编（static binding）。静态联编在编一阶段就必须了解所有的函数或模块执行所需要的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型。C 语言中，所有的联编都是静态联编，C++ 中一般情况下联编也是静态联编。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"动态联编（dynamic binding）：在程序运行的时候才进行函数实现和函数调用的绑定。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当编译器含有虚函数的类时，将为它建立一个虚函数表 VTABLE（virtual table），它相当于一个指针数组，存放每个虚函数的入口地址。编译器为该类增加一个额外的数据成员，这个数据成员是一个指向虚函数表的指针，通常称为 vptr。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当调用虚函数时，先通过 vptr 找到虚函数表，然后再找出虚函数的真正地址，再调用它。派生类能继承基类的虚函数表，而且只要是和基类同名（参数也相同）的成员函数，无论是否使用 virtual 声明，它们都自动成为虚函数。如果派生类没有改写继承基类的虚函数，则函数指针调用基类的虚函数。如果派生类改写了基类的虚函数，编译器将重新为派生类的奇函数建立地址，函数指针会调用改写以后的虚函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虚函数的调用规则：根据当前对象，有限调用对象本身的虚成员函数。这和名字支配规则类似，不过虚函数时动态联编的，是在运行时（通过虚函数表中的函数地址）「间接」调用实际上欲联编的函数。","category":"page"},{"location":"lang/Cpp/#虚函数","page":"C++","title":"虚函数","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虚函数：用 virtual 关键字修饰的成员函数。作用是实现多态性，以共同的方法，对不同的对象采取不同的策略","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"class 类名 {\n    virtual 返回类型 函数名(形式参数列表);\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"virtual 只在类体中使用。当在派生类中定义了一个同名的成员函数时，只要该成员函数的参数个数、参数类型以及返回类型与基类中同名的虚函数完全一样，则派生类的这个成员函数无论是否使用 virtual，它都将成为一个虚函数。程序员习惯给派生类的同名函数也加上 virtual 便于阅读理解。利用虚函数，可在基类和派生类中使用相同的函数名定义函数的不同实现，从而实现「一个接口，多种方式」。当用基类指针或引用对虚函数进行访问时，系统将根据运行时指针或引用所指向或引用的实际对象来确定调用对象所在类的虚函数版本。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"关键字 virtual 指示 C++ 编译器在调用虚函数时进行动态联编。这种多态性是程序运行到相应的语句时才动态确定的，所以称为运行时的多态性。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"不过，使用虚函数并不一定产生多态性，也不一定使用动态联编。例如，在调用中对虚函数使用成员名限定，可以强制 C++ 对该函数的调用使用静态联编。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"不要在构造函数与析构函数中调用虚函数。派生类对象在创建时，首先基类部分先被创建，如果在基类创建构造函数调用虚函数时，将无法调用派生类版本的函数，因为此时派生类还未创建。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"大部分时候希望派生类是真正「重写」基类的函数，而不是「隐藏」，一般建议将所有方法都生命为 virtual，只是因为虚函数相对于普通函数来说调用代价更高，但是差别不会太大，在 Java 中所有的方法默认都是虚函数，而在 C++ 中则不是。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虚函数实现多态的条件：必须同时满足一下三条才能报纸实现动态联编","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类之间的继承关系满足赋值兼容性规则\n改写了同名的虚函数\n根据赋值兼容性规则使用指针（或引用）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在派生类中，当一个指向基类成员函数的指针指向一个虚函数，并且通过指向对象的基类指针（或引用）访问这个虚函数时，仍将发生多态性。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"何时需要虚函数？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"首先看成员函数所在的类是否会作为基类，然后看成员函数在类的继承后有无可能被更改功能，如果希望派生类更改其功能的，一般应该将它声明为虚函数\n后如果成员函数在类被继承后功能不需要修改，或派生类用不到该函数，则不要把它声明为虚函数。\n如果成员函数的调用是通过基类指针或引用去访问的，则应当声明为虚函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"使用虚函数，系统要增加一定的空间开销用来存储虚函数表，但系统在进行动态联编时的时间开销是很少的，因此多态性是高效的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"派生类的对象从内存中撤销时一般先调用派生类的析构函数，然后再调用基类的析构函数。但是，如果使用 new 运算符建立了派生类对象，且定义了一个基类的指针指向这个对象，那么当用 delete 运算符撤销对象时，系统会只执行基类的析构函数，而不执行派生类的析构函数，因而也无法对派生类对象进行真正的撤销清理操作。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"虚析构函数：如果基类指针指向派生类，在对这个指针执行 delete 的时候可以执行派生类的析构函数，那么基类的析构函数要声明为虚函数，称为虚析构函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"如果将基类的析构函数声明为虚函数，由该基类所派生的所有派生类的析构函数也都自动称为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当基类的析构函数为虚函数时，无论指针指的是同一类族中的哪一个类对象，系统总会采用动态联编。调用正确的析构函数，对该对象进行清理。C++ 支持虚析构函数，但不支持虚构造函数，即构造函数不能声明为虚函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"纯虚函数（pure virtual function）：在许多情况下，不能在基类中为虚函数给出一个有意义的定义，这时可以将它说明为纯虚函数，将具体定义留给派生类去做。virtual 返回类型 函数名(形式参数列表) = 0; 在虚函数的原型声明后加上 = 0 表示纯虚函数根本就没有函数体。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"纯虚函数的作用是在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。如果在一个类中声明了纯虚函数，而在其派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"抽象类（abstract class）：包含有纯虚函数的类称为抽象类。一个抽象类只能作为基类来派生新类，所以又称抽象基类（abstract base class）。抽象类不能定义对象。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"如果在派生类中给出了抽象类的纯虚函数的实现，则该派生类不再是抽象类。否则只要派生类仍然有纯虚函数，则派生类依然是抽象类。抽象类至少含有一个虚函数，而且至少有一个虚函数是纯虚函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"运算符重载：对现有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。其本质上就是函数的重载，运算符属于名字特殊的函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"除了 .、 .*、::、?:、sizeof 之外，绝大多数运算符可以重载\n不能改变运算符的优先级、结合型和运算对象数目\n运算符重载函数不能使用默认参数\n重载函数必须具有一个类对象（或类对象的引用）的参数，不能全部是 C++ 的内置数据类型\n一般若运算结果作为左值则返回类型为引用类型；若运算结果要作为右值，则返回对象\n重载运算符的功能应该与原来的功能一致","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 operator 运算符号(形式参数列表) {\n    函数体\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当运算符重载为成员函数时，运算符函数的形式参数的个数比运算符规定的运算对象个数要少一个。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"原因是类的非静态成员函数都有一个隐含的 this 指针，运算符函数可以用 this 指针隐式地访问类对象的成员，因此这个对象自身的数据可以直接访问，不需要放到形参列表中进行传递，少了的运算对象就是该对象本身。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"双目运算符重载为类的成员函数：重载之后表达式 obj1 op obj2 相当于 obj1.operator op(obgj2)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 类名::operator op(const 所属类型 &obj2) {\n    // ...   // this 指针对应 obj1 运算对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"前置单目运算符重载为类的成员函数：重载之后表达式 op obj 相当于 obj.operator op()","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 类名::operator op() {\n    ...  // this 指针对应 obj 运算对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"后置单目运算符重载为类的成员函数：重载之后表达式 obj op 相当于 obj.operator op(0)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 类名::operator op(int) {\n    ...  // this 指针对应 obj 运算对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"当运算符重载为友元函数时，运算符函数的形式参数的个数和运算符规定的运算对象个数一致。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"双目运算符重载为类的友元函数：重载之后表达式 obj1 op obj2 相当于 operator op(obj1, obj2)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 operator op(const 所属类型 &obj1, const 所属类型 &obj1) {\n    ...  // obj1 和 obj2 分别对应两个运算对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"前置单目运算符重载为类的友元函数：重载之后表达式 op obj2 相当于 operator op(obj)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 operator op(const 所属类型 &obj) {\n    ...  // obj 对应运算对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"后置单目运算符重载为类的友元函数：重载之后表达式 obj op 相当于 operator op(obj, 0)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"返回类型 operator op(const 所属类型 &obj, int) {\n    ...  // obj 对应运算对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"重载复合的赋值运算符：复合的赋值运算符具有「给运算对象重新赋值」的功能，所以运算符函数需要返回引用类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"重载流运算符：用户自定义数据类型的数据，是不能直接用 << 和 >> 来进行输入输出的，如果想使用它们输入输出自定义数据类型的数据，就必须对它们进行重载。对 << 和 >> 重载的函数是由标准库 iostream 规定的","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ostream& operator <<(ostream& os, const 类类型 &obj) {\n    os << ...;  // obj 数据成员逐个输出\n    return os;  // 必须返回 ostream 对象\n}\n\nistream& operator >>(istream& is, 类类型 &obj) {\n    is >> ...;  // 逐个输入 obj 数据成员\n    return is;  // 必须返回 istream 对象\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"无论流插入还是流提取都需要连续输入或输出，如 cout << a << b << c; 因此运算对象应该能作为左值。流插入和提取重载函数不能是类的成员函数，否则左运算对象就只能是该类型的对象，就会出现如下的错误形式：a << cout 或者 a >> cin。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"如果想要支持正常的形式，则左运算对象就必须为 ostream 类型或 istream 类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"重载类型装换运算符：C++ 对基本数据类型既有隐式类型转换，又有显示类型转换，我们可以通过构造单个参数的构造函数将指定数据类型隐式转换为类类型，如果要将类类型显式地转换为其他数据类型，就需要重载类型转换运算符。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类型转换运算符函数只能作为类的成员函数，因为转换的运算对象是类的对象。","category":"page"},{"location":"lang/Cpp/#模板-and-泛型编程","page":"C++","title":"模板 & 泛型编程","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类模板：可以想定义函数模板一样，去定义类模板。以关键字 template 开头，后接模板形参表，用一对尖括号 <> 括住的一个或多个模板形参的列表，不允许为空，形参之间以逗号分隔。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// template <模板形参表>\ntemplate <class 类型参数1, class 类型参数2, ...>\nclass 类模板名 {\n    成员列表\n};","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"模板形参表用于表示可以在类定义中使用的数据类型。类型形参跟在关键字 class 或 typename 之后定义，如 class T 是名为 T 的类型形参，在这里 class 和 typename 没有区别。一般，类模板习惯用 class，函数模板习惯用 typename","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"除了模板形参列表外，类模板的定义与类定义相似。类模板可以定义数据成员和函数成员，也可以使用访问标号控制对成员的访问，还可以定义构造函数和析构函数等等。在类和类成员的定义中，可以使用模板形参作为类型或值的占位符，在使用类时再提供那些类型或值的具体信息。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"由于类模板包含类型参数，因此又称参数化的类。如果说类是对象的抽象，对象是类的实例，则类模板是类的抽象，类是类模板的实例。利用类模板可以建立支持各种数据类型的类。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"如果在类模板外部定义成员函数","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"template <模板形参表>\n返回类型 类名<类型参数表>::函数名(形式参数列表) {\n    函数体\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"用类模板定义对象时，必须为模板形参显式指定类型实参","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类模板名<类型实参表> 对象名列表;\n类模板名<类型实参表> 对象名1(实参列表1), 对象名2(实参列表2), ...;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"模板形参可以设置默认值","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"关键字 export：作用与 extern 相似，函数模板或类模板的实例化与定义体可以不必放在同一个编译单元。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类模板在表示数组、向量、列表、队列、栈、矩阵等数据结构时，显得特别重要，因为这些数据结构的表示和算法的选择不受其所包含的元素的类型的影响","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"泛型（generic）：一种允许一个数据取不同类型的技术，与操作对象数据类型独立的算法称为泛型算法，独立于任何特定类型的编程方法称为泛型编程。模板是泛型编程的基础，泛型编程关注于产生通用的软件组件，让这些组件在不同的应用场合都能很容易地重用。在 C++ 中，类模板和函数模板是进行泛型编程极为有效的机制。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"泛型编程：面向过程 PO（procedure oriented）、面向对象 OO（object oriented）、泛型编程 GP（generic programming）是三种重用的编程方法","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"早期的 C++ 语言泛型编程思想仅仅体现于简单的模板技术，之后的标准模板库 STL（standard template library）是泛型编程思想的实际体现和具体实现。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 标准库的内容分为：C1 语言支持、C2 输入/输出、C3 诊断功能、C4 通用工具、C5 字符串、C6 容器、C7 迭代器、C8 算法、C9 数值操作、C10 本地化","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 标准库中所有的头文件都没有扩展名（.h），内容总共在 51 个标准头文件中定义，其中 18 个 <cname> 形式的头文件（<complex> 除外）内容与标准 C 语言的 name.h 头文件相同，但包含了 C++ 扩展的功能。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在 <cname> 形式的头文件中，与宏相关的名称在全局作用域中定义，其他名称在 std 命名空间中声明。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"另外，在 C++ 中还可以使用 name.h 形式的 C 语言头文件，但不建议这样用。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ 标准库由三组库构成：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C 库：由 C 标准库扩展而来，强调结构、函数和过程，不支持面向对象技术\nC++ 库：增加了面向对象的库，包含了具有关键功能的类\n标准模板库（STL）：高效的 C++ 程序库，该库包含了诸多在计算机科学领域里所常用的基本数据结构的基本算法","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"以上库文件都被定义在 namespace std 中，C++ 库可以不规定头文件的扩展名","category":"page"},{"location":"lang/Cpp/#字符串流","page":"C++","title":"字符串流","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字符串流是以内存中的 string 对象或字符数组（C 风格字符串）为输入输出的对象，将数据输出到内存中的字符串存储区域，或者从字符串存储区域读入数据。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字符串流的作用是利用输入输出操作方法将各种类型的数据转换成字符序列，或者相反。字符串流是程序数据与设备进行数据交换重要的桥梁。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字符串流类有 istringstream、ostringstream、stringstream 和 istrstream、ostrstream、strstream 两种。前一种以 C++ string 串对象作为字符串，定义在头文件 <sstream> 中；后一种以字符数组作为字符串（即 C 风格字符串），定义在头文件 <strstream> 中。根据 C++ 标准的定义，strstream 是过时的，未来版本的 C++ 标准可能不再支持 strstream。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"使用字符串流类的方法是建立字符串流对象，通过构造函数或成员函数 str() 与某个字符串关联，此后对字符串流对象按输入输出形式进行操作。字符串流类的构造函数和常用成员函数原型如下","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"istringstream(openmode which=ios_base::in);  // 构造字符串输入流对象\n// 构造字符串输入流对象，并初始化为 str 的内容\nistringstream(const string& str, openmode which=ios_base::in);\nostringstream(openmode which=ios_base::out);  // 构造字符串输出流对象\n// 构造字符串输出流对象，并初始化为 str 的内容\nostringstream(const strin& str, openmode which=ios_base::out);\n// 构造字符串输入输出流对象\nstringstream(openmode which=ios_base::out | ios_base::in);  // 构造字符串输入输出流对象，并初始化为 str 的内容\nstringstream(const string& str, openmode which=ios_base::out | ios_base::in);\nstring str();  // 返回当前字符串流缓冲区关联的字符串对象的副本\nvoid str(const string& s);  // 复制字符串 s 的内容到字符串流缓冲区关联的 string 对象中","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ostringstream 对象用来进行格式化的输出，可以将各种类型转换为 string 类型，只支持 << 操作符","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ostringstream oss;\noss << 1.234;  // double 型转化为字符串\noss << \" \";  // 字符串常量转化为字符串\noss << endl;\ncout << oss.str();\noss.str(\"\");  // 清空","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"istringstream 对象用来把一个已定义字符串中的以空格隔开的内容提取出来，只支持 >> 操作符","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"int a;\nstring str1;\nstring input = \"abd 123 def 456 ghi 789\";\nistringstream iss(input);  // \t通过构造函数对 iss 进行赋值\nwhile (iss >> str1 >> a) {\n    cout << str1 << \" \" << a << endl;\n}\n/* 运行结果\nabd 123\ndef 456\nghi 789\n*/","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"stringstream 类是 istringstream 和 ostringstream 类的综合，支持 << 和 >> 操作符","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"int a;\nstring str1;\nstring input = \"abd 123 def 456 ghi 789\";\nstringstream ss;\nss << input;\nwhile (ss >> str1 >> a) {\n    cout << str1 << \" \" << a << endl;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"流：C++ 的输入输出是以字节流的形式实现的。流是指由若干字节组成的字节序列的数据从一个对象传递到另一个对象的操作。从流中读取数据称为提取操作，向流内添加数据称为插入操作。流在使用前要建立，使用后要删除。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"流的方向性：与输入设备相联系的流称为输入流，与输出设备相联系的流称为输出流，与输入输出设备相联系的流称为输入输出流。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在 istream 类中已经将运算符 >> 重载为提取运算符，支持基本数据类型及其指针类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在 ostream 类中已经将运算符 << 重载为插入运算符，其适用类型除了前述类型外，还增加了 void* 类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"预定义流对象：标准库将常用 iostream 类的流对象，定义在 <iostream> 头文件中：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"cin：与标准输入设备相关联的标准输入流（istream 对象）\ncout：与标准输出设备相关联的标准输出流（ostream 对象）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件：是指存放在磁盘上数据的集合。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件按数据的组织形式可以分为两类：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ASCII 文本文件：文本（text）文件对于 ASCII 字符集而言，文件中每个字节存放的是一个 ASCII 码，表示一个字符；对于像汉子、日韩文字等字符集而言，使用双字节存放字符\n二进制文件：二进制文件是将数据以内存中的存储形式直接存放到磁盘上。用二进制形式输出数据，可以节省存储空间和避免编码转换。由于一个字节并不对应一个字符，所以不能直接打印输出或编辑二进制文件。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件打开：已创建的文件流对象需要和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件，这个过程称为文件打开。打开文件的两种方式：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义文件流对象时使用带参数的构造函数\n调用文件流成员函数 open","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ifstream();  // 文件输入流构造函数\n// 文件输入流构造函数，用指定的 mode 方式打开 filename 文件\nifstream(const char* filename, ios_base::openmode mode=ios_base::in);\nofstream();  // 文件输出流构造函数\n// 文件输出流构造函数，用指定的 mode 方式打开 filename 文件\nofstream(const char* filename, ios_base::openmode mode=ios_base::out);\nfstream();  // 文件输入输出流构造函数\n// 文件输入输出流构造函数，用指定的 mode 方式打开 filename 文件\nfstream(const char* filename. ios_base::openmode mode=ios_base::in | ios_base::out);\n// 用指定的 mode 方式打开 filename 文件\nvoid open(const char* filename, ios_base::openmode mode=ios_base::in);\nbool operator!();  // 检测流对象是否为空\nbool is_open();  // 检测文件是否打开","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"打开方式 openmode 的不同取值：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ios_base::in：input，以输入方式打开文件（默认方式）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ios_base::out：output，以输出方式打开文件。若以存在该文件，则将其内容全部清空","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ios_base::app：append，以输出方式打开文件，写入的数据添加在文件末尾","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ios_base::ate：at end，打开一个已有的文件，文件指针指向文件末尾","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ios_base::binary：binary，二进制文件，默认为 ASCII 文件","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ios_base::trunc：truncate，打开一个文件，若文件已存在，则将其内容全部清空；若文件不存在，则建立新文件。若指定了 ios::out 方式而未指定 ios::app、ios::ate、ios::in 时，默认为此方式","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"可以用位或运算 | 对 openmode 进行组合\n打开文件时操作可能会失败，如果打开操作失败，open 函数返回值为 0（假）。如果是调用构造函数打开文件且打开操作失败，则流对象的值为 0（空对象）。可以据此测试打开是否成功，确定能否对该文件继续操作。\n每个打开的文件都有一个文件指针，该指针初始位置要么在文件末尾（当指定 ios_base::app 或 ios_base::ate 时），要么在文件开头。每次读写都从文件指针的当前位置开始，每读写一个字节，指针就自动后移一个字节，当文件指针移到最后，就会越到文件结束 EOF（文件结束符）","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件关闭：当不再使用文件时，应该关闭该文件。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"void close();  // 关闭文件","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件状态：文件流提供如下四个成员函数用来检测文件状态：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"bool eof();  // 如果文件已到末尾，返回 1（真），否则返回 0（假）\nbool bad();  // 读写文件过程中出错返回 true\n// 如果对一个不是为写状态打开的文件进行写入，或者要写入的设备没有剩余空间。\n// 除了与 bad 函数同样的情况下会返回 true 以外，格式错误时 fail 函数也会返回 true\nbool fail();  \nbool good();  // 如果调用以上任何函数返回 true 的话，good 函数发挥 false","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"文件操作的基本形式","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ifstream infile(filename, openmode);  // 打开或创建文件\nif (!infile) {  // 打开或创建成功继续操作\n    ...;  // 文件读写操作\n    infile.close();  // 处理结束时关闭文件\n}\n\nifstream infile;\ninfile.open(filename, openmode);  // 打开文件或创建文件\nif (!infile.fail()) {  // 打开或创建成功继续操作\n    ...;  // 文件读写操作\n    infile.close();  // 处理结束时关闭文件\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"除流提取和流插入运算符外，文件流还有如下有用的操作文件的成员函数","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// 用于文件输入流\nistream& read(char* s, streamsiez, n);  // 从文件中读 n 个字节到 s\nstreampos tellg();  // 返回文件指针的位置\nistream& seekg(streampos pos);  // 移动文件指针到 pos 位置\nistream& seekg(streamoff off, ios_base::seekdir dir);  // 以 dir 参照 off 偏移移动文件指针\n// 用于文件输出流\nostream& write(const char* s, streamsize n);  // 输出 s 的 n 个字节到文件\nstreampos tellp();  // 返回文件指针的位置\nostream& seekp(streampos pos);  // 移动文件指针到 pos 位置\nostream& seekp(streamoff off, ios_base::seekdir dir);  // 以 dir 参照 off 偏移移动文件指针\nflush();  // 文件输出流刷新","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对 ASCII 文件操作可以用以下两种方法：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"用流插入 << 运算符和流提取 >> 运算符输入输出标准类型的数据\n用流对象成员函数 get、getline、put 等进行字符的输入输出","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对二进制文件操作：打开时要用 ios_base::binary 指定为以二进制形式读取和存储。二进制文件除了可以作为输入文件或输出文件外，还可以是既能输入又能输出的文件。对二进制文件的读写操作主要使用成员函数 read 和 write。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"随机访问二进制文件：对二进制文件来说，可以利用 seekg 或 seekp 成员函数移动文件指针，从而随机地访问文件中任意位置上的数据，还可以修改文件中的内容","category":"page"},{"location":"lang/Cpp/#向量（动态数组）","page":"C++","title":"向量（动态数组）","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"迭代器（iterator）：是一种允许检查容器内元素，并实现元素遍历的数据类型。迭代器提供了比下标操作更为一般化的方法：所有的标准库容器都定义了相应的迭代器类型，只有少数容器支持下标操作。因为迭代器对所有的容器都适用，现代 C++ 程序更倾向于适用迭代器而不是下标操作访问容器元素","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"向量（vector）：是 C++ 标准模板库中的内容，是一个容器，它能够存放各种类型的对象，简单地说，vector 是一个能够存放任意类型的动态数组，可以动态改变大小。使用向量，需要在程序中添加 <vector> 头文件。向量类似数组，但是它的元素个数是可以随时动态改变的。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"向量类成员函数原型如下：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// 定义动态数组\n// int 可以为 string、double 等\nvector<int> a;  // 定义一维动态数组\nvector<int*> a;  // 定义二维动态数组\nvector<int**> a;  // 定义三维动态数组\n\n// 迭代器 iterators\n// 返回一个顺序迭代器\niterator begin();  // 返回向量第 1 个元素为迭代器起始\niterator end();  // 返回向量末尾元素为迭代器结束\n\n// 返回一个逆序迭代器\nreverse_iterator rbegin();  // 返回向量末尾元素为逆向迭代器起始\nreverse_iterator rend();  // 返回向量第 1 个元素为逆向迭代器结束\n\n// 容量 capacity\nsize_type size();  // 返回向量元素数目\nsize_type max_size();  // 返回向量能容纳的最大元素数目（长度）\nvoid resize(sieez_type sz, T c=T());  // 重置向量长度为 sz，c 填充到扩充元素中\nsize_type capacity();  // 返回向量容器存储空间大小\nbool empty();  // 测试向量是否为空\nvoid reserve(size_type n);  // 为向量申请能容纳 n 个元素的空间\n\n// 元素存储 element access\noperator [](size_type n);  // 返回向量第 n 个元素的位运算符，n 从 0 算起\nat(size_type n);  // 返回向量第 n 个元素位置，n 从 0 算起\nfront();  // 返回向量第 1 个元素的引用\nback();  // 返回向量末尾元素\n\n// 向量调节器 modifiers\nvoid assign(size_type n, const T& u);  // 向量赋 n 个 u 值\nvoid push_back(const T& x);  // 增加一个元素到向量末尾\nvoid pop_back();  // 删除向量末尾元素\n\n// 在向量 pos 处插入 n 个元素值 x，pos 从 1 算起\nvoid insert(iterator pos, size_type n, const T& x);\niterator erase(iterator pos);  // 删除向量指定位置的元素，pos 从 1 算起\nvoid swap(vector<T, Allocator>& vec);  // 与向量 vec 互换元素\nvoid clear();  // 清空向量","category":"page"},{"location":"lang/Cpp/#列表","page":"C++","title":"列表","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"列表（list）：是一个双向链表，它的内存空间是可以不连续的，通过指针来进行数据的访问，这使得 list 的随机访问效率比较低，因此 list 没有提供 [] 运算符的重载。但 list 可以很好的支持任意地方的插入和删除操作，只需要移动指针即可。列表定义在 <list> 头文件中。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"列表类成员函数原型如下：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// 迭代器 iterators\niterator begin();  // 返回表头元素为迭代器起始\niterator end();  // 返回表尾元素为迭代器结束\nreverse_iterator rbegin();  // 返回表尾元素为逆向迭代器起始\nreverse_iterator rend();  // 返回表头元素为逆向迭代器结束\n\n// 容量 capacity\nbool empty();  // 测试是否为空集\nsize_type size();  // 返回列表长度\nsize_type max_size();  // 返回列表能容纳的最大长度\nvoid resize(size_type sz, T c=T());  // 重置列表长度为 sz，c 填充到扩充元素中\n\n// 元素存储 element access\nfront();  // 返回表头元素\nback();  // 返回表尾元素\n\n// 列表调节器 modifiers\nvoid assign(size_type n, const T& u);  // 列表赋 n 个 u 值\nvoid push_front(const T& x);  // 插入一个元素到表头\nvoid pop_front();  // 删除表头元素\nvoid push_back(const T& x);  // 增加一个元素到表尾\nvoid pop_back();  // 删除表尾元素\n\n// 在列表 pop 处插入 n 个元素值 x，pos 从 1 算起\nvoid insert(iterator pos, size_type n, const T& x);\niterator erase(iterator pos);  // 删除列表指定位置的元素，pos 从 1 算起\nvoid swap(list<T, Allocator>& lst);  // 与列表 lst 互换元素\nvoid clear();  // 清空列表\n\n// 列表运算 operations\nvoid remove(const T& value);  // 删除列表中值与 value 相同的所有元素\nvoid remove_if(Predicate pred);  // 删除列表满足条件的元素\nvoid unique();  // 删除列表重复值\nvoid merge(list<T, Allocator>& x);  // 合并列表 x，列表必须有序\nvoid sort();  // 列表排序\nvoid sort(Compare comp);  // 列表按 comp 关系比较排序\nvoid reverse();  // 列表逆序","category":"page"},{"location":"lang/Cpp/#队列","page":"C++","title":"队列","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"队列（queue）：一种先进先出 FIFO（first in first out）的线性表。它只允许在表的一端进行插入元素，而在另一端删除元素，最早进入队列的元素最早离开。在队列中，插入的一端称为队尾（back），删除的一端称为对头（front）。队列定义在 <queue> 头文件中。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"队列类成员函数原型如下：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"queue<int> q;\n\n// 容量 capacity\nbool empty();  // 测试是否为空队列\nsize_type size();  // 返回队列长度\n\n// 元素存取 element access\nfront();  // 返回队头元素\nback();  // 返回队尾元素\n\n// 队列运算 operations\nvoid push(const T& x);  // 插入一个元素到队尾\nvoid pop();  // 删除队列下一个元素，不会返回弹出的元素","category":"page"},{"location":"lang/Cpp/#栈","page":"C++","title":"栈","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"要注意区别在系统内存中的堆和栈，以及数据结构中的堆和栈的区别。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"栈（stack）：是后进先出 LIFO（last in first out）的线性表。因此，对栈来说表尾有其特殊含义，称为栈顶（top），相应地，表头称为栈底（bottom），不含元素的空表称为空栈。栈定义在 <stack> 头文件中","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"栈类成员函数原型如下：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// 定义 stack 的语法 stack<T> s;\nstack<int> s;  // int 可以为 string, double 等\n\n// 容量 capacity\nbool empty();  // 测试是否为空栈\nsize_type size();  // 返回栈长度\n\n// 栈运算 operations\nvoid push(const T& x);  // 进栈\nvoid pop();  // 出栈，不会返回出栈的元素\ntop();  // 返回栈顶元素","category":"page"},{"location":"lang/Cpp/#集合","page":"C++","title":"集合","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"集合（Set）类似于数学上的集合，每个元素只能出现一次。集合会自动排序。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"set<int> s;\n\nbegin();  // 返回一个迭代器，指向第一个元素\nend();  // 返回一个迭代器，指向最后一个元素的下一个位置\nclear();  // 清空 Set 的所有元素\nempty();  // 判断是否为空\nsize();  // 返回当前元素个数\nerase(it);  // 删除迭代器指针 it 指向的元素\ninsert(a);  // 插入元素 a\ncount();  // 查找某个元素出现的次数，只有可能为 0 或 1\nfind();  // 查找某个元素出现的位置，如果找到则返回这个元素的迭代器，如果不存在，则返回 s.end()","category":"page"},{"location":"lang/Cpp/#哈希表","page":"C++","title":"哈希表","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"C++ STL 中哈希表对应的容器是 unordered_map，对应的数据结构是哈希表，查找的时间复杂度为 O(1)。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"map 对应的数据结构是红黑树，是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 O(log N)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"template<\n    class Key,\n    class T,\n    class Hash = std::hash<Key>,\n    class KeyEqual = std::equal_to<Key>,\n    class Allocator = std::allocator< std::pair<const Key, T> >\n> class unordered_map;\n\n// 成员函数\n// 迭代器 Iterators\nbegin();  // 返回一个迭代器，指向第一个元素\nend();  // 返回一个迭代器，指向最后一个元素\n\n// 容量 Capacity\nempty();  // 判断是否为空\nsize();  // 返回大小\n\n// Modifiers\nclear();  // 清除所有元素\ninsert(a);  // 插入元素 a\nemplace();  // \nerase();  // 移除某个元素\n\n// 查找 Lookup\nat();  // \nfind();  // 查找 key 对应的元素，如果不存在则返回末尾\nmap.find(key) == map.end();  // 通过这样来判断 key 是否存在\nsize_type count(const key_type& key) const;  // 用以统计 key 在 unordered_map 出现的次数，如果 key 存在返回 1；如果不存在返回 0\n","category":"page"},{"location":"lang/Cpp/#异常处理","page":"C++","title":"异常处理","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"异常是指程序运行时出现的不正常，程序运行过程中可能会出现下列异常：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"CPU 异常，在计算过程中，出现除数为 0 的情况\n内存异常：\n使用 new 或 malloc 申请动态内存但存储空间不够\n数组下标越界\n使用野指针、迷途指针读取内存\n设备异常：\n无法打开文件，或能够打开文件但文件有损坏，从而无法读取数据\n正在读取磁盘文件时挪动了文件或磁盘\n正在使用打印机但设备被断开\n正在使用的网络断线或阻塞\n用户数据异常：\nscanf 输入时数据格式或类型有错误\n正在处理的数据库有错误\n程序假定的数据环境发生变化","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"程序的健壮性：又称鲁棒性，是指程序对于规范要求以外的特殊情况的处理能力。鲁棒的程序对于规范操作以外的特殊情况能够有合理的处理方式。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"容错性：程序可以从错误的环境中推断出正确合理的内容。\n可移植性：程序可以正确地运行在不同环境下。\n正确性：程序能够检测自己内部的设计或者编码错误，并得到正确的执行结果。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在设计各种软件系统中，处理程序中的错误和其他反常行为是非常困难的。比如服务器上长期运行的网络服务程序将 80% 的代码用于实现错误检测和错误处理。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"异常处理的方法：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"终止模型：将假设错误非常关键，以至于程序无法返回异常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，程序不能继续执行\n恢复模型：异常处理程序的工作是修正错误，然后重新尝试调动出问题的过程","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"异常处理的机制：抛出异常（throw）、检查异常（try 块）、捕获异常（catch 块）。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"把需要检测的程序放到 try 块中，把异常处理的程序放到 catch 中，如果执行一个函数时出现异常，可以不在该函数中立即处理，而是抛出异常信息，传递给它的上一级函数（调用函数），它的上一级函数捕获到这个信息后再进行处理。如果上一级函数也不处理，就逐级向上传递。如果传递到了最高一级（如 main 函数）还不处理，就只能异常终止程序的执行。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"抛出异常：可以使用 throw 表达式抛出异常，将异常抛掷给主调函数去处理。异常通常以类似于实参传递给函数的方式（由 throw）抛出和（被 catch）捕获，throw 表达式的类型决定了所抛出的异常类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"throw 表达式;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"由于 C++ 是根据类型来区分不同的异常的，因此在抛出异常时，throw 表达式的值没有实际意义，而表达式的类型则非常重要。如果程序中有多处要抛出异常，应该用不同的表达式类型来相互区别。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"执行 throw 的时候，不会执行跟在 throw 后面的语句，而是将程序从 throw 转移到匹配的 catch，该 catch 可以是同一函数中的 catch，也可以在直接或间接调用发生异常函数的上一级函数中。\n被抛出的对象是一个用 throw 表达式初始化的「异常对象」。异常对象由 throw 创建，并初始化为被抛出的表达式副本。异常对象将传递给对应的 catch，并在异常处理完成后撤销。因此异常对象必须是可以复制的类型（具有复制构造函数）。\n如果抛出的是数组，被抛出的对象自动该转换为指向该数组首元素的指针，如果抛出的是一个函数，函数被转换为指向该函数的指针。\n如果抛出一个指针，该指针是一个指向派生类对象的基类指针，则那个对象将被分割，只抛出基类的部分\n抛出指向局部对象的指针总是错误的，因为抛出指针的时候，必须确保进入异常处理程序时指针所指的对象仍然存在。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"检测捕获异常：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"try {\n    ...;  // 检测程序块（可能抛出异常的代码）\n}\ncatch (异常说明符1) {\n    ...;  // 处理程序（当异常说明符1被抛出时执行的程序）\n}\ncatch (异常说明符2) {\n    ...;  // 处理程序（当异常说明符2被抛出时执行的程序）\n}\n...;  // 更多的 catch","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"一个 try 块可以紧跟一个或多个 catch 块。在 try 中执行程序块所抛出的异常，通常会被其中的一个 catch 子句处理，一旦 catch 子句执行结束，程序流程继续执行紧随最后一个 catch 子句后面的语句。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"catch 子句中的异常说明符是有一个形参的形参列表，有三种形式：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"catch(类型名)：只需要了解异常的类型\ncatch(类型名 形参名)：需要了解异常的类型之外的信息\ncatch(...)：捕获所有异常","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"异常处理的执行过程：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"程序流程到达 try 块，然后执行 try 块内的程序块。如果没有引起异常，那么跟在 try 块后的 catch 子句都不执行，程序从最后一个 catch 子句后面的语句继续执行下去\n抛出异常的时候，将暂停当前函数的执行，开始查找匹配的 catch 子句\n首先检查 throw 是否在 try 内部，如果是，检查 catch 子句，看是否其中之一与抛出对象相匹配。如果找到匹配的 catch，就处理异常；如果找不到，就推出当前函数并释放局部对象，然后继续在调用函数中查找。\n在调用函数中，检查与该 try 相关的 catch 子句。如果找到匹配的 catch，就处理异常；如果找不到，则推出调用函数，然后继续在调用这个函数的函数中查找\n沿着嵌套函数调用链继续向上，直到为异常找到一个 catch 子句。只要找到能够处理异常的 catch 子句，就进入该 try 块的最后一个 catch 子句之后的语句继续执行。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"重抛异常：在 catch 子句中，可以再次抛出异常。throw 不加表达式，表示再次抛出 try 块中检测到的异常表达式，重抛异常不能被 try-catch 捕获，只能传到上一级函数。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"try {\n    throw \"hello\";  // 抛出 char *异常\n} catch (const char *) {  // 捕获 char *异常\n    throw;  // 重新抛出 char *异常至上一级函数\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓要如何利用 C++ 里面的异常？","category":"page"},{"location":"lang/Cpp/#命名空间","page":"C++","title":"命名空间","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"命名空间是用来限定名字的解析和使用范围的，它是 C++ 开发大型程序的工具之一。其原理是将全局作用域划分为一个一个的命名空间，每个命名空间是一个独立的作用域，在不同命名空间内部定义的名字彼此之间互补影响，从而有效地避免了命名空间污染。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"定义命名空间：命名空间可以在全局作用域或其他命名空间内部定义，但不能在函数、结构体或类内部定义，且要保证命名空间之间不会出现名字冲突。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"namespace 命名空间名 {\n    ...;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"命名空间作用域内，可以包含一下内容：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"变量、对象以及它们的初始化\n枚举常量\n函数声明以及函数定义\n类、结构体声明与实现\n模板\n其他命名空间","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"每个命名空间是一个作用域：定义在命名空间中的实体称为命名空间成员。命名空间中的每个名字必须是该命名空间中的唯一实体，不同命名空间可以具有同名成员。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"在命名空间中定义的名字可以被命名空间中的其他成员直接访问，命名空间外部的代码必须指出名字定义在哪个命名空间中，即作用域运算符限定命名空间：命名空间::成员名\n命名空间可以是不连续的：可以在几个部分中分开定义，一个命名空间可以分散在多个文件中。\n接口和实现分离：命名空间可以不连续意味着：\n命名空间成员如果是类，可以将作为类接口的函数声明和对象声明放在头文件中，使用这些命名空间成员的文件可以包含这些头文件\n命名空间类成员的定义可以放在单独的源文件中。\n定义命名空间成员：在命名空间内部定义的函数可以使用同一命名空间中定义的名字\n全局命名空间：定义在全局作用域的名字（任何类、函数或命名空间外部声明的名字）是定义在全局命名空间中的。全局命名空间存在于每个程序中，是隐式的。\n嵌套命名空间：外围命名空间中声明的名字被嵌套命名空间中同一名字的声明所屏蔽","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"未命名的命名空间：定义命名空间时如果没有给出命名空间名字，称为未命名的命名空间","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"namespace {\n    ...;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"未命名的命名空间中定义的名字可以直接使用，没有命名空间名字来限定它们。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"未命名的命名空间可以在给定文件中不连续，但不能跨越文件，每个文件有自己的未命名的命名空间。本质上在一个文件中所有未命名的命名空间会被系统用同一个标识符代替，且区别于其他文件的标识符。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"命名空间别名：为命名空间起一个别名来代替较长的命名空间名 namespace 命名空间名 = 命名空间名;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"命名空间声明：使用 using 声明引入命名空间成员 using 命名空间名::命名空间成员名;","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"使用 using namespaec 命名空间名; 使得特定命名空间的所有名字可见，没有限制。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"类和命名空间：对命名空间内部使用的名字的查找遵循常规的 C++ 名字查找规则。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"实参相关的查找与类类型形参：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"std::string s;\ngetline(std::cin, s);  // 调用 std::getline","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"接收类类型形参的函数，以及与类本身定义在同一命名空间的函数，在用类类型对象作为实参的时候是可见的。当编译器在编译 getline(std::cin, s); 的时候，它在当前的作用域以及定义 cin 和 string 类型的命名空间中查找匹配的函数，进而在 std 命名空间找到有 string 类型定义的 getline 函数，所以调用 getline 函数不用 std:: 限定。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"标准命名空间的使用：标准库的所有名字都是在一个名为 std 的标准命名空间中定义的，当程序中用到标准库时，需要使用 std 作用域限定。","category":"page"},{"location":"lang/Cpp/#C11-新特性","page":"C++","title":"C++11 新特性","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"auto 关键词","category":"page"},{"location":"lang/Cpp/#C-LeetCode-常用语法与函数","page":"C++","title":"C++ LeetCode 常用语法与函数","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字符串转整型：stoi(s, start, base)，s 是要转换的字符串，start 是起始位置，base 是要转换的整数进制，默认是从 0 位置开始，转换为 10 进制。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"数值转字符串：to_string(val)，val 可以是任何数值类型。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"分割字符串：用 getline() 和 istringstream 联合实现：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"// 根据 ',' 号分割字符串，getline 默认的是按照行读取，但是指定就按照给定的标志分割\nint main() {\n    string str = \"1,2,3,4,5\";\n    istringstream s_in(str);\n    string c;\n    while (getline(s_in, c, ',')) {\n        cout << c << endl;\n    }\n    return 0;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"强制类型转换：在 LeetCode 中常用 static_cast 作为类型转换 static_cast<new type>(expression)","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"判断是否为数字、字母：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"isalpha(char c);  // 判断是否为字母\nisdigit(char c);  // 判断是否为数字\nisalnum(char c);  // 判断是否为数字或字母","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"字母的大小写转换：小写转换 tolower(char c)，大写转换 toupper(char c)。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"有序查找：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"lower_bound() 用于在指定区域内（左闭右开）查找不小于目标值的第一个元素，也就是说最终查找的不一定是和目标值相等的元素，也可能是比目标值大的元素，底层实现是二分查找：","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val);\nint main() {\n    vector<int> nums {1, 2, 3, 5, 5};\n    auto it1 = lower_bound(nums.begin(), nums.end(), 3);\n    cout << *it1 << endl;\n    auto it2 = lower_bound(nums.begin(), nums.end(), 4);\n    cout << *it2 << endl;\n    system(\"pause\");\n    return 0;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"upper_bound() 用于在指定目标区域中查找大于目标值的第一个元素，返回该元素所在位置的迭代器。","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"int main() {\n    vector<int> nums {1, 2, 3, 5, 5};\n    auto it1 = upper_bound(nums.begin(), nums.end(), 3);\n    cout << it1 - nums.begin() << endl;\n    auto it2 = upper_bound(nums.begin(), nums.end(), 4);\n    cout << it2 - nums.begin() << endl;\n    system(\"pause\");\n    return 0;\n}","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"对于 set 和 map 来说有属于自己类的 lower_bound 和 upper_bound：其效率高于 STL 中的","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"set.lower_bound(val);\nmap.lower_bound(val);","category":"page"},{"location":"lang/Cpp/#问题","page":"C++","title":"问题","text":"","category":"section"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓malloc 的对象直接 delete，程序会崩溃吗？","category":"page"},{"location":"lang/Cpp/","page":"C++","title":"C++","text":"❓如何用 rand5 实现 rand7？","category":"page"},{"location":"AI/RNN/#快速索引目录","page":"循环神经网络","title":"快速索引目录","text":"","category":"section"},{"location":"AI/RNN/#循环神经网络","page":"循环神经网络","title":"循环神经网络","text":"","category":"section"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"记录网络的输入序列为 x_1x_2cdotsx_n，一个循环神经网络（RNN）展开后可以看做一个 n 层的前馈神经网络，第 t 层对应着 t 时刻的状态（t=12cdotsn），记第 t 层（时刻）的输入状态、隐藏状态、输出状态分别为 x_t h_t o_t，训练时的目标输出值为 y_t，则有：隐藏状态 h_t 由当前时刻的输入状态 x_t 和上一时刻的隐藏状态 h_t-1 共同确定，即","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"h_t=sigma(Ux_t+Wh_t-1+b)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中，U 是输入层到隐藏层的权重矩阵，W 是不同时刻的隐藏层之间的连接权重，b 是偏置向量，sigma(cdot) 是激活函数（通常使用 textttTanh 函数）。循环神经网络最大的特点就是当前时刻的隐藏状态不仅与当前时刻的输入状态有关，还受上一时刻的隐藏状态影响。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"输出状态 o_t 的计算公式为：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"o_t=g(Vh_t+c)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中，V 是隐藏层到输出层的权重矩阵，c 是偏置向量，g(cdot) 是输出层的激活函数（对于分类任务可以采用 textttSoftmax 函数）。在训练时，网络在整个序列上的损失可以定义为不同时刻的损失之和：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"mathcalL=sum_tmathcalL_t=sum_t Loss(o_ty_t)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"上述的权重矩阵 U W V 是所有时刻共享参数的，这种机制不仅可以极大地减少网络需要学习的参数数量，而且使得网络可以处理长度不固定的输入序列。在 RNN 的训练过程中，由于不同时刻的状态是相互依赖的，因此需要存储各个时刻的状态信息，而且无法进行并行计算，这导致整个训练过程内存消耗大，并且速度较慢。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"RNN 之所以能够在序列数据的处理上获得出色的表现，是因为它拥有长期记忆功能，能够压缩并获得长期数据的表示。实际上，在 RNN 训练过程中，为了防止梯度爆炸（或弥散）的问题，通常采用带截断的反向传播算法，即仅反向传播 k 个时间步的梯度。理论上的无限记忆优势在实际中几乎不存在。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"实际上，在序列任务中，卷积神经网络（CNN）在空洞卷积的帮助下（例如 TextCNN），具有更好的并行化和可训练性。只不过长短期记忆网络（LSTM）和 Seq2Seq 网络依然是序列数据处理中最为通用的架构。还有人很多工作对卷积神经网络和循环神经网络进行组合使用，提升序列数据处理能力（如 TrellisNet）。","category":"page"},{"location":"AI/RNN/#随时间反向传播算法（BPTT）","page":"循环神经网络","title":"随时间反向传播算法（BPTT）","text":"","category":"section"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"随时间反向传播算法（BackPropagation Through Time, BPTT）将 RNN 看做一个展开的多层前馈网络，每一层对应 RNN 中的每个时刻。在展开的前馈网络中，所有层的参数是共享的，因此参数的真实梯度是所有展开层的参数梯度之和。","category":"page"},{"location":"AI/RNN/#长短期记忆网络（LSTM）","page":"循环神经网络","title":"长短期记忆网络（LSTM）","text":"","category":"section"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"LSTM 在标准 RNN 基础上做了改进，解决 RNN 训练过程中的梯度消失问题。增加了控制门单元：遗忘门、输入门、输出门，这些门控单元组合成 cell 状态，可以保证 LSTM 在长序列场景下的信息保持。","category":"page"},{"location":"AI/RNN/#长程依赖问题","page":"循环神经网络","title":"长程依赖问题","text":"","category":"section"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"LSTM 是如何实现长短期记忆功能的？","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（1）一般的 RNN 中，只有一个隐藏状态（hidden state）单元 h_t，不同时刻隐藏状态单元的参数是相同（共享）的。LSTM 在普通 RNN 的基础上增加了一个元胞状态（cell state）单元 c_t，其在不同时刻有着可变的连接权重，可解决普通循环神经网络中的梯度消失或爆炸问题。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（2）LSTM 引入了门控单元，是神经网络学习到的用于控制信号的存储、利用和舍弃的单元。对于每一个时刻 t，LSTM 有输入门 i_t、遗忘门 f_i 和输出门 o_t 共 3 个门控单元。每个门控单元的输入包括当前时刻的序列信息 x_t 和上一时刻的隐藏状态单元 h_t-1，具体公式：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"i_t=sigmaleft( W_i x_t + U_i h_t-1 + b_i right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"f_t=sigmaleft( W_f x_t + U_f h_t-1 + b_f right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"o_t=sigmaleft( W_o x_t + U_o h_t-1 + b_o right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"3 个门控单元都相当于一个全连接层，激活函数 sigma(cdot) 的取值范围是 0 1，常用 textttSigmoid 作为激活函数。当门控单元的状态为 0 时，信号会被全部丢弃；当状态为 1 时，信号会被全部保留。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（3）元胞状态单元从上一个时刻 c_t-1 到当前时刻 c_t 的转移是由输入门和遗忘门共同控制的。输入门决定了当前时刻输入信息 tildec_t 有多少被吸收，遗忘门决定了上一时刻元胞状态单元 c_t-1 有多少不被遗忘，最终的元胞状态单元 c_t 由两个门控处理后的信号取和产生。具体公式：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"tildec_t = textttTanhleft( W_c x_t + U_c h_t-1 + b_c right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"c_t = f_t odot c_t-1 + i_t odot tildec_t","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中 odot 为逐元素点乘操作。LSTM 的隐藏状态单元 h_t 则由输出门 c_t 决定：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"h_t = o_t odot textttTanh(c_t)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"不仅隐藏状态单元 h_t-1 和 h_t 之间有着较为复杂的循环连接，内部的元胞状态单元 c_t-1 和 c_t 之间还具有线性自循环关系，这个关系可以看作是在滑动处理不同时刻的信息。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（4）LSTM 中遗忘门和输出门的激活函数十分重要。删除遗忘门的激活函数会导致之前的元胞状态不能很好地被抑制；而删除输出门的激活函数则可能会出现非常大的输出状态。","category":"page"},{"location":"AI/RNN/#门控循环单元（GRU）","page":"循环神经网络","title":"门控循环单元（GRU）","text":"","category":"section"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（1）GRU 只有两个门控单元，分别为重置门 r_t 和 更新门 z_t，一个控制短期记忆，另一个控制长期记忆。重置门控制前一状态有多少信息被写入到当前的候选集上，其值越小，前一个状态的信息被写入的就越少；更新门用于控制前一个时刻的状态信息被代入到当前状态中的程度，其值越大，说明前一个时刻的状态信息带入越多。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（2）GRU 中每个门控单元的输入包括当前时刻和序列信息 x_t 和上一时刻的隐藏状态单元 h_t-1，具体计算公式为：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"r_t = sigmaleft( W_r x_t + U_r h_t-1 right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"z_t = sigmaleft( W_z x_t + U_z h_t-1 right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中 sigma(cdot) 是激活函数，一般用 textttSigmoid。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（3）GRU 中重置门决定先前的隐藏状态单元是否被忽略，而更新门则控制当前隐藏状态单元是否需要被新的隐藏状态单元更新，具体公式：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"tildeh_t = textttTanh left( W_h x_t + U_h (r_t odot h_t-1) right)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"h_t = (1 - z_t) h_t - 1 + z_t tildeh_t","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中，(1 - z_t)h_t-1 表示上一时刻保留下来（没被遗忘）的信息，z_t tildeh_t 是当前时刻记忆下来的信息。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"用 1 - z_t z_t  作为系数，表明对上一时刻遗忘多少权重的信息，就会在这一时刻记忆多少权重的信息以作为弥补。GRU 就是用这样的一种方式用一个更新门 z_t 实现遗忘和记忆两个功能。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（4）GRU 只有一个隐藏状态单元 h_t，而 LSTM 有隐藏状态单元 h_t 和元胞状态单元 c_t。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（5）GRU 具有更少的参数，更易于计算和实现。在不同数据集、不同超参配置下，可以取得与 LSTM 相当甚至更好的性能，并且具有更快地收敛速度。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"❓GRU 通过什么方法保留前面时序的信息？","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"❓GRU 使用什么损失函数？","category":"page"},{"location":"AI/RNN/#序列到序列（Seq2Seq）","page":"循环神经网络","title":"序列到序列（Seq2Seq）","text":"","category":"section"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（1）Seq2Seq 的映射架构能够将一个可变长序列映射到另一个可变长序列。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（2）Seq2Seq 框架由于输入序列和输出序列是不等长的因此整个处理过程需要拆分为对序列的理解和翻译，也就是编码和解码。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（3）采用一个固定尺寸的状态向量 C 作为编码器与解码器之间的「桥梁」。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（4）假设输入序列为 X=(x_1x_2cdotsx_T)，编码器可以是一个简单的循环神经网络，其隐藏状态 h_t 的计算公式为：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"h_t = f(h_t-1 x_t)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中，f(cdot) 是非线性激活函数，可以是简单的 textttSigmoid 函数，也可以是复杂的门控函数（LSTM、GRU 等）。将上述循环神经网络（编码器）最后一个时刻的隐藏状态 h_T 作为状态向量，并输入到解码器。C 是一个尺寸固定的向量，并且包含了整个序列的所有信息。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（5）解码器需要根据固定尺寸的状态向量 C 来生成长度可变的解码序列 Y=(y_1 y_2 cdots y_T)。这里解码序列的长度 T^prime 和编码长度 T 可以是不同的。解码器也可以用一个简单的循环神经网络来实现，其隐藏状态 h_t 可以按照如下公式计算：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"h_t = f(h_t-1y_t-1C)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"解码器的输出由如下公式决定：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"P(y_tmid y_t-1y_t-2cdotsy_1C) = g(h_t y_t-1C)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中，g(cdot) 会产生一个概率分布（例如用 textttSoftmax 函数产生概率分布）。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（6）解码器的工作流程：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"首先在收到一个启动信号（如 y_0=text start gt）后开始工作，根据 h_t y_t-1 C 计算出 y_t  的概率分布；\n然后对 y_t 进行采样获得具体取值；\n循环上述操作，直到遇到结束信号（如 y_t=text eos gt；","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（7）解码器的实现还能够用一种更加简单的方式，仅在初始时刻需要状态向量 C，其他时刻仅接收隐藏状态和上一时刻的输出信息 P(y_t)=g(h_ty_t-1)。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（8）在训练时，需要让模型输出的序列尽可能正确，这可以通过最大化对数似然概率来实现：","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"max_theta frac1Nsum_n=1^N log p_theta(Y_n mid X_n)","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"其中 theta 为模型参数，X_n 是一个输入序列，Y_n 是对应的输出序列， (X_nY_n) 构成一个训练样本对。","category":"page"},{"location":"AI/RNN/","page":"循环神经网络","title":"循环神经网络","text":"（9）因为是序列到序列的转换，实际应用中可以通过贪心法求解 Seq2Seq，当度量标准、评估方式确定后，解码器每次根据当前的状态和已解码的序列选择一个最佳的解码结果，直至结束。","category":"page"},{"location":"OS/#操作系统","page":"-","title":"操作系统","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"资料：B 站课程：南京大学 2022 操作系统 - 蒋炎岩；课程链接：操作系统：设计与实现 (2022 春季学期)；\nMIT - The Missing Semester of Your CS Education；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"操作系统（Operating System, OS）：是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。向上对用户程序提供接口，向下接管硬件资源。操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"操作系统服务谁？程序 = 状态机；涉及多线程 Linux 应用程序；\n操作系统为程序提供什么服务？操作系统 = 对象 + API（应用视角/设计）；涉及 POSIX + 部分 LInux 特性；\n如何实现操作系统提供的服务？操作系统 = C 程序（硬件视角/实现）；涉及 xv6、自制迷你操作系统；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"计算机专业学生必须具备的核心素质：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"是一个合格的操作系统用户：\n会 STFW/RTFM 自己动手解决问题\n不怕使用任何命令行工具 vim, tmux, grep, gcc, binuils, ….\n不惧怕写代码：\n能管理一定规模（数千行）的代码；\n能在出 Bug 时默念「机器永远是对的、我肯定能调出来的」，然后开始用正确的工具/方法调试；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是源代码视角下的程序？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"数字逻辑电路：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"状态 = 寄存器保存的值（flip-flop）；\n初始状态 = RESET（implementation dependent）；\n迁移 = 组合逻辑电路计算寄存器下一周期的值；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"如果把状态机用一段代码写出来，是这样的","category":"page"},{"location":"OS/","page":"-","title":"-","text":"#include <stdio.h>\n#include <unist.h> \n\n#define REGS_FOREACH(_) _(X) _(Y)\n#define RUN_LOGIC  X1 = !X && Y; \\\n\t\t\t\t   Y1 = !X && !Y;\n#define DEFINE(X)  static int X, X##1;\n#define UPDATE(X)  X = X##1;\n#define PRINT(X)   printf(#X \" = %d; \", X);\n\nint main() {\n    REGS_FOREACH(DEFINE);\n    while (1) {  //clock\n    \tRUN_LOGIC;\n        REG_FOREACH(PRINT);\n        REG_FOREACH(UPDATE);\n        putchar('\\n'); sleep(1);\n    }\n}","category":"page"},{"location":"OS/","page":"-","title":"-","text":"更完整的一种实现是「数码管显示」，输出数码管的配置信号：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"#include <stdio.h>\n#include <unistd.h>\n\n#define REGS_FOREACH(_)  _(X) _(Y)\n#define OUTS_FOREACH(_)  _(A) _(B) _(C) _(D) _(E) _(F) _(G)\n#define RUN_LOGIC        X1 = !X && Y; \\\n                         Y1 = !X && !Y; \\\n                         A  = (!X && !Y) || (X && !Y); \\\n                         B  = 1; \\\n                         C  = (!X && !Y) || (!X && Y); \\\n                         D  = (!X && !Y) || (X && !Y); \\\n                         E  = (!X && !Y) || (X && !Y); \\\n                         F  = (!X && !Y); \\\n                         G  = (X && !Y); \n\n#define DEFINE(X)   static int X, X##1;\n#define UPDATE(X)   X = X##1;\n#define PRINT(X)    printf(#X \" = %d; \", X);\n\nint main() {\n  REGS_FOREACH(DEFINE);\n  OUTS_FOREACH(DEFINE);\n  while (1) { // clock\n    RUN_LOGIC;\n    OUTS_FOREACH(PRINT);\n    REGS_FOREACH(UPDATE);\n    putchar('\\n');\n    fflush(stdout);\n    sleep(1);\n  }\n}","category":"page"},{"location":"OS/","page":"-","title":"-","text":"在课程课件中复制 logisim.c 代码的下载链接使用 wget http://jyywiki.cn/pages/OS/2022/demos/logisim.c 将文件下载，然后使用 vi logisim.c 可以查看和编辑。在 vim 下用 :!gcc % 可以编译当前文件，没有报错可以 :!./a.out 来看看程序的运行输出结果。在课程课件中复制下载 seven-seg.py 代码：wget http://jyywiki.cn/pages/OS/2022/demos/seven-seg.py，然后再次运行 ./a.out | python seven-seg.py，就会出现数码管的显示了；seven-seg.py 将 7 个晶体管用 A - G 分别表示，然后用 1 表示亮，0 表示不亮；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"C 程序的状态机：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"状态  = 堆 + 栈\n初始状态 = main 的第一条语句；\n迁移 = 执行一条简单语句\n任何 C 程序都可以改写成「非复合语句」的 C 代码；\n真的有这种工具（C Intermediate Language）和解释器；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"‼️任何真正的理解都应该落到可以执行的代码。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"下载课件 hanoi-r.c 为其写一个 main 函数：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"#include <stdio.h>\n#include \"hanoi-r.c\"\n\nint main() {\n    hanoi(3, 'A', 'B', 'C');\n    return 0;\n}","category":"page"},{"location":"OS/","page":"-","title":"-","text":"编译并执行 gcc main.c && ./a.out，可以看到函数的输出。使用 gdb 运行程序：gdb ./a.out 可以看到堆栈情况和单步执行。命令：start 程序开始，step 单步执行，info frame 打印堆栈信息。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"M1 Mac ARM 架构目前无法安装 gdb。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是 lldb 和 gdb？它们有什么区别？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"C 程序的状态机模型：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"状态 = stack frame 的列表（每个 frame 有 PC）+ 全局变量；\n初始状态 = main(argc, argv)，全局变量初始化；\n迁移 = 执行 top stack frame PC 的语句；PC++。PC 是指向程序语句的指针；\n函数调用 = push frame（frame.PC = 入口）；\n函数返回 = pop frame；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是二进制视角下的程序？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"还是状态机：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"状态 = 内存 M + 寄存器 R；（寄存器在 CPU 上，本质也是一个内存）\n初始状态 = \n迁移 = 执行一条指令","category":"page"},{"location":"OS/","page":"-","title":"-","text":"调用操作系统 syscall；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"把 (MR) 完全交给操作系统，任其修改\n❓如果程序不打算完全信任操作系统呢？\n实现与操作系统中的其他对象交互\n读写文件/操作系统状态（例如把文件内容写入 M）\n改变进程（运行中状态机）的状态，例如创建进程/销毁自己","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓既然 <程序 = 计算 + syscall>，请问如何构造一个最小的 Hello, World？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"用 gcc 编译出来的文件不满足「最小」","category":"page"},{"location":"OS/","page":"-","title":"-","text":"--verbose 可以查看所有编译选项（有很多）。printf 变成了 puts@plt；\n-static 会复制 libc；\n强行编译 + 链接：gcc -c + ld；链接失败 ld 不知道怎么链接库函数；如果把 printf 函数去掉，即定义空的 main 函数（把 main 改成 _start 可以避免一个奇怪的警告），这个时候会出现 Segmentation Fault；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"下载最小版本的汇编代码 minimal.S","category":"page"},{"location":"OS/","page":"-","title":"-","text":"#include <sys/syscall.h>\n\n.globl _start\n_start:\n  movq $SYS_write, %rax   # write(\n  movq $1,         %rdi   #   fd=1,\n  movq $st,        %rsi   #   buf=st,\n  movq $(ed - st), %rdx   #   count=ed-st\n  syscall                 # );\n\n  movq $SYS_exit,  %rax   # exit(\n  movq $1,         %rdi   #   status=1\n  syscall                 # );\n\nst:\n  .ascii \"\\033[01;31mHello, OS World\\033[0m\\n\"\ned:","category":"page"},{"location":"OS/","page":"-","title":"-","text":"gcc 支持对汇编代码的预编译（还会定义 __ASSEMBLER__ 宏）","category":"page"},{"location":"OS/","page":"-","title":"-","text":"编译命令：gcc minimal.S -c && ld minimal.o","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓为什么会出现 Segmentation Fault？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"可以观察程序（状态机）的执行：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"初学者必须克服的恐惧：STFW/RTFM（M 非常有用）；\nstarti 可以帮助从第一条指令开始执行程序；【可以去看看 GDB 的官方文档】\ngdb 可以在两种状态机视角之间切换（layout）；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"因为返回的是初始状态，状态机的初始状态是不能够返回的；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓杀人面试题 (1)：一个普通的、人畜无害的 Hello World C 程序执行的第一条指令在哪里？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"可以用 gdb a.out，然后 starti 去调试。info proc {mappings,...} 打印进程内存。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"main() 之前发生了什么？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓杀人的面试题 (2)：main 执行之前、执行中、执行后，发生了哪些操作系统 API 调用？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓有什么办法让状态机「停下来」？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"如果是纯「计算」 的状态机，是不行的，要么是死循环，要么 undefined behavior；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"解决办法是使用 syscall","category":"page"},{"location":"OS/","page":"-","title":"-","text":"#include <sys/syscall.h>\n\nint main() {\n    syscall(SYS_exit, 42);\n}","category":"page"},{"location":"OS/","page":"-","title":"-","text":"一些彩蛋：ANSI Escape Code. 在终端中一些字符可以有颜色，特殊编码的字符实现终端控制","category":"page"},{"location":"OS/","page":"-","title":"-","text":"vi.c from busybox；\ntelnet towel.blinkenlights.nl（可以看到用字符做成的电影，按 Ctrl + ] and q 退出）；\ndialog --msgbox 'Hello, OS World!' 8 32；\nssh sshtron.zachlatta.com（网络游戏）；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是编译器？什么是正确的编译？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"正确的编译就一句话：在 C 代码中所有不可优化的代码都被翻译到汇编语言中；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"同步（Synchronization）与异步（Asynchronous）。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"生产者 - 消费者问题：99% 的实际并发问题都可以用生产者 - 消费者解决。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"void Tproduce() { while (1) printf(\"(\"); }\nvoid Tconsume() { while (1) printf(\")\"); }","category":"page"},{"location":"OS/","page":"-","title":"-","text":"这个代码需要解决的问题是：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"保证打印出来的括号是合法的，或者是某个合法括号序列的前缀；\n括号嵌套的深度不超过 n；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"实现同步的方法：（1）等到有空位的时候再打印左括号；（2）等到能够配对的时候再打印右括号。因此：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"左括号：相当于生产资源（任务）、放入队列；\n右括号：从队列取出资源（任务）执行；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"使用互斥锁实现括号问题：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"左括号：嵌套深度（队列）不足 n 的时候才能够打印：\n右括号：嵌套深度（队列） 1 时候才能够打印；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"条件变量（Conditional Variables, CV）：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"wait(cv, mutex)：调用时必须保证已经获得 mutex；释放 mutex 进入睡眠状态。在睡眠状态的时候，系统不会对代码有任何操作；\nsignal/notify(cv)：如果有线程正在等待 cv，则唤醒其中一个线程；\nbroadcast/notifyAll(cv)：唤醒全部正在等待 cv 的线程；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓线程（Threads）和协程（Corotines）","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓互斥锁和自旋锁的区别","category":"page"},{"location":"OS/#堆栈","page":"-","title":"堆栈","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"堆和栈的区别：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"栈区（stack）：由编译器自动分配和释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构的栈；\n堆区（heap）：一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。需要手动使用 new, malloc, delete, free 进行分配和回收，空间较大，但可能会出现内存泄漏和空闲碎片的情况。它与数据结构中的堆是两回事，分配方式类似于链表；\n申请方式：\n栈：由系统自动分配。例如在声明函数的一个局部变量 int b，系统会自动在栈中为 b 开辟空间；\n堆：需要程序员自己申请，并指明大小。在 C 中用 maclloc 函数申请，在 C++ 中用 new 操作符；\n申请后系统的响应：\n栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出；\n堆：操作系统有一个记录空间内存地址的链表，当系统收到程序的申请时，会遍历链表，寻找第一个空间大于所申请空间的堆结点，然后将节点从内存空闲节点链表中删除，并将该节点的空间分配给程序。对于大多数操作系统，会在这块内存空间中的首地址处记录本次分配的大小。这样，代码中的 delete 语句才能正确地释放本地内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入到链表中。\n申请大小的限制：\n栈：在 Windows 下，栈是向低地址拓展的数据结构，是一块连续的内存的区域。栈的地址和栈的大小是系统预先规定好的，如果申请的内存空间超过栈的剩余空间，将提升栈溢出。栈的空间有限；\n堆：是向高地址拓展的内存结构，是不连续的内存区域。是系统用链表存储空闲内存地址的，不连续。堆是很大的自由内存区；\n申请效率的比较：\n栈：由系统自动分配，速度较快，但程序员无法控制；\n堆：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便；\n拓展：在 Windows 操作系统中，最好的方式是用 VirtualAlloc 分配内存。不是在堆，不是在栈，而是在内存空间中保留一块内存，虽然用起来不方便，但是速度快，也很灵活；\n堆和栈的存储内容：\n栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用的下一个可执行语句）的地址，然后是函数的各个参数。在 C 编译器中，参数是由右往左入栈的，然后是函数的局部变量，静态变量不入栈；\n堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。\n总结：\n栈的空间由操作系统自动分配以及释放；堆的空间是程序员手动分配以及释放的；\n栈的空间有限；堆是很大的自由内存区；\nC 中的 maclloc 函数分配的内存空间就在堆上；C++ 中对应的是 new 操作符；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"除了栈区和堆区之外，还有：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"全局/静态存储区：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另外一块区域。程序结束后由系统释放；\n文字常量区：常量字符串存放的位置，一般不允许修改，程序结束之后由系统释放；\n程序代码区：存放函数体的二进制代码；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是内存泄漏？要怎么排查？","category":"page"},{"location":"OS/#命令行","page":"-","title":"命令行","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"uname：查询系统基本信息的命令：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"-s, --kernel-name 输出内核名称；\n-n, --nodename 输出网络节点上的主机名；\n-r, --kernel-release 输出内核发行号；\n-v, --kernel-version 输出内核版本；\n-m, --machine 输出主机的硬件架构名称；\n-p, --processor 输出处理器类型或 unknown；\n-i, --hardware-platform 输出硬件平台或 unknown；\n-o, --operating-system 输出操作系统名称；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓uname -a 输出的是什么？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"(base) strongnine@strongs-MacBook-Pro opt % uname -a\nDarwin strongs-MacBook-Pro.local 22.1.0 Darwin Kernel Version 22.1.0: Sun Oct  9 20:14:30 PDT 2022; root:xnu-8792.41.9~2/RELEASE_ARM64_T8103 arm64","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓tldr (Too Long; Didn’t Read) 是做什么的？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"wget：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是 strace？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"strace 也即是 system call trace。在理解程序运行时使用的系统调用，例如 strace ./hello-goodbye。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"所有的程序都是状态机，它们不断地在「计算」和「syscall」两种状态转换；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"被操作系统加载：通过另一个进程执行 execve 设置为初始状态；\n状态机执行：\n进程管理：fork, execve, exit, …\n文件/设备管理：open, close, read, write, …\n存储管理：mmap, brk, …\n直到 _exit (exit_group) 退出；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"在不同的视角下去理解程序","category":"page"},{"location":"OS/","page":"-","title":"-","text":"源代码 S：状态迁移 = 执行语句；\n二进制代码 C：状态迁移 = 执行指令；\n编译器 C = compile(S)；\n应用视角下的 OS：就是一条 syscall 指令；\n理解 OS 的重要工具：gcc, binutils, gdb, strace； ","category":"page"},{"location":"OS/#并发编程","page":"-","title":"并发编程","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"并发（concurrency）：如果逻辑控制流在时间上重叠，那么它们就是并发的（concurrent），这种常见的现象称为并发。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"并发程序（concurrent program）：使用应用级并发的应用程序称为并发程序。现代操作系统提供了山中基本的构造并发程序的方法：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"进程：每个逻辑控制流都是一个进程，由内核来调度和维护。进程有独立的虚拟地址空间，要想和其他流通信，控制流必须使用某种显式的进程间通信（interprocess communication, IPC）机制。\nI/O 多路复用：应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。\n线程：运行在一个单一进程上下文中的逻辑流，由内核进行调度，可以看成是其他两种方式的混合体，像进程流一样由内核进行调度，又像 I/O 多路复用流一样共享同一个虚拟地址空间。","category":"page"},{"location":"OS/#进程","page":"-","title":"进程","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"进程的优点：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"有独立的地址空间，进程不会不小心覆盖另一个进程的虚拟内容。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"进程的缺点：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"独立的地址空间使得进程共享状态信息更加困难，需要使用显式的 IPC（进程间通信）机制，而这开销很大。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"Unix IPC 通常指的是所有允许进程和同一台主机上其他进程进行通信的技术，包括：管道、先进先出（FIFO）、系统 V 共享内存、系统 V 信号量（semaphore）。","category":"page"},{"location":"OS/#I/O-多路复用","page":"-","title":"I/O 多路复用","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"I/O 多路复用的优点：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"比基于进程的涉及给了程序员更多的对程序行为的控制。\n基于 I/O 多路复用的事件驱动器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。\n因为不需要进程上下文切换来调度新的流，事件驱动设计常常比基于进程的设计要高效得多。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"I/O 多路复用的缺点：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"编码复杂，并且随着并发粒度的减小，复杂性变高。\n不能充分利用多核处理器。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"现代高性能服务器（如 Node.js, nginx, Tornado）使用的都是基于 I/O 多路复用的事件驱动的编程方式，因为相比较于进程和线程的方式，它有明显的性能优势。并发粒度：是指每个逻辑流每个时间片执行的指令数量。","category":"page"},{"location":"OS/#线程","page":"-","title":"线程","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"线程（thread）：运行在进程上下文中的逻辑流。每个线程都有自己的线程上下文（thread context），包括一个唯一的整数线程 ID（Thread ID, TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"主线程（main thread）：每个进程开始生命周期时都是单一线程，这个线程称为主线程。在某一时刻，主线程创建一个对等线程（peer thread），从这个时间点开始，两个线程就并发地运行。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"因为一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"在任何一个时间点上，线程是可结合的（joinable）或者是可分离的（detached）。一个","category":"page"},{"location":"OS/#并发与并行","page":"-","title":"并发与并行","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"操作系统是最早的并发程序之一。并发的基本单位是「线程」。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"原子性：一段代码执行（例如 pay()）独占整个计算机系统。「程序（甚至是一条指令）独占处理器执行」的基本假设在现代多处理器系统上不再成立。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"99% 的并发问题都可以用一个队列解决：","category":"page"},{"location":"OS/","page":"-","title":"-","text":"把大任务切分成可以并行的小任务；\nworker thread 去锁保护的队列里取任务；\n除去不可并行的部分，剩下的部分可以获得线性的加速度：T_nT_infty+fracT_1n","category":"page"},{"location":"OS/","page":"-","title":"-","text":"单个处理器把汇编代码（用电路）编译成更小的 muops，每个 muops 都有 Fetch、Issue、Execute、Commit 四个阶段。在任何时刻，处理器都维护一个 muops 的「池子」","category":"page"},{"location":"OS/","page":"-","title":"-","text":"每一周期向池子补充尽可能多的 muop：多发射；\n每一周期（在不违反编译正确性的前提下）执行尽可能多的 muop：乱序执行、按序提交；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓并发和并行有什么区别？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"并发（concurrency），指的是多个事情，在同一时间段内同时发生了。例如在单核 CPU 上的多任务，在宏观上看来两个程序是同时运行的，但是从微观上看两个程序的指令是交织着运行的，在单个周期内只运行了一个指令；\n并行（parallelism），指的是多个事情，在同一时间点上同时发生了。是严格物理意义上的同时运行，比如两个程序分别运行在两个 CPU 核心上，两者之间相互不影响，单个周期内每个人程序都运行了自己的指令；\n只有在多 CPU 的情况下，才会发生并行，否则看似同时发生的事情，其实都是并发执行的；\n并发并不会提高计算机的性能，只能够提高效率，例如降低某个进程的相应时间。而并行可以提高计算机的性能。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"互斥：保证两个线程不能同时执行一段代码","category":"page"},{"location":"OS/#问题","page":"-","title":"问题","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"❓ARM 和 X86 架构有什么区别？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"中央处理单元（CPU）主要由运算器、控制器、寄存器三部分组成，从字面意思看运算器就是起着运算的作用，控制器就是负责发出 CPU 每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"CPU 有着处理指令、执行操作、控制时间、处理数据四大作用。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"CPU 的架构可以分为两大类：复杂指令集和精简指令集，即 CISC 和 RISC。Intel 的处理器使用的是复杂指令集（CISC），ARM 处理器使用精简指令集（RISC）。ARM 架构过去称作进阶精简指令集机器（AdvancedRISCMachine），更早称作：AcornRISCMachine。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"ARM 从来只是设计低功耗处理器，Intel 的强项是设计超高性能的台式机和服务器处理器。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"Intel 并没有开发 64 位版本的 x86 指令集。64 位的指令集名为 x86-64（有时简称为 x64），实际上是 AMD 设计开发的。Intel 想做 64 位计算，它知道如果从自己的 32 位 x86 架构进化出 64 位架构，新架构效率会很低，于是它搞了一个新 64 位处理器项目名为 IA64。由此制造出了 Itanium 系列处理器。同时 AMD 知道自己造不出能与 IA64 兼容的处理器，于是它把 x86 扩展一下，加入了 64 位寻址和 64 位寄存器。最终出来的架构，就是 AMD64，成为了 64 位版本的 x86 处理器的标准。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"ARM 的 big.LITTLE 架构是一项 Intel 一时无法复制的创新。在 big.LITTLE 架构里，处理器可以是不同类型的。传统的双核或者四核处理器中包含同样的 2 个核或者 4 个核。一个双核 Atom 处理器中有两个一模一样的核，提供一样的性能，拥有相同的功耗。ARM 通过 big.LITTLE 向移动设备推出了异构计算。这意味着处理器中的核可以有不同的性能和功耗。当设备正常运行时，使用低功耗核，而当你运行一款复杂的游戏时，使用的是高性能的核。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"设计处理器的时候，要考虑大量的技术设计的采用与否，这些技术设计决定了处理器的性能以及功耗。在一条指令被解码并准备执行时，Intel和ARM的处理器都使用流水线，就是说解码的过程是并行的。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"为了更快地执行指令，这些流水线可以被设计成允许指令们不按照程序的顺序被执行（乱序执行）。一些巧妙的逻辑结构可以判断下一条指令是否依赖于当前的指令执行的结果。Intel和ARM都提供乱序执行逻辑结构，可想而知，这种结构十分的复杂，复杂意味着更多的功耗。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"Intel 处理器由设计者们选择是否加入乱序逻辑结构。异构计算则没有这方便的问题。ARM Cortex-A53 采用顺序执行，因此功耗低一些。而 ARM Cortex-A57 使用乱序执行，所以更快但更耗电。采用 big.LITTLE 架构的处理器可以同时拥有 Cortex-A53 和 Cortex-A57 核，根据具体的需要决定如何使用这些核。在后台同步邮件的时候，不需要高速的乱序执行，仅在玩复杂游戏的时候需要。在合适的时间使用合适的核。","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓从精度、非空、非负考虑，采用 float","category":"page"},{"location":"OS/","page":"-","title":"-","text":"面试官提出 float 精度问题，引申到存储原理，如何判 0？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓float 数 (1 - 0.9) 与 (0.9 - 0.8) 相等吗？面对精度丢失，如何改进？引申到整型，把余额×100，转整型；","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓如何给文件增加运行权限？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓Linux 软连接和硬连接的区别？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓线程的共享资源和私有资源是什么？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓什么是内存池？怎么去设计？怎么去测试性能会提升多少？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓内存池跑在 32 位系统和 64 位系统上可能会有什么问题？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓内存池会不会无限扩展？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓回收内存的时候，如何确定回收的块的大小？","category":"page"},{"location":"OS/","page":"-","title":"-","text":"❓select、poll、epoll 有什么区别？","category":"page"},{"location":"OS/#资料","page":"-","title":"资料","text":"","category":"section"},{"location":"OS/","page":"-","title":"-","text":"https://gitee.com/autoencoder/interviewtop/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md","category":"page"},{"location":"OS/","page":"-","title":"-","text":"操作系统八股文背诵版 - 互联网面试八股文","category":"page"},{"location":"dataStruc&algo/algo/#复杂度","page":"-","title":"复杂度","text":"","category":"section"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"平均时间复杂度：全称加权平均时间复杂度或者期望时间复杂度。","category":"page"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"均摊时间复杂度：适用于一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系。","category":"page"},{"location":"dataStruc&algo/algo/#排序","page":"-","title":"排序","text":"","category":"section"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"常用的排序算法复杂度对比","category":"page"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性\n冒泡排序 mathcalO(n^2) mathcalO(n) mathcalO(n^2) mathcalO(1) 原地 稳定\n选择排序 mathcalO(n^2) mathcalO(n^2) mathcalO(n^2) mathcalO(1) 原地 不稳定\n插入排序 mathcalO(n^2) mathcalO(n) mathcalO(n^2) mathcalO(1) 原地 稳定\n希尔排序 mathcalO(n^125) mathcalO(n) mathcalO(nlog^2 n) mathcalO(1) 原地 不稳定\n归并排序 mathcalO(nlog n) mathcalO(nlog n) mathcalO(nlog n) mathcalO(n) 非原地 稳定\n快速排序 mathcalO(nlog n) mathcalO(nlog n) mathcalO(n^2) mathcalO(log n) 原地 不稳定\n堆排序 mathcalO(nlog n) mathcalO(nlog n) mathcalO(nlog n) mathcalO(1) 原地 不稳定\n计数排序 mathcalO(n+k) mathcalO(n+k) mathcalO(n+k) mathcalO(k) 非原地 稳定\n桶排序 mathcalO(n+k) mathcalO(n+k) mathcalO(n) mathcalO(n+k) 非原地 不稳定\n基数排序 mathcalO(ntimes k) mathcalO(ntimes k) mathcalO(ntimes k) mathcalO(n+k) 非原地 稳定","category":"page"},{"location":"dataStruc&algo/algo/#动态规划","page":"-","title":"动态规划","text":"","category":"section"},{"location":"dataStruc&algo/algo/#背包问题（含物品价值）","page":"-","title":"背包问题（含物品价值）","text":"","category":"section"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"def knapsack3(weight: List[int], value: List[int], n: int, w: int) -> int:\n    # states[i][j] 代表决策完前 i 个物品时背包重量为 j 时的所有物品价值之和的最大值\n    states = [[-1 for _ in range(w + 1)] for _ in range(n)]\n    \n    states[0][0] = 0\n    if weight[0] <= w: \n        states[0][weight[0]] = value[0]\n    \n    for i in range(1, n):\n        for j in range(w + 1):  # 不选择第 i 个物品\n            if states[i - 1][j] >= 0: \n                states[i][j] = states[i - 1][j]\n        \n        for j in range(w - weight[i] + 1):  # 选择第 i 个物品\n            if states[i - 1][j] >= 0:\n                v = states[i - 1][j] + value[i]\n                if v > states[i][j + weight[i]]:\n                    states[i][j + weight[i]] = v\n                    \n    # 找出最大值\n    maxvalue = -1\n    for j in range(w + 1):\n        if states[n - 1][j] > maxvalue:\n            maxvalue = states[n - 1][j]\n\n    return maxvalue","category":"page"},{"location":"dataStruc&algo/algo/#树的遍历","page":"-","title":"树的遍历","text":"","category":"section"},{"location":"dataStruc&algo/algo/#Morris-中序遍历","page":"-","title":"Morris 中序遍历","text":"","category":"section"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 mathcalO(1)，其步骤如下，记当前结点为 x：","category":"page"},{"location":"dataStruc&algo/algo/","page":"-","title":"-","text":"如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的有孩子，即 x = x.right；\n如果 x 有左孩子，则找到左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor：\n如果 predecessor 的右孩子为空，则将右孩子指向 x，然后访问 x 的左孩子，即 x = x.left；\n如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将 predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x = x.right；\n重复上述操作，直到访问完整棵树。","category":"page"},{"location":"docker/#Docker-命令","page":"Docker 使用","title":"Docker 命令","text":"","category":"section"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"推荐阅读：Docker 命令大全；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"docker run：命令是创建一个新的容器并且运行一个命令，完整的语法为","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"docker run [OPTIONS] IMAGE [COMMAND] [ARG...]","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"其中 OPTION 可以选参数：","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"-i 以交互模式运行容器，通常与 -t 同时使用；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"-t 为容器分配一个伪输入终端，通常与 -t 同时使用；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"通常都是 -it 这样的","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"--volume, -v 是绑定一个卷；或者说是目录映射；-v 本地目录:容器目录","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"-e 是环境变量；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"例如 -v /data:/data 就是主机的目录 /data 映射到容器的 /data；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"--env-file=[] 从指定文件读入环境变量；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"--ipc=host 是容器间都共享宿主机的内存；","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"登录：docker login 仓库地址 -u 用户名 -p 密码（如果不指定地址则为登录官方仓库）","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"登出：docker logout","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"拉取镜像：docker pull 镜像仓库地址","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"上传镜像：docker push 镜像仓库地址","category":"page"},{"location":"docker/","page":"Docker 使用","title":"Docker 使用","text":"列出容器：docker ps","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"读取文件和保存文件：Input/Output","category":"page"},{"location":"py_module/pandas/#通用函数","page":"-","title":"通用函数","text":"","category":"section"},{"location":"py_module/pandas/#数据操作","page":"-","title":"数据操作","text":"","category":"section"},{"location":"py_module/pandas/","page":"-","title":"-","text":"函数 功能\nmelt(frame[, idvars, valuevars, var_name, ...]) 将 DataFrame 从宽格式转为长格式，可选择设置标识符。\npivot(data, *[, index, columns, values]) 返回由给定索引 / 列值组织的重塑 DataFrame。\npivot_table(data[, values, index, columns, ...]) 创建一个电子表格样式的数据透视表作为 DataFrame。\ncrosstab(index, columns[, values, rownames, ...]) 计算两个（或更多）因子的简单交叉表。\ncut(x, bins[, right, labels, retbins, ...]) 将值分类为离散间隔。\nqcut(x, q[, labels, retbins, precision, ...]) 基于分位数的离散化函数。\nmerge(left, right[, how, on, left_on, ...]) 将 DataFrame 或命名的 Series 对象与数据库样式的连接合并。\nmerge_ordered(left, right[, on, left_on, ...]) 使用可选的填充/插值对有序数据执行合并。\nmerge_asof(left, right[, on, left_on, ...]) 按关键距离执行合并。\nconcat(objs, *[, axis, join, ignore_index, ...]) 沿特定轴连接 pandas 对象。\nget_dummies(data[, prefix, prefix_sep, ...]) 将分类变量转换为虚拟/指标变量。\nfrom_dummies(data[, sep, default_category]) 从虚拟变量的 DataFrame 创建一个分类的 DataFrame。\nfactorize(values[, sort, na_sentinel, ...]) 将对象编码为枚举类型或分类变量。\nunique(values) 根据哈希表返回唯一值。\nwide_to_long(df, stubnames, i, j[, sep, suffix]) 将 DataFrame 从宽格式转为长格式。","category":"page"},{"location":"py_module/pandas/#顶层缺失数据","page":"-","title":"顶层缺失数据","text":"","category":"section"},{"location":"py_module/pandas/","page":"-","title":"-","text":"isna(obj) Detect missing values for an array-like object.\nisnull(obj) Detect missing values for an array-like object.\nnotna(obj) Detect non-missing values for an array-like object.\nnotnull(obj) Detect non-missing values for an array-like object.","category":"page"},{"location":"py_module/pandas/#Pandas-常用操作","page":"-","title":"Pandas 常用操作","text":"","category":"section"},{"location":"py_module/pandas/","page":"-","title":"-","text":"读取 CSV 文件：pd.DataFrame.from_csv(\"csv_file\") 或者 pd.read_csv(\"csv_file\")；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"读取 Excel 文件：pd.read_excel(\"excel_file\")","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"将 DataFrame 保存为 CSV 文件：采用逗号作为分隔符，且不带索引：df.to_csv(\"data.csv\", sep=',', index=False)；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"获得基本的数据集特征信息：df.info()；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"基本的数据集统计信息：df.describe()；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"将 DataFrame 输出到一张表：print(tabulate(print_table, headers=headers))，当 print_table 是一个列表，其中列表元素还是新的列表，headers 为表头字符串组成的列表；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"列出所有列的名字：df.columns；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"删除缺失数据：df.dropna(axis=0, how='any') 返回一个 DataFrame，其中删除了包含任何 NaN 值的给定轴，选择 how = 'all' 会删除所有元素都是 NaN 的给定轴；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"替换缺失数据：df.replace(to_replace=None, value=None)，使用 value 值替代 DataFrame 中的 to_replace 值，其中 value 和 to_replace 都需要我们赋予不同的值；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"检查空值 NaN：pd.isnull(object) 即数值数组中的 NaN 和目标数组中的 None/NaN；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"删除特征：df.drop('feature_variable_name', axis=1)，axis 为 0 表示选择行，1 表示选择列；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"将目标类型转换为浮点型：pd.to_numeric(df[\"feature_name\"], errors='coerce') 将目标类型转化为数值从而进一步执行计算，在这个案例中为字符串；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"将 DataFrame 转换为 NumPy 数组：df.as_matrix()；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"查看 DataFrame 的前 n 行：df.head(n)；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"查看 DataFrame 的后 n 行：df.tail(n)；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"通过特征名取数据：df.loc[feature_name]；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"对 DataFrame 使用函数：df[\"height\"].apple(lambda: height: 2 * height) 将 height 行的所有值乘上 2；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"重命名行：df.rename(column={df.columns[2]: 'size'}, inplace=True) 将第三行重命名为 size；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"取某一行的唯一实体：df[\"name\"].unique() 取 name 行的唯一实体；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"访问子 DataFrame：new_df = df[[\"name\", \"size\"]] 抽取行 name 和 size；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"总结数据信息：总和 df.sum()，最小值 df.min()，最大值 df.max()，最小值的索引位置 df.idxmin()，最大值的索引位置 df.idxmax()，统计数据 df.describe()，均值 df.mean()，中值 df.median()，相关系数 df.corr()，这些函数都可以对单独数据行进行；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"给数据排序：df.sort_values(ascending=False)；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"布尔型索引：df[df[\"size\"] == 5] 选择 size 行中值等于 5 的行；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"选特定的值：df.loc([0], ['size']) 选的 size 列第一行数据；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"沿着一条轴将多个对象堆叠到一起：pd.concat()；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"关系型数据库的连接方式：pd.merge() 根据一个或多个键将不同的 DataFrame 连接起来。针对同一个主键存在两张不同字段的表，根据主键整合到一张表里；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"用于索引上的合并：pd.join()","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"纵向追加：pd.append()","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"转换字符串时间为标准时间：pd.to_datetime(df['time'])；","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"提取时间序列信息：df['time'].year()","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"加减时间：df['time'] + pd.Timedelta(days=1) 或者 df['time'] - pd.to_date_time('2016-1-1')","category":"page"},{"location":"py_module/pandas/","page":"-","title":"-","text":"时间跨度计算","category":"page"},{"location":"AI/ML/#特征工程","page":"机器学习","title":"特征工程","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓问：为什么要对特征做归一化处理？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"特征归一化、标准化，是数据预处理中的重要技术。特征间的单位（尺度）可能不同，变化范围也可能是不同的，在进行距离有关的计算时，尺度大的特征会起决定性的作用，而尺度小的特征可能会被忽略，为了消除特征间单位和尺度差异的影响，要对特征做归一化处理。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓问：「类别型特征」的编码方式有哪些？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"序号编码（Ordinal Encoding）：通常用于处理类别间具有大小关系的数据，转换后依然保留相对的大小关系。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"独热编码（One-hot Encoding）：通常用于处理类别间不具有大小关系的特征。对于类别取值较多的情况下使用 One-hot Encoding 需要注意以下问题：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"使用稀疏向量来节省空间。\n配合特征选择来降低维度。高维度特征会带来几方面的问题：\n在 K 近邻算法中，高维度空间下两点之间的距离很难得到有效的衡量；\n在逻辑回归模型中，参数的数量会随着维度的增高而增加，容易引起过拟合的问题；\n通常只有部分维度是对分类、预测有帮助，因此可以考虑配合特征选择来降低维度；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"二进制编码（Binary Encoding）：先用序号编码给每个类别赋予一个类别 ID，然后将类别 ID 对应的二进制编码作为结果。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Helmert Contrast","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Sum Contrast","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Polynomial Contrast","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Backward Difference Contrast","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓问：什么是组合特征？如何处理高维组合特征？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。在实际问题中，需要面对多种高维特征，简单地两两组合，依然容易存在参数过多、过拟合等问题。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"怎样有效地找到组合特征？可以利用决策树来寻找特征组合方式。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"对于这种「高维组合特征」要如何处理？假设用户和物品的数量分别为 m 和 n，一种行之有效的方法是将两个特征分别用 k 维的低维向量表示（kll mkll n），这样原本 mtimes n 的学习参数就降低为 mtimes k + ntimes k，这其实等价于推荐算法中的矩阵分解。","category":"page"},{"location":"AI/ML/#距离函数","page":"机器学习","title":"距离函数","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"欧氏距离：欧几里得距离，就是平方和开根号。是最常用的一种距离度量，欧氏距离越小，两个向量的相似度越大；欧氏距离越大，两个向量的相似度越小。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"曼哈顿距离：x_1-x_2 + y_1-y_2","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"切比雪夫距离：max(x_1 x_2 y_1 y_2)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓问：什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"对于两个向量 A 和 B，其余弦相似度定义为 cos(AB)=fracABAB，即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小，余弦相似度依然符合「相同为 1，正交为 0，相反为 -1」的性质，其取值范围是 -1 1，欧氏距离衡量空间点的直线距离，余弦距离衡量点在空间的方向差异，欧氏距离体现数值上的绝对差异，余弦距离体现方向上的相对差异。","category":"page"},{"location":"AI/ML/#模型评估","page":"机器学习","title":"模型评估","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓过拟合和欠拟合是啥？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"过拟合：在训练集上表现很好，测试集上表现很差。过拟合会导致高 Variance；\n欠拟合：在训练集上表现很差。欠拟合会导致高 Bias；\n模型需要在 Bias 与 Variance 之间做出一个权衡；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"解决欠拟合的方法：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"增加新特征，可以考虑加入特征组合、高次特征来增大假设空间；\n尝试非线性模型，比如核 SVM、决策树、DNN 等模型；\n如果有正则项可以适当降低正则项参数；\nBoosting 方法往往会有较小的 Bias；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"解决过拟合的方法：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"交叉验证，通过交叉验证得到较优的模型参数；\n减少特征的数量：通过人工选择保留哪些特征或者模型选择算法来降低；\n正则化：降低模型参数的数量；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Holdout 检验","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"交叉检验","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"自助法（Bootstrap）：有放回地从 N 个样本中抽样 n 个样本。当样本规模比较小的时候，将样本集进行划分会让训练集进一步减小，这可能会影响模型训练效果。自助法是基于自助采样的检验方法。在 n 次采样过程中，有的样本会被重复采样，有的样本没有被抽出过，将这些没有被抽出的样本作为验证集，进行模型验证，这就是自助法的验证过程。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"交并比（Intersection over Union，IoU）：交并比 IoU 衡量的是两个区域的重叠程度，是两个区域的交集比上并集。在目标检测任务重，如果模型输出的矩形框与人工标注的矩形框 IoU 值大于某个阈值（通常为 0.5）时，即认为模型输出正确。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"精准率与召回率（Precision & Recall）：在目标检测中，假设有一组图片，Precision 代表我们模型检测出来的目标有多少是真正的目标物体，Recall 就是所有真实的目标有多少比例被模型检测出来了。目标检测中的真正例（True Positive）、真负例（True Negative）、假正例（False Positive）、假负例（False Positive）的定义如下：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":" 实际为正 实际为负\n预测为正 TP FP\n预测为负 FN TN","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"对于这四个指标可以这样去理解，后面的 Positive 和 Negative 以预测的结果为主，因为我们关注的是模型的预测，如果模型的预测与实际的标注不一样，那么这个预测就是「假的」，比如预测为负那么就称为 Negative，但是实际为正，与预测的不一样，那么就是「假的」False，因此这个预测就是 False Negative，这是一个「假的正例」是「错误的正例」。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"精准率，就是在预测为正样本中实际为正样本的概率，也就是所有的 Positive 中 True Positive 的概率","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Precision = fracTPTP+FP","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"召回率，就是在实际为正样本中预测为正样本的概率，就是所有的实际标注为正样本的（TP + FN）预测为正样本的概率（TP）","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Recall = fracTPTP+FN","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"准确率，就是模型预测正确的（所有的 True：TP + TN）占全部的比例","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Accuracy = fracTP+TNTP+TN+FP+FN","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"平均精度（Average precision，AP）：是主流的目标检测模型评价指标，它的意思是不同召回率上的平均精度。我们希望训练好的模型 Precision 和 Recall 都越高越好，但是这两者之间有个矛盾，当 Recall 很小的时候 Precision 可能会很高，当 Recall 很大的时候，Precision 可能会很低。我们将不同 Recall 对应的 Precision 做一个曲线（PR 曲线），然后在这个曲线上计算 Precision 的均值。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"曲线下面积（Area Under Curve，AUC）：","category":"page"},{"location":"AI/ML/#优化算法","page":"机器学习","title":"优化算法","text":"","category":"section"},{"location":"AI/ML/#损失函数总结","page":"机器学习","title":"损失函数总结","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"为了刻画模型输出与样本标签的匹配程度，定义损失函数 L(cdotcdot)Ytimes Yrightarrow mathbbR_ge 0，L(f(x_itheta)y_i) 越小，表明模型在该样本点匹配得越好。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"为了具有更加简介的表达，将网络的输出表示为 f，而实际标签表达为 y。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"在分类问题上常用的损失函数：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）0-1 损失函数：最常用于二分类问题，Y=1-1，我们希望 textttsign f(x_itheta)=y_i，所以 0-1 损失函数为","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_0-1(fy) = 1_fyle 0","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 1_P 是指示函数（Indicator Function），当且仅当 P 为真时取值为 1，否则取值为 0。0-1 损失的优点是可以直观地刻画分类的错误率，缺点是由于其非凸、非光滑的特点，算法很难对该函数进行优化。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）Hinge 损失函数：是 0-1 损失函数相对紧的凸上界，且当 fyge 1 时，函数不对其做任何惩罚。它在 fy=1 处不可导，不能够用梯度下降法进行优化，而是用次梯度下降法（Subgradient Descent Method）。适用于 Maximum-Margin 分类，主要用于支持向量机（SVM）中，用来解间距最大化的问题。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_texthinge(fy)=max01-fy","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（3）感知损失函数（Perceptron Loss）：是 Hinge 损失函数的一个变种。Hinge 对判定边界附近的点（正确端）惩罚力度很高，但是 Perceptron 只要样本的判定类别正确就行，不管其判定边界的距离。它比 Hinge 更加简单，不是 Max-margin Boundary，所以模型的泛化能力没有 Hinge 强。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_textPerceptron=max(0 -f)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（4）Logistic 损失函数：是 0-1 损失函数的凸上界，该函数处处光滑，对所有的样本点都有所惩罚，因此对异常值相对更敏感一点。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_textlogistic(fy)=log_2(1+exp(-fy))","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（5）Log 对数损失函数：即对数似然损失（Log-likelihood Loss），它的标准形式","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_textlog(f(boldsymbolxtheta)y)=-log f_y(boldsymbolxtheta)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 f_y(boldsymbolxtheta) 可以看作真实类别 y 的似然函数。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（6）交叉熵（Cross Entropy）损失函数：对于两个概率分布，一般可以用交叉熵去衡量它们的差异。标签的真实分布 boldsymboly 和模型预测分布 f(boldsymbolxtheta) 之间的交叉熵为","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"mathcalL(f(boldsymbolxtheta)boldsymboly)=-boldsymboly^toplog f(boldsymbolxtheta)=-sum_c=1^Cy_clog f_c(boldsymbolxtheta)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"因为 boldsymboly 为 one-hot 向量，因此交叉熵可以写为","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"mathcalL(f(boldsymbolxtheta)boldsymboly)=-log f_y(boldsymbolxtheta)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 f(boldsymbolxtheta) 可以看作真实类别 y 的似然函数。因此交叉熵损失函数也就是负对数似然函数（Negative Log-Likelihood）。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"在回归问题中常用的损失函数：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）平方损失（Mean Squared Error）函数：在回归问题中最常用的损失函数。对于 Y=mathbbR，我们希望 f(x_itheta)approx y_i","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_textMSE(fy)=(f-y)^2","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）绝对损失（Mean Absolute Error）函数：当预测值距离真实值较远的时候，平方损失函数的惩罚力度大，也就是说它对于异常点比较敏感。如果说平方损失函数是在做均值回归的话，那么绝对损失函数就是在做中值回归，对于异常点更加鲁棒一点。只不过绝对损失函数在 f=y 处无法求导。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_textMAE(fy)=f-y","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（3）Huber 损失函数：也称为 Smooth L1 Loss， 综合考虑可导性和对异常点的鲁棒性。在 f-y 较小的时候为平方损失，比较大的时候为线性损失","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_textHuber(fy)=begincases(f-y)^2qquad f-yle delta 2deltaf-y-delta^2quadf-ydeltaendcases","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（4）Log-Cosh 损失函数：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（5）分位数损失函数：","category":"page"},{"location":"AI/ML/#随机梯度算法","page":"机器学习","title":"随机梯度算法","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"随机梯度下降法本质上是采用迭代方式更新参数，每次迭代在当前位置的基础上，沿着某一方向迈一小步抵达下一位置，不断地重复这个步骤，它的更新公式为","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"theta_t+1=theta_t - eta g_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 eta 是学习率。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"动量（Momentum）方法：类比中学物理知识，当前梯度就好比当前时刻受力产生的加速度，前一次步长 v_t-1 好比前一时刻的速度，当前步长 v_t 好比当前加速度共同作用的结果。这就好比小球有了惯性，而刻画惯性的物理量是动量。模型参数的迭代公式为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"v_t = gamma v_t-1 + eta g_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"theta_t+1 = theta_t - v_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"在这里当前更新步长 v_t 直接依赖于前一次步长 v_t-1 和当前梯度 g_t，衰减系数 gamma 扮演了阻力的作用。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"AdaGrad 方法：在应用中，我们希望更新频率低的参数可以拥有较大的更新步幅，而更新频率高的参数的步幅可以减小，AdaGrad 方法采用「历史梯度平方和」来衡量不同参数的梯度的稀疏性，取值越小表明越稀疏。AdaGrad 借鉴了 mathscrl_2 正则化的思想，每次迭代时自适应地调整每个参数的学习率。这样的方式保证了不同的参数有具有自适应学习率。具体的更新公式表示为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"在第 t 次迭代时，先计算每个参数梯度平方的累计值","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"G_t = sum_tau=1^t boldsymbolg_tau odot boldsymbolg_tau","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 odot 为按元素乘积，boldsymbolg_tauin mathbbR^theta 是第 tau 次迭代时的梯度。参数更新差值为","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Deltatheta_t=-fracetasqrtG_t+epsilonodotboldsymbolg_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 alpha 是初始学习率，epsilon 是为了保持数值稳定性而设定的非常小的常数，一般取值为 e^-7sim e^-10。分母中求和的形式实现了退火过程，意味着随着时间推移，学习速率 fracetasqrtG_t+epsilon 越来越小，保证算法的最终收敛。在 AdaGrad 算法中，如果某个参数的偏导数积累比较大，其学习率相对较小；相反如果其偏导数积累较小，其学习率相对较大，但整体是随着迭代次数的增加，学习率逐渐变小。","category":"page"},{"location":"AI/ML/#Adam-算法","page":"机器学习","title":"Adam 算法","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Adam 算法的全称是自适应动量估计算法（Adaptive Moment Estimation Algorithm），它将惯性保持和自适应两个优点结合，可以看作是动量法和 RMSprop 算法（或者 AdaGrad 算法）的结合。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"它一方面记录梯度的一阶矩（First Moment）M_t，即过往梯度与当前梯度的平均，理解为「惯性」，是梯度 boldsymbolg_t 的指数加权平均。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"另一方面记录梯度的二阶矩（Second Moment）G_t，即过往梯度平方与当前梯度平方的平均，理解为「自适应部分」，是梯度 boldsymbolg_t^2 的指数加权平均。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"一阶矩可以理解为均值；二阶矩可以理解为未减去均值的方差","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"M_t = beta_1 M_t-1 + (1 - beta_1)boldsymbolg_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"G_t = beta_2 G_t-1 + (1 - beta_2)boldsymbolg_todotboldsymbolg_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 beta_1 和 beta_2 分别为两个移动平均的衰减率，通常取值为 beta_1 = 09, beta_2 = 099. ","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Adam 算法考虑了 M_t G_t 在零初始情况下的偏置矫正。假设 M_0=0 G_0=0，那么在迭代初期 M_t 和 G_t 的值会比真实的均值和方差要小，特别是当 beta_1 和 beta_2 都接近于 1 时，偏差会很大。具体来说，Adam 算法的更新公式为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"hatM_t = fracM_t1 - beta_1^t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"hatG_t = fracG_t1 - beta_2^t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Deltatheta_t = -fracalphasqrthatG_t + epsilon hatM_t","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中学习率 alpha 通常设为 0.001，并且也可以进行衰减，比如 alpha_t=alpha_0sqrtt. ","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Adam 算法的物理意义：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"《百面机器学习》163 页","category":"page"},{"location":"AI/ML/#逐层归一化","page":"机器学习","title":"逐层归一化","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"逐层归一化（Layer Normalization）是将传统机器学习中的数据归一化方法应用到深度神经网络中，对神经网络中隐藏的输入进行归一化，使得网络更容易训练。常用的逐层归一化方法有：批量归一化、层归一化、权重归一化和局部响应归一化。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"内部协变量偏移（Internal Covariate Shift）：当使用随机梯度下降来训练网络时，每次参数更新都会导致该神经层的输入分布发生改变，越高的层，其输入分布会改变得越明显。从机器学习角度来看，如果一个神经层的输入分布发生了改变，那么其参数需要重新学习。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"逐层归一化的能够提高训练效率的原因：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）更好的尺度不变性：把每个神经层的输入分布都归一化为标准正态分布，可以使得每个神经层对其输入具有更好的尺度不变性。不论低层的参数如何变化，高层的输入保持相对稳定。另外，尺度不变性可以使得我们更加高效地进行参数初始化以及超参选择。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）更平滑的优化地形：逐层归一化一方面可以使得大部分神经层的输入处于不饱和区域，从而让梯度变大，避免梯度消失问题；另一方面还可以使得神经网络的优化地形（Optimization Landscape）更加平滑，以及使梯度变得更加稳定，从而允许我们使用更大的学习率，并提高收敛速度。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"批量归一化（Batch Normalization，BN）方法 是一种有效的逐层归一化方法，可以对神经网络中任意的中间层进行归一化操作。假设神经网络第 l 层的净输入为 boldsymbolz^(l)，神经元输出为 boldsymbola^(l)，即","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"boldsymbola^(l) = f(boldsymbolz^(l))=fleft( boldsymbolWboldsymbola^(l) + boldsymbolb right)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 f(cdot) 是激活函数，boldsymbolW boldsymbolb 是神经网络的参数。为了提高优化效率，就要使得净输入 boldsymbolz^(l) 的分布一致，比如都归一化到标准正态分布。归一化操作一般应用在仿射变换（Affine Transformation）boldsymbolWboldsymbola^(l)+boldsymbolb 之后，激活函数之前。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"为了提高归一化效率，一般使用标准化将净输入 boldsymbolz^(l) 的每一维都归一化到标准正态分布","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"hatboldsymbolz^(l) = fracboldsymbolz^(l)-mathbbEboldsymbolz^(l)sqrttextvar(boldsymbolz^(l))+epsilon","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 mathbbEboldsymbolz^(l) 和 textvar(boldsymbolz^(l)) 是当前参数下 boldsymbolz^(l) 的每一维在整个训练集上的期望和方差。","category":"page"},{"location":"AI/ML/#决策树与集成学习","page":"机器学习","title":"决策树与集成学习","text":"","category":"section"},{"location":"AI/ML/#决策树（Decision-Tree）","page":"机器学习","title":"决策树（Decision Tree）","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"一颗决策树包含一个根结点、若干个内部结点和若干个叶结点；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"叶结点对应于决策结果，其他每个结点则对应于一个属性测试；\n每个结点包含的样本集合根据属性测试的结果被划分到子结点中；\n根结点包含样本全集；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"决策树的生成是一个递归过程，遵循「分治策略」（divide-and-conquer）。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"决策树基本算法中导致递归返回的三种情况：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"当前结点包含的样本全部属于同一个类别；\n当前属性集为空，或是所有样本在所有属性上取值相同，无法划分。在这种情况下，把当前结点标记为叶结点，并将其类别设定为该结点所含样本最多的类别。这相当于利用了当前结点的后验分布；\n当前结点包含的样本集合为空，不能划分。在这种情况下，同样把当前结点标记为叶结点，但将其类别设定为其父结点所含样本最多的类别；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"信息熵（Information Entropy）：是度量样本集合纯度最常用的一种指标。假定当前样本集合 D 中第 k 类样本所占的比例为 p_k (k=12dotsmathcalY)，则 D 的信息熵为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"textEnt(D)=-sum_k=1^mathcalYp_klog_2p_k","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"如果 textEnt(D) 的值越小，则 D 的纯度越高，纯度越高说明包含的信息量越少。textEnt(D)in0log_2mathcalY.","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"注意：计算信息熵时约定，若 p=0，则 plog_2p=0，这与极限一致 lim_prightarrow 0^+plog p=0。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"信息增益（Information Gain）：一般而言，信息增益越大，表示用属性 a 来进行划分所获得的「纯度提升」越大。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"假定离散属性 a 有 V 个可能的取值 a^1 a^2dotsa^V，如果使用 a 来对样本集 D 进行划分，则会产生 V 个分支结点，其中第 v 个分支结点包含了 D 中所有在属性 a 上取值为 a^v 的样本，记为 D^v.","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"因此用属性 a 对样本集 D 进行划分所获得的信息增益为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"textGain(D a)=textEnt(D)-sum_v=1^VfracD^vDtextEnt(D^v)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中考虑到不同的分支结点所包含的样本数不同，给分支结点赋予权重 D^vD，表示样本数越多的分支结点的影响越大。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"著名的决策树算法 ID3（Iterative Dichotomiser，迭代二分器）就是以信息增益为准则来选择划分属性的。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"以信息增益作为准则来生成决策树有一个缺点，就是信息增益对可取值数目较多的属性有更大的偏好，一个更好的方法就是使用「增益率」（Gain Ratio）来选择最优划分属性，著名的 C4.5 决策树算法就利用增益率来生成决策树。增益率的定义为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"textGain_ratio(D a)=fractextGain(D a)textIV(a)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"textIV(a)=-sum_v=1^VfracD^vDlog_2fracD^vD","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"称为属性 a 的「固有值」（intrinsic value），属性 a 的可能取值书目越多，V 就会越大，textIV(a) 的值通常就会越大。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"但是增益率准则带来的一个缺点又变成了对可取值数目较少的属于更加偏好，因此 C4.5 算法并不直接选择增益率最大的候选划分属性，它的具体做法是：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的属性作为「最优划分属性」。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"基尼指数（Gini index）：反映了从数据集 D 中随机抽取两个样本，其类别标记不一致的概率。因此 textGini(D) 越小，则数据集 D 的纯度越高。属性 a 的基尼指数定义为：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"textGini_index(D a)=sum_v=1^VfracD^vDtextGini(D^v)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"在候选属性集合 A 中，选择那个使得划分后基尼指数最小的属性作为划分属性。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"CART 决策树（Classification and Regression Tree）就是使用基尼指数来选择划分属性的。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"剪枝（pruning）是决策树学习算法对付「过拟合」的主要手段，基本策略有「预剪枝」（pre-pruning）和「后剪枝」（post-pruning）。","category":"page"},{"location":"AI/ML/#Boosting-与-Bagging","page":"机器学习","title":"Boosting 与 Bagging","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"机器学习问题的两种策略：一种是研发人员尝试各种模型，选择其中表现最好的模型，做重点调参优化；另一种是将多个分类器的结果统一成一个最终的决策，其中每个单独的分类器称为基分类器，使用这类策略的机器学习方法统称为集成学习。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"集成学习分为 Boosting 和 Bagging 两种。Boosting 方法训练基分类器时采用串行方式，各个基分类器之间有依赖。它的基本思路是将基分类器层层叠加，每一层在训练的时候，对前一层基分类器分错的样本，给予更高的权重。测试时，根据各层分类器的结果的加权得到最终结果。Bagging 与 Boosting 的串行训练方式不同，Bagging 方法在训练过程中，各基分类器之间无强依赖，可以进行并行训练。最著名的算法之一就是基于决策树基分类器的随机森林（Random Forest）。Bagging 方法更像是一个集体决策的过程，每个个体都进行单独学习，在最终做决策时，每个个体单独做出判断，再通过投票的方式做出最后的集体决策。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"基分类器，有时候又被称为弱分类器。基分类器的错误，是偏差和方差两种错误之和。偏差主要是由于分类器的表达能力有限导致的系统性错误，表现在训练误差不收敛，方差是由于分类器对于样本分布过于敏感，导致在训练样本数较少时，产生过拟合。而 Boosting 方法通过逐步聚焦于基分类器分错的样本，减小集成分类器的偏差。Bagging 方法则是采取分而治之的策略，通过对训练样本多次采样，并分别训练出多个不同模型，然后做综合，来减小集成分类器的方差。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"最常用的基分类器是决策树：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"决策树可以较为方便地将样本的权重整合到训练过程当中，而不需要使用过采样的方法来调整样本权重；\n决策树的表达能力和泛化能力，可以通过调节树的层数来做折中；\n数据样本的扰动对于决策树的影响较大，因此不同子样本集合生成的决策树基分类器随机性较大，这样的「不稳定学习期」更适合作为基分类器。（在这个点上，神经网络也因为不稳定性而适合作为基分类器，可以通过调节神经元数量、连接方式、网络层数、初始权值等方式引入随机性）；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"集成学习的基本步骤。集成学习一般可以分为以下 3 个步骤：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）找到误差互相独立的基分类器；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）训练基分类器；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（3）合并基分类器的结果；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"合并基分类器的方法有 voting 和 stacking 两种，前者对应 Bagging 方法，后者对应 Boosting 方法。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"以 Adaboost 为例，其基分类器的训练和合并的基本步骤如下：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）确定基分类器：可以选择 ID3 决策树作为基分类器。虽然任何分类模型都可以作为基分类器，但树形模型由于结构简单且较为容易产生随机性所以比较常用。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）训练基分类器：假设训练集为 x_iy_ii=1dotsN，其中 y_iin-11，并且有 T 个基分类器，则可以按照如下过程来训练基分类器：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"初始化采样分布 D_1(i)=1N；\n令 t=12dotsT 循环：\n从训练集中，按照 D_t 分布，采样出子集 S_i=x_iy_ii=1dotsN；\n用 S_i 训练出基分类器 h_t；\n计算基分类器 h_t 的错误率：\nvarepsilon_t=fracsum_i=1^N_tIh_t(x_i)neq y_iD_i(x_i)N_t\n其中 Icdot 为判别函数；\n计算基分类器 h_t 权重 a_t=logfrac(1-varepsilon_t)varepsilon_t，这里可以看到错误率 varepsilon_t 越大，基分类器的权重 a_t 就越小；\n设置下一次采样：\nD_t+1=begincasesD_t(i) text or  fracD_t(i)(1-varepsilon_t)varepsilon_t  h_t(x_i)neq y_i\nfracD_t(i)varepsilon_t(1-varepsilon_t)  h_t(x_i)= y_iendcases","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（3）合并基分类器：给定一个未知样本 z，输出分类结果为加权投票的结果 textSign(sum_t=1^Th_t(z)a_t).","category":"page"},{"location":"AI/ML/#梯度提升决策树（GBDT）","page":"机器学习","title":"梯度提升决策树（GBDT）","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓GBDR 和 RF 有什么区别？","category":"page"},{"location":"AI/ML/#XGBoost","page":"机器学习","title":"XGBoost","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"XGBoost 是陈天奇等人开发的一个开源机器学习项目，高效地实现了 GBDT 算法并进行了算法和工程上的许多改进，被广泛应用在 Kaggle 竞赛以及其他许多机器学习竞赛中。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"XGBoost 本质上还是一个 GBDT（Gradient Boosting Decision Tree），只是把速度和效率发挥到极致，所以前面加上了 X（代表 Extreme）。原始的 GBDT 算法基于经验损失函数的负梯度来构造新的决策树，只是在决策树构建完成后再进行剪枝。XGBoost 在决策树构建阶段就加入了正则项，即","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_t=sum_i lleft(y_i F_t-1(x_i)+f_t(x_i)right)+Omega(f_t)","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 F_t-1(x_i) 表示现有的 t-1 棵树最优解，树结构的正则项定义为","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Omega(f_t)=gamma T+frac12lambdasum_j=1^Tw^2_j","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"其中 T 为叶子节点个数，w_j 表示第 j 个叶子节点的预测值。对该损失函数在 F_t-1 处进行二阶泰勒展开可以推导出","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"L_tapproxoversetsimL_t=sum_j=1^TleftG_jw_j+frac12(H_j+lambda)w^2_jright+gamma T","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"从所有的树结构中寻找最优的树结构是一个 NP-hard 问题，在实际中往往采用贪心法来构建出一个次优的树结构，基本思想是根据特定的准则选取最优的分裂。不同的决策树算法采用不同的准则，如 IC3 算法采用信息增益，C4.5 算法为了克服信息增益中容易偏向取值较多的特征而采用信息增益比，CART 算法使用基尼指数和平方误差，XGBoost 也有特定的准则来选取最优分裂。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓XGBoost 与 GBDT 有什么区别和联系？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）GBDT 是机器学习算法，XGBoost 是该算法的工程实现；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）在使用 CART 作为基分类器时，XGBoost 显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（3）GBDT 在模型训练时只使用了代价函数的一阶导数信息，XGBoost 对代价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（4）传统的 GBDT 采用 CART 作为基分类器，XGBoost 支持多种类型的基分类器，比如线性分类器；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（5）传统的 GBDT 在每轮迭代时使用全部的数据，XGBoost 则采用了与随机森林相似的策略，支持对数据进行采样；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（6）传统的 GBDT 没有设计对缺失值进行处理，XGBoost 能够自动学习出缺失值的处理策略；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"❓XGBoost 如何实现并行化生成树？","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"XGBoost 的并行化：boosting 是一种串行结构，它的并行不是在 tree 粒度上的，而是在特征粒度上的并行。决策树学习最耗时的一个步骤就是对特征的值进行排序（为了确定最佳分割点）。XGBoost 训练之前，预先对数据进行排序，保存为 block 结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个 block 结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"XGBoost 的特点：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"传统的 GBDT 以 CART 作为基函数，而 XGBoost 相当于有 L1/L2 正则化项的分类或者回归\n传统的 GBDT 在优化的时候只用到一阶导数，XGBoost 对代价函数进行了二阶泰勒展开，同时用到一阶和二阶导数。并且 XGBoost 工具支持自定义代价函数，只要函数可以一阶和二阶求导；\nXGBoost 在代价函数里加入了正则项，控制模型复杂度。正则项里包含了树的叶节点个数、每个叶子节点上输出 score 的 L2 模的平方和。从 Bias-variance tradeoff 角度来讲，正则项降低了模型 variance，使学习出来的模型更加简单，防止过拟合，这也是 XGBoost 优于传统 GBDT 的一个特性。 剪枝是都有的，叶子节点输出 L2 平滑是新增的；\nshrinkage 缩减和 column subsampling。shrinkage 缩减：类似于学习速率，在每一步 tree boosting 之后增加了一个参数 n（权重），通过这种方式来减小每棵树的影响力，给后面的树提供空间去优化模型。column subsampling：列（特征）抽样，随机森林那边学习来的，防止过拟合的效果比传统的行抽样还好（行抽样功能也有），并且有利于后面提到的并行化处理算法；\nsplit finding algorithms（划分点查找算法），树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法 greedy algorithm 枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以 XGBoost 还提出了一种可并行的近似直方图算法（Weighted Quantile Sketch），用于高效地生成候选的分割点；\n对缺失值的处理。对于特征的值有缺失的样本，XGBoost 可以自动学习出它的分裂方向。 稀疏感知算法 Sparsity-aware Split Finding；\n内置交叉验证（Built-in Cross-Validation），XGBoost 可以在 boosting 过程的每次迭代中运行交叉验证，因此很容易在一次运行中获得准确的最佳 boosting 迭代次数；\nXGBoost 支持并行，提高计算速度；","category":"page"},{"location":"AI/ML/#LightGBM","page":"机器学习","title":"LightGBM","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"LightGBM 是 XGBoost 的更高效实现，由微软发布。LightGBM 相比于 Xgboost，添加了很多新的方法来改进模型，包括：并行方案、基于梯度的单边检测（GOSS）、排他性特征捆绑等。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"LightGBM 的设计思路主要是两点：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"减小数据对内存的使用，保证单个机器在不牺牲速度的情况下，尽可能地用上更多的数据；\n减小通信的代价，提升多机并行时的效率，实现在计算上的线性加速。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"由此可见，LightGBM 的设计初衷就是提供一个快速高效、低内存占用、高准确度、支持并行和大规模数据处理的数据科学工具。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"LightGBM 并没有垂直的切分数据集，而是每个 worker 都有全量的训练数据，因此最优的特征分裂结果不需要传输到其他 worker 中，只需要将最优特征以及分裂点告诉其他 worker，worker 随后本地自己进行处理。处理过程如下：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"每个 worker 在基于局部的特征集合找到最优分裂特征；\nworker 间传输最优分裂信息，并得到全局最优分裂信息；\n每个 worker 基于全局最优分裂信息，在本地进行数据分裂，生成决策树；","category":"page"},{"location":"AI/ML/#其他知识","page":"机器学习","title":"其他知识","text":"","category":"section"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"HMM：EM 算法、维特比算法、前向后向算法、极大似然估计","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"在 HMM 中，如果已知观察序列和产生观察序列的状态序列，可以用极大似然估计进行阐述估计。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"EM 算法只有观测序列，无状态序列时来学习模型参数，即 Baum-Welch 算法。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"维特比算法是用动态规划解决 HMM 的预测问题的，不是参数估计。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"前向后向算法是用来计算概率的。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"极大似然估计是观测序列和相应序列都存在时的监督学习算法，用来进行阐参数估计。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"序列模式挖掘算法、AprioriAll 算法、GSP 算法、FreeSpan 算法、PrefixSpan 算法","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"Apriori 算法：关联分析原始算法，用于从候选项集中发现频繁项集。两个步骤：进行自连接、进行剪枝。缺点：无时序先后性。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"AprioriAll 算法：AprioriAll 算法与 Apriori 算法的执行过程是一样的，不同点在于候选集的产生，需要区分最后两个元素的前后。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"AprioriSome 算法：可以看做是 AprioriAll 算法的改进","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"AprioriAll 算法和 AprioriSome 算法的比较：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（1）AprioriAll 用  去计算出所有的候选 Ck，而 AprioriSome 会直接用  去计算所有的候选 ，因为 包含 ，所以 AprioriSome 会产生比较多的候选。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（2）虽然 AprioriSome 跳跃式计算候选，但因为它所产生的候选比较多，可能在回溯阶段前就占满内存。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（3）如果内存占满了，AprioriSome 就会被迫去计算最后一组的候选。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"（4）对于较低的支持度，有较长的大序列，AprioriSome 算法要好些。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"GPS算法：类Apriori算法。用于从候选项集中发现具有时序先后性的频繁项集。两个步骤：进行自连接、进行剪枝。缺点：每次计算支持度，都需要扫描全部数据集；对序列模式很长的情况，由于其对应的短的序列模式规模太大，算法很难处理。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"SPADE算法：改进的GPS算法，规避多次对数据集D进行全表扫描的问题。与GSP算法大体相同，多了一个IDLIST记录，使得每一次的IDLIST根据上一次的IDLIST得到（从而得到支持度）。而IDLIST的规模是随着剪枝的不断进行而缩小的。所以也就解决了GSP算法多次扫描数据集D问题。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"FreeSpan算法：即频繁模式投影的序列模式挖掘。核心思想是分治算法。基本思想为：利用频繁项递归地将序列数据库投影到更小的投影数据库集中，在每个投影数据库中生成子序列片断。这一过程对数据和待检验的频繁模式集进行了分割，并且将每一次检验限制在与其相符合的更小的投影数据库中。 优点：减少产生候选序列所需的开销。缺点：可能会产生许多投影数据库，开销很大，会产生很多的","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"PrefixSpan 算法：从FreeSpan中推导演化而来的。收缩速度比FreeSpan还要更快些。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"模型过拟合：","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"原因：（1）训练数据太少；（2）模型太复杂；（3）参数过多；（4）噪声过多。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"解决办法：（1）获得更多的训练数据；（2）降低特征维度；（3）正则化；（4）Dropout；（5）早停 Early Stop；（6）数据清洗。","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"参考","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"[1] GitHub 项目：ML-NLP；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"[2] XGBoost 特点、调参、讨论；","category":"page"},{"location":"AI/ML/","page":"机器学习","title":"机器学习","text":"[3] 诸葛越，葫芦娃，《百面机器学习》，中国工信出版集团，人民邮电出版社","category":"page"},{"location":"dataStruc&algo/dataStruc/#数组","page":"-","title":"数组","text":"","category":"section"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"double * array [8];  // array 是一个数组, 数组的每一个元素是指向双精度实型数据的指针\n// double * 为双精度指针类型, 后面的数组为存放双精度指针的数组","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"指针数组 (* strings [])：这个变量是一个数组，这个数组的所有元素都是指针类型。32 位系统中，指针占 4 个字节。","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"数组指针 ((*strings)[])：这个变量是一个指针，这个指针存放着一个数组的首地址，或者这个指针指向一个数组的首地址。","category":"page"},{"location":"dataStruc&algo/dataStruc/#树","page":"-","title":"树","text":"","category":"section"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"二叉树：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"度：结点所拥有的子树的数目称为该节点的度，叶子结点的度为 0。度数为 0 的结点个数比度数为 2 的结点个数多 1，即 n_0=n_2+1. 对于完全二叉树， n_1 为 0 或 1.","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"❓三层的二叉树有多少种？","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"二叉搜索树：中序遍历的序列一定是有序的。","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"满二叉树：结点数 2^k-1，k 为深度","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"哈夫曼树（Huffman Tree）：给定 N 个权值作为 N 个叶子节点，构造一颗二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"树转换为二叉树：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"加线：在所有兄弟结点之间加一条连线；\n抹线：对树中的每一个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；\n旋转：以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明；","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"森林转换为二叉树：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"先把每一棵树转换为二叉树；\n第一棵二叉树不动，从第二课二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来，不断重复直到所有的二叉树都连接起来；","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"二叉树转换为树：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该节点的孩子结点；\n对每一个结点都用第一个规则进行处理；","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"二叉树转换为森林：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"先把每个结点与右孩子结点的连线删除，得到分离的二叉树；\n把分离后的每颗二叉树转换为树；\n整理第 2 步得到的树，得到森林；","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"前缀树（Trie）：又称字典树，LeetCode 题目 208. 实现 Trie (前缀树)【中等】","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"实现 Trie 类：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"Trie() 初始化前缀树对象。每个结点包括以下字段：\n指向子结点的长度为 26 的指针数组 children 每个位置代表对应的小写字母，初始化时全为 None；\n布尔字段 isEnd 表示该节点是否为字符串的结尾；\n插入字符串：void insert(String word) 向前缀树中插入字符串 word 。从 Trie 的根开始，对于当前字符：\n首先指向 Trie 的根结点 node = self：\n子结点存在，沿着指针移动到子结点，继续处理下一个字符；\n子结点不存在，创建一个新的子结点，记录在 children 数组的对应位置上，移动到子结点，继续搜索下一个字符；\n查找单词：boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。从 Trie 的根开始，对于当前字符：\n查找前缀：boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。从 Trie 的根开始，对于当前字符：\n子结点存在：沿着指针移动到子结点，继续搜索下一个字符；\n子结点不存在：说明 Trie 中不包含该前缀，返回 False；","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"「查找单词」和「查找前缀」的区别就是：对于查找单词，如果末尾字符对应结点的 isEnd 为真，那么就代表 Trie 中包含这个单词；\n对于查找前缀，如果搜索到前缀的末尾，则说明字典树中存在该前缀；","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"具体代码参考题解：Python3：实现字典树（Trie）","category":"page"},{"location":"dataStruc&algo/dataStruc/#图","page":"-","title":"图","text":"","category":"section"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"拓扑排序：","category":"page"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"首先选择没有前驱的顶点（入度为 0 的结点），删除与它相关的所有边；\n继续寻找下一个没有前驱的顶点，删除与它相关的所有边；\n不断重复这个寻找和删除的步骤。","category":"page"},{"location":"dataStruc&algo/dataStruc/#问题","page":"-","title":"问题","text":"","category":"section"},{"location":"dataStruc&algo/dataStruc/","page":"-","title":"-","text":"❓连续整数之和为 1000，有几组？","category":"page"},{"location":"CV/contrast/#直方图统计","page":"对比度增强","title":"直方图统计","text":"","category":"section"},{"location":"CV/contrast/#直方图均衡化","page":"对比度增强","title":"直方图均衡化","text":"","category":"section"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"直方图均衡化（Histogram Equalization）可以增强图像对比度，主要的思想就是通过一个映射函数把一副图像的直方图分布变成近视均匀分布来提高图像的对比度，因此关键就是如何得到映射函数。","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"s_k=sum_j=0^k fracn_jn k=012cdots L-1","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"其中，s_k 是当前灰度级经过累积分布函数映射之后的值，n 是图像中像素的总和，n_j 是当前灰度级的像素个数，L 是图像中的灰度级别总数。","category":"page"},{"location":"CV/contrast/#基于空间熵的全局对比度增强（SEGCE）","page":"对比度增强","title":"基于空间熵的全局对比度增强（SEGCE）","text":"","category":"section"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"基于空间熵的灰度全局对比度增强（Spatial Entropy-Based Global Image Contrast Enhancement）通过计算图像的空间熵，得到一个可以拉伸像素值的映射函数，从而提高图像的对比度。","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"假设图像大小为 H times W，每个像素值为 x(i j)，SEGCE 的计算步骤如下：","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"首先将图像 I 分成 M times N = K 个区域，对于每一个子区域 I =  i_1 i_2 dots i_k  计算灰度空间直方图：","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"h_k =  h_k( m n ) mid 1 le m le M 1 le n le N ","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"其中 h_k(m n) 是 dots","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"N = lfloor left( fracKr right)^frac12 rfloor M = lfloor left( Kr right)^frac12 rfloor","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"计算空间熵：","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"S_k = -sum_m-1^Msum_n-1^Nh_k(mn)log_2(h_k(mn))","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"计算离散函数 f_k","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"f_k = fracS_ksum_l=1lneq k^K S_l","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"离散函数 f_k 衡量灰度 k 相比其它灰度级的重要性。计算累计分布函数之前对齐进行归一化","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"f_k = fracf_ksum_l=1^Kf_l","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"计算累计分布函数 F(k)","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"F_k=sum_l=1^kf_l","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"将映射函数拉伸到 0 255，获取映射函数","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"y_k = lfloor F_k(y_u - y_d) + y_d rfloor","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"将原图像素利用映射函数得到新的对比度增强的图像。","category":"page"},{"location":"CV/contrast/#应用","page":"对比度增强","title":"应用","text":"","category":"section"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"问题总结：","category":"page"},{"location":"CV/contrast/","page":"对比度增强","title":"对比度增强","text":"对灰度图计算映射函数，然后使用同一个函数分别对 BGR 三个通道进行计算，效果可以，缺点是会使得画面偏暗；\n对 BGR 三个通道分别计算映射函数，缺点是会导致偏色；","category":"page"},{"location":"#Docs","page":"Home","title":"9Docs","text":"","category":"section"},{"location":"CV/dark_channel_prior/#暗通道先验","page":"暗通道先验去雾","title":"暗通道先验","text":"","category":"section"},{"location":"Linux/#Linux-系统","page":"-","title":"Linux 系统","text":"","category":"section"},{"location":"Linux/","page":"-","title":"-","text":"Linux 系统可以划分为 4 部分：Linux 内核、GNU 工具、图形化桌面环境、应用软件。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"Linux 内核主要负责 4 种功能：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"系统内存管理\n软件程序管理\n硬件设备管理\n文件系统管理","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"常见的 Linux 目录名：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"目录 用途\n/ 虚拟目录的根目录，通常不会在这里放置文件\n/bin 二进制文件目录，存放了很多用户级的 GNU 实用工具\n/boot 引导目录，存放引导文件\n/dev 设备目录，Linux 在其中创建设备节点\n/etc 系统配置文件目录\n/home 主目录，Linux 在其中创建用户目录（可选）\n/lib 库目录，存放系统和应用程序的库文件\n/libname 库目录，存放替代格式的系统和引用程序库文件（可选）\n/media 媒介目录，可移动存储设备的常用挂载点\n/mnt 挂载目录，可用于临时挂载文件系统的常用挂载点\n/opt 可选目录，存放第三方软件包\n/proc 进程目录，存放现有内核，系统以及进程的相关信息\n/root root 用户的主目录（可选）\n/run 运行目录，存放系统的运行时数据\n/sbin 系统二进制文件目录，存放了很多管理级的 GNU 实用工具\n/srv 服务目录，存放本地服务的相关文件\n/sys 系统目录，存放设备、驱动程序以及部分内核特性信息\n/tmp 临时目录，可以在其中创建和删除临时工作文件\n/usr 用户目录，一个次目录层级结构（secondary directory hierarchy）","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"文件系统层级标准（filesystem hierarchy standard, FHS）：常见的 Linux 目录名均基于文件系统层级标准。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"cd [路径]：切换路径。单点号 . 表示当前目录，双点号 .. 表示当前目录的父目录。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"pwd：显示 shell 会话的当前目录。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"列表命令 ls：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"ls -F 可以区分文件和目录。目录名之后会带有 /，在可执行文件之后带有星号 *；\nls -a 可以将以单点号 . 开始的隐藏文件也显示出来；\nls -R 递归显示，可以列出当前目录所包含的子目录中的文件。如果子目录很多输出的内容会变得很长；\nls -l 显示更多的目录和文件信息。例如：drwxr-xr-x. 2 strongnine \t\tstrongnine 6 Feb 20 14:23 Desktop，其中包括的信息有：\n文件类型：目录（d）、文件（-）、链接文件（l）、字符设备（c）、块设备（b）\n文件的权限、文件的硬链接数、文件属主、文件属组、文件大小（以字节为单位）\n文件的上次修改时间、文件名或目录名","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"选项参数可以结合使用，例如 ls -alF。\n如果想查看单个文件的长列表，只需要在 ls -l 命令之后跟上该文件名即可。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"过滤器：就是一个字符串，可以用作简单的文本匹配。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"问号 ? 可以代表过滤器字符串中任意位置的单个字符；\n星号 * 可以用来匹配零个或多个字符；\n方括号 [a-z] 可以指定要匹配的字母或者范围；\n惊叹号 ! 可以将不希望出现的内容排除在外；","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"通配符匹配（globbing）：是指使用通配符进行模式匹配的过程。通配符的正式名称叫做元字符通配符（metacharacter wildcard）。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"创建文件 touch：创建文件并将你的用户名作为该文件的属主。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"touch 可以改变文件的修改时间为当前时间，而且不会改变文件内容。即对一个非空文件夹 touch dir_name 并不会改变文件夹 dir_name 里面的内容。","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"复制文件：基本用法 cp source destination","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"当想要在文件存在时 shell 询问「是否覆盖」，可以加上 -i 命令。通过 y 和 n 来回答；\n用 -R 可以递归地复制整个目录的内容；","category":"page"},{"location":"Linux/#Linux-基本命令","page":"-","title":"Linux 基本命令","text":"","category":"section"},{"location":"Linux/","page":"-","title":"-","text":"创建文件夹：mkdir 可以创建一级目录，如果要创建更深的目录（碰到不存在的文件夹自动创建可以使用 mkdir -p）","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看权限：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看文件权限：ls -l\n查看所在文件夹权限：ls -ld\n修改文件夹权限：chmod xxx dir/file 其中 xxx 不同的数字代表不同的权限\n600 只有所有者有读和写的权限；644 所有者有读和写的权限，组用户只有读的权限；700 只有所有者有读和写以及执行的权限；666 每个人都有读和写的权限；777 每个人都有读和写以及执行的权限；","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"移动文件或者目录：mv 原路径 目标路径","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"复制文件：cp 原路径 目标路径","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看 CUDA 和 cuDNN 的版本：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"1、方法一：查看 CUDA 版本 nvcc --version 或 nvcc -V；方法二：cat /usr/local/cuda/version.json","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"2、查看 cuDNN 版本：cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"修改 /tmp 目录：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"仅对当前终端有效：··","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"$ mkdir -p $HOME/tmp  # 在 HOME 目录创建一个 tmp 文件夹\n$ export TMPDIR=$HOME/tmp  # 指定","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"永久生效：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"$ mkdir -p $HOME/tmp\n$ echo \"export TMPDIR=$HOME/tmp\" >> ~/.bashrc\n$ source ~/.bashrc","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"ncdu","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看文件大小：https://blog.51cto.com/u_14691718/3432088","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"创建软连接：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看已经挂载的硬盘：df -T，其中 -T 表示显示文件类型","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看磁盘占用情况：df -h","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看所有被系统识别的磁盘：fdisk -l","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"挂载 device 到 dir：mount -t <type> <device> <dir>","category":"page"},{"location":"Linux/#终端复用器-Tmux","page":"-","title":"终端复用器 Tmux","text":"","category":"section"},{"location":"Linux/","page":"-","title":"-","text":"推荐阅读：Tmux 使用教程","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"Tmux 是一个终端复用器（terminal multiplexer），在不同系统上安装的方式如下：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"# Ubuntu 或 Debian\n$ sudo apt-get install tmux\n\n# CentOS 或 Fedora\n$ sudo yum install tmux\n\n# Mac\n$ brew install tmux","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"输入 tmux 就可以开始使用，输入 exit 或者 Ctrl + d 就可以退出 Tmux 窗口：","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"新建一个指定名字的会话：tmux new -s <session-name>","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"重新接入某个已存在的会话：tmux attach -t <session-name>","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"将当前会话与窗口分离：tmux detach 或者 快捷键 Ctrl + b, d","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"查看当前所有的 Tmux 会话：tmux ls 或者 tmux attach -t <session-name>","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"关掉某个会话：tmux kill-session -t 0 或者 tmux kill-session -t <session-name>","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"切换会话：tmux switch -t <session-name>","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"重命名会话：tmux rename-session -t 0 <new-name>","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"重命名当前窗口：tmux rename-window <new-name>","category":"page"},{"location":"Linux/#段错误","page":"-","title":"段错误","text":"","category":"section"},{"location":"Linux/","page":"-","title":"-","text":"https://komodor.com/learn/sigsegv-segmentation-faults-signal-11-exit-code-139/","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"https://tldp.org/FAQ/sig11/html/index.html","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"https://stackoverflow.com/questions/26521401/segmentation-fault-signal-11","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"https://github.com/JuliaLang/julia/issues/35005","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"https://discourse.julialang.org/t/signal-11-segmentation-fault-11-with-differentialequations-jl/23264","category":"page"},{"location":"Linux/","page":"-","title":"-","text":"https://github.com/JuliaLang/julia/issues/31758","category":"page"},{"location":"Qt/#问题总结","page":"-","title":"问题总结","text":"","category":"section"},{"location":"Qt/#「欢乐斗地主」项目","page":"-","title":"「欢乐斗地主」项目","text":"","category":"section"},{"location":"Qt/","page":"-","title":"-","text":"课程地址：大丙课程；用手机登录；","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"Bug：Undefined symbols for architecture arm64，完整的报错信息：","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"设备：MacBook Pro Apple M1","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"系统：macOS Ventura 13.0","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"Qt Creator：Qt Creator 9.0.0 Based on Qt 6.4.1 (Clang 13.0 (Apple), arm64)","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"Qt：Qt 6.4.0","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"Undefined symbols for architecture arm64:\n  \"Player::prepareCallLord()\", referenced from:\n      vtable for Player in moc_player.o\n  \"Player::preparePlayHand()\", referenced from:\n      vtable for Player in moc_player.o\nld: symbol(s) not found for architecture arm64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nmake: *** [Landlords.app/Contents/MacOS/Landlords] Error 1\n23:00:12: The process \"/usr/bin/make\" exited with code 2.\nError while building/deploying project Landlords (kit: Desktop (arm-darwin-generic-mach_o-64bit))\nWhen executing step \"Make\"","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"尝试 1：有可能是因为 Qt 版本的原因，项目视频里面是用 5.15.2 的版本。","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"先试着链接 https://www.cnblogs.com/wqcwood/p/15138983.html 中的方法：","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"做到 make -j15 这一步的时候报错了；","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"尝试 2：使用 BrewHome 安装了 Qt 5.15.7，设置 Qt mkspec 路径 /opt/homebrew/opt/qt@5/mkspecs/linux-g++，编译的时候出现报错：","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"make: *** [scorepanel.o] Error 1\nmake: *** Waiting for unfinished jobs....\nIn file included from ../Landlords/userplayer.cpp:1:\nIn file included from ../Landlords/userplayer.h:4:\nIn file included from ../Landlords/player.h:4:\nIn file included from /opt/homebrew/Cellar/qt@5/5.15.7/lib/QtCore.framework/Headers/QObject:1:\n/opt/homebrew/Cellar/qt@5/5.15.7/lib/QtCore.framework/Headers/qobject.h:46:10: fatal error: 'QtCore/qobjectdefs.h' file not found\n#include <QtCore/qobjectdefs.h>\n         ^~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\n1 error generated.\nmake: *** [cardpanel.o] Error 1\nmake: *** [main.o] Error 1\n1 error generated.\nmake: *** [robot.o] Error 1\n1 error generated.\nmake: *** [player.o] Error 1\n1 error generated.\nmake: *** [userplayer.o] Error 1\n1 error generated.\nmake: *** [gamecontrol.o] Error 1\n11:46:07: The process \"/usr/bin/make\" exited with code 2.\nError while building/deploying project Landlords (kit: Desktop (arm-darwin-generic-mach_o-64bit))\nWhen executing step \"Make\"","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"尝试 3：应该是虚函数没有定义。","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"如果是基类声明了一个虚函数，但是没有为其定义函数体，那么就会出现这个错误；","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"因此有两个修改的方式：","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"第一个方法：就是将 Player.h 头文件中的虚函数写成纯虚函数 virtual void prepareCallLord() = 0;，只需要在后面令虚函数等于 0 就是纯虚函数；\n第二个方法：在 Player.cpp 源文件中为虚函数定义一个空的函数体；","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"❓为什么 Qt Creator 里「Design（设计）」的按钮是灰色的？","category":"page"},{"location":"Qt/","page":"-","title":"-","text":"如果选中的文件不是一个可以使用 Design 的类型的，那么就无法进行设计。一般是后缀为 ui 的文件可以，放在 Forms 目录里面，双击选中这个文件就会跳出 Design 的界面了。","category":"page"},{"location":"AI/dataAnaly/#数据分析基本知识","page":"-","title":"数据分析基本知识","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：常用的 Python 库有哪些？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"NumPy：矩阵运算；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Scikit-learn（sklearn）：常用机器学习和数据挖掘工具库；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"SciPy：基于 NumPy 做高效的数学计算，如积分、线性代数、稀疏矩阵等；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Pandas：将数据用表的形式进行操作；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Matplotlib：数据可视化工具；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"seaborn：数据可视化工具；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Keras、TensorFlow、Theano：深度学习工具包；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"NLTK：自然语言处理工具包；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"beautifulsoap：网页文档解析工具；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：数据预处理过程有哪些？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"缺失值处理：删除、插入\n异常值处理\n特征转换：时间特征 sin 化表示\n标准化：最大最小标准化、Z 标准化等；\n归一化：对于文本或评分特征，不同样本之间可能有整体上的差异，如 a 文本共 20 个词，b 文本 30000 个词，b 文本中各个维度上的频次都很可能远远高于 a 文本；\n离散化：one-hot、分箱等；","category":"page"},{"location":"AI/dataAnaly/#数学知识","page":"-","title":"数学知识","text":"","category":"section"},{"location":"AI/dataAnaly/#参数估计","page":"-","title":"参数估计","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"参数估计是用样本统计量去估计总体的参数。它是统计推断的一种基本形式，是数理统计学的一个重要分支，分为点估计和区间估计两部分。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"参数估计 - 矩估计和极大似然估计概述","category":"page"},{"location":"AI/dataAnaly/#假设检验","page":"-","title":"假设检验","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"置信区间是我们所计算出的变量存在的范围，置信水平就是我们对于这个数值存在于我们计算出的这个范围的可信程度。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"统计学假设检验中 p 值的含义具体是什么？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"例如「有 95% 的把握，真正的数值在我们所计算的范围里」，这里 95% 是置信水平，而计算出的范围，就是置信区间。如果置信度为 95%， 则抽取 100 个样本来估计总体的均值，由 100 个样本所构造的 100 个区间中，约有 95 个区间包含总体均值。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"如何通俗地解释「置信区间」和「置信水平」？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：参数估计和假设检验的区别是什么？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"参数估计和假设检验是统计推断的两个组成部分，它们都是利用样本对总体进行某种推断，但推断的角度不同。参数估计讨论的是用样本估计总体参数的方法，总体参数 mu 在估计前是未知的。而在假设检验中，则是先对 mu 的值提出一个假设，然后利用样本信息去检验这个假设是否成立。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：协方差与相关系数的区别和联系是什么？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"协方差：表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"相关系数：研究变量之间线性相关程度的量，取值范围是 [-1,1]。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"相关系数也可以看成协方差：一种剔除了两个变量量纲影响、标准化后的特殊协方差。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：什么是中心极限定理？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"中心极限定理定义：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（1）任何一个样本的平均值将会约等于其所在总体的平均值。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（2）不管总体是什么分布，任意一个总体的样本平均值都会围绕在总体的平均值周围，并且呈正态分布。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"中心极限定理作用：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（1）在没有办法得到总体全部数据的情况下，我们可以用样本来估计总体。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（2）根据总体的平均值和标准差，判断某个样本是否属于总体。","category":"page"},{"location":"AI/dataAnaly/#降维算法","page":"-","title":"降维算法","text":"","category":"section"},{"location":"AI/dataAnaly/#主成分分析","page":"-","title":"主成分分析","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"主成分分析（PCA）是一种降维方法，思想是将样本从原来的特征空间转化到新的特征空间，并且样本在新特征空间坐标轴上的投影方差尽可能大，这样就能涵盖样本最主要的信息。数据投影的第一大方差在第一个坐标（称为第一主成分）上，第二大方差在第二个坐标（第二主成分）上。PCA 也可以看成是激活函数为线性函数的自动编码机","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"方法：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"特征归一化；\n求样本特征的协方差矩阵 A；\n求 A 的特征值和特征向量，即 AX=lambda X\n将特征值从大到小排列，选择前 K 个，对应的特征向量就是新的坐标轴；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：PCA 为什么要中心化？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"因为要算协方差。单纯的线性变换只是产生了倍数缩放，无法消除量纲对协方差的影响，而协方差是为了让投影后方差最大。","category":"page"},{"location":"AI/dataAnaly/#聚类算法","page":"-","title":"聚类算法","text":"","category":"section"},{"location":"AI/dataAnaly/#K-Means-算法","page":"-","title":"K-Means 算法","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：K-Means 算法原理及改进，遇到异常值怎么办？评估算法的指标有哪些？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"原理：在给定 K 值和 K 个初始类簇中心点的情况下，把每个点（即数据记录）分到离其最近的类簇中心点所代表的类簇中，所有点分配完毕之后，根据一个类簇内的所有点重新计算该类簇的中心点（取平均值），然后再迭代的进行分配点和更新类簇中心点的步骤，直至类簇中心点的变化很小，或者达到指定的迭代次数。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"改进：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"K-Means++：初始随机点选择尽可能远，避免陷入局部解。方法是 n+1 个中心点选择时，对于离前 n 个点选择到的概率更大；\nmini-batch K-Means：每次只用一个子集做重入类并找到类心（提高训练速度）；\nISODATA：对于难以确定 k 的时候，使用该方法。思路是当类下的样本小时，剔除；类下样本数量多时，拆分；\nkernel K-Means：K-Means 用欧氏距离计算相似度，也可以使用 kernel 映射到高维空间再聚类；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"当 K-Means 遇到异常值时：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"有条件的话使用密度聚类或者一些软聚类的方法先聚类，剔除异常值。不过本来用 K-Means 就是为了快，这么做就有些南辕北辙；\n局部异常因子 LOF：如果点 p 的密度明显小于其领域点的密度，那么点 p 可能是异常值；\n多元高斯分布异常点检测\n使用 PCA 或自动编码机进行异常点检测：使用降维后的维度作为新的特征空间，其降维结果可以认为剔除了异常值的影响（因为过程是保留使投影后方差最大的投影方向）；\nIsolation Forest：基本思路是建立树模型，一个节点所在的树深度越低，说明将其从样本空间划分出去越容易，因此越可能是异常值。是一种无监督的方法，随机选择 n 个sum sample，随机选择一个特征一个值；\nwinsorize：对于简单的，可以对单一维度做上下截取；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"异常点/离群点检测算法 —— LOF；Isolation Forest 算法原理详解；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"评估聚类算法的指标：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"外部法（基于有标注）：Jaccard 系数、纯度；\n内部法（无标注）：内平方和 WSS 和外平方和 BSS；\n此外还要考虑到算法的时间空间复杂度、聚类稳定性等；","category":"page"},{"location":"AI/dataAnaly/#决策树与随机森林","page":"-","title":"决策树与随机森林","text":"","category":"section"},{"location":"AI/dataAnaly/#随机森林","page":"-","title":"随机森林","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"原理：通过构造多个决策树，做 Bagging 来提高泛化能力；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"随机方法：subsample（有放回抽样）、subfeature、低维空间投影；","category":"page"},{"location":"AI/dataAnaly/#数据挖掘","page":"-","title":"数据挖掘","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"数据预处理：将原始数据进行集成、变换、维度规约、数值规约。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"其中 F 是快速性 (Fast)，指系统能在数秒内对用户的多数分析要求做出反应；A是可分析性(Analysis)，指用户无需编程就可以定义新的专门计算，将其作为分析的一部 分，并以用户所希望的方式给出报告；M是多维性(Multi—dimensional)，指提供对数据分析的多维视图和分析；I是信息性(Information)，指能及时获得信息，并且管理大容量信息。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"根据 OLAP 委员会的定义，联机分析处理 OLAP 是「使分析人员、管理人员或执行人员能够从多种角度对从原始数据中转化出来的、能够真正为用户所理解的并真实反映企业维特性的信息进行快速、一致、交互地存取，从而获得对数据的更深入了解的一类软件技术。」它具有 FASMI (Fast Analysis of Shared Multidimensional Information)，即共享多维信息的快速分析的特征。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"1）快速性：指系统能在数秒内对用户的多数分析要求做出反应。用户对 OLAP 的快速反应能力有很高的要求。系统应能在用户要求的时间内对用户的大部分分析要求做出反应，因此就更需要一些技术上的支持，如专门的数据存储格式、大量的事先运算、特别的硬件设计等。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"2）可分析性：指用户无需编程就可以定义新的专门计算，将其作为分析的一部 分，并以用户所希望的方式给出报告；OLAP 系统应能处理与应用有关的任何逻辑分析和统计分析。用户无需编程就可以定义新的专门计算，将其作为分析的一部分，并以用户理想的方式给出报告。用户可以在 OLAP 平台上进行数据分析，也可以连接到其他外部分析工具上，如时间序列分析工具、数据挖掘工具等。 ","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"3）多维性：指提供对数据分析的多维视图和分析。多维性是 OLAP 的关键属性。系统必须提供对数据分析的多维视图和分析，包括对层次维和多重层次维的完全支持。事实上，多维分析是分析企业数据最有效的方法，是 OLAP 的灵魂。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"4）信息性：指能及时获得信息，并且管理大容量信息。不论数据量有多大，也不管数据存储在何处，OLAP 系统应能及时获得信息，并且管理大容量信息。这里有许多因素需要考虑，如数据的可复制性、可利用的磁盘空间、OLAP 产品的性能及与数据仓库的结合度等。 ","category":"page"},{"location":"AI/dataAnaly/#关联规则挖掘","page":"-","title":"关联规则挖掘","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Apriori 算法是在「购物篮分析」中常用的关联规则挖掘算法，在实际工作中需要对数据集扫描多次。2000 年时提出的 FP-Growth 算法只需要扫描两次数据集即可以完成关联规则的挖掘。其主要贡献就是提出了 FP 树和项头表，通过 FP 树减少了频繁项集的存储以及计算时间。Apriori 的改进算法除了 FP-Growth 算法以外，还有 CBA 算法、GSP 算法。","category":"page"},{"location":"AI/dataAnaly/#数据库","page":"-","title":"数据库","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Hive 允许使用类 SQL 语句在 Hadoop 集群上进行读、写、管理等操作；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Spark 是一种与 Hadoop 相似的开源集群计算环境，将数据集缓存在分布式内存中的计算平台，每轮迭代不需要读取磁盘的 IO 操作，从而大幅降低了单轮迭代时间；","category":"page"},{"location":"AI/dataAnaly/#面试问题","page":"-","title":"面试问题","text":"","category":"section"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：给定一个无序数组，怎么样才能合理采样？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"无序数组是相对有序数组而言的，无序数组并不等于随机，因此首先要做的是将无序数组洗牌，得到随机排列。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"对于无序数组，n 个元素能产生 n 种排序。如果洗牌算法能产生 n 种不同的结果，并且这些结果产生的概率相等，那么这个洗牌算法是正确的。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"Jiang_zzz，CSDN：数组的完全随机排列算法","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：行存储和列存储的区别？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"列式数据库更符合人类阅读习惯；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"行存储：传统数据库的存储方式，同一张表内的数据放在一起，插入更新很快。缺点是每次查询即使只涉及几列，也要把所有数据读取；\n列存储：OLAP 等情况下，将数据按照列存储会更加高效，每一列都可以成为索引，投影很高效。缺点是查询是选择完成时，需要对选择的列进行重新组装。\n当核心业务是 OLTP 时，一个行式数据库，再加上优化操作，可能是一个最好的选择。当核心业务是 OLAP 时，一个列式数据库，是更好的选择。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"列式存储和行式存储的区别为什么列存储数据库读取速度会比传统的行数据库快？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：男生点击率增加，女生点击率增加，总体为何减少？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"因为男女的点击率可能有较大差异，同时低点击率群体的占比增大。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"例如原来男性 20 人，点击 1 人；女性 100 人，点击 99 人，总点击率 100/120。现在变成男性 100 人，点击 6 人；女性 20 人，点击 20 人，总点击率 26/120。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：如何不用任何公开参考资料，估算今年新生儿出生数量？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"采用两层模型（人群画像 x 人群转化）：新生儿出生数=sum (各年龄层育龄女性数量times 各年龄层生育比率);\n从数字到数字：如果有前几年新生儿出生数量数据，建立时间序列模型（需要考虑到二胎放开的突变事件）进行预测;\n找先兆指标，如婴儿类用品的新增活跃用户数量 X 表示新生儿家庭用户。X_ntext新生儿_n 为该年新生儿家庭用户的转化率，如 X_2007text新生儿_2007 为 2007 年新生儿家庭用户的转化率。该转化率会随平台发展而发展，可以根据往年数量推出今年的大致转化率，并根据今年新增新生儿家庭用户数量推出今年估计的新生儿数量。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：如果次日用户留存率下降了 5% 该怎么分析？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"首先采用「两层模型」分析：对用户进行细分，包括新老、渠道、活动、画像等多个维度，然后分别计算每个维度下不同用户的次日留存率。通过这种方法定位到导致留存率下降的用户群体是谁。\n对于目标群体次日留存下降问题，具体情况具体分析。具体分析可以采用「内部-外部」因素考虑。\n内部因素分为获客（渠道质量低、活动获取非目标用户）、满足需求（新功能改动引发某类用户不满）、提活手段（签到等提活手段没达成目标、产品自然使用周期低导致上次获得的大量用户短期内不需要再使用等）；\n外部因素采用 PEST 分析（宏观经济环境分析），政治（政策影响）、经济（短期内主要是竞争环境，如对竞争对手的活动）、社会（舆论压力、用户生活方式变化、消费心理变化、价值观变化等偏好变化）、技术（创新解决方案的出现、分销渠道变化等）。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：卖玉米如何提高收益？价格提高多少才能获取最大收益？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"收益 = 单价times 销售量\n，那么我们的策略是提高「单位溢价」或者「提高销售规模」。\n提高单位溢价的方法：\n品牌打造获得长期溢价，但缺陷是需要大量前期营销投入；\n加工商品占据价值链更多环节，如熟玉米、玉米汁、玉米蛋白粉；重定位商品，如礼品化等；\n价格歧视，根据价格敏感度对不同用户采用不同定价。\n销售量=流量times 转化率\n，上述提高单位溢价的方法可能对流量产生影响，也可能对转化率产生影响。\n收益 = 单价times 流量times 转化率\n，短期内能规模化采用的应该是进行价格歧视，如不同时间、不同商圈的玉米价格不同，采取高定价，然后对价格敏感的用户提供优惠券等。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：类比到头条的收益，头条放多少广告可以获得最大收益？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"收益 = 出价times 流量times 点击率times 有效转化率","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"，放广告的数量会提高流量，但会降低匹配程度，因此降低点击率。最大收益是找到这个乘积的最大值，是一个有约束条件的最优化问题。同时参考价格歧视方案，可以对不同的用户投放不同数量的广告。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：APP 激活量的来源渠道很多，怎样对来源渠道变化大的进行预警？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"如果渠道使用时间较长，认为渠道的 APP 激活量满足一个分布，比较可能是正态分布。求平均值和标准差，对于今日数值与均值差大于 3/2/1 个标准差的渠道进行预警。\n对于短期的新渠道，直接与均值进行对比。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：用户刚进来 APP 的时候会选择属性，怎样在保证有完整用户信息的同时让用户流失减少？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"采用技术接受模型（TAM）来分析，影响用户接受选择属性这件事的主要因素有：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"技术接受模型提出了两个主要的决定因素：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"感知的有用性（perceived usefulness），反映一个人认为使用一个具体的系统对他工作业绩提高的程度；\n感知的易用性（perceived ease of use），反映一个人认为容易使用一个具体的系统的程度。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（1）感知有用性：文案告知用户选择属性能给用户带来的好处；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（2）感知易用性：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"关联用户第三方账号（如微博），可以冷启动阶段匹配用户更有可能选择的属性，推荐用户选择。\n交互性做好。","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（3）使用者态度：用户对填写信息的态度","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"这里需要允许用户跳过，后续再提醒用户填写\n告知用户填写的信息会受到很好的保护","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（4）行为意图：用户使用 APP 的目的性，难以控制","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（5）外部变量：如操作时间、操作环境等，这里难以控制","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"❓问：如何识别作弊用户，例如爬虫程序、渠道伪造的假用户？","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"分类问题可以用机器学习的方法去解决，下面是我目前想到的特征：","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（1）渠道特征：渠道、渠道次日留存率、渠道流量以及各种比率特征；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（2）环境特征：设备（一般伪造假用户的工作坊以低端机为主）、系统（刷量工作坊一般系统更新较慢）、WiFi 使用情况、使用时间、来源地区、IP 是否进过黑名单；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（3）用户行为特征：访问时长、访问页面、使用间隔、次日留存、活跃时间、页面跳转行为（假用户的行为要么过于一致，要么过于随机）、页面使用行为（正常用户对图片的点击也是有分布的，假用户的行为容易过于随机）；","category":"page"},{"location":"AI/dataAnaly/","page":"-","title":"-","text":"（4）异常特征：设备号异常（频繁重置 idfa）、IP 异常（异地访问）、行为异常（突然大量点击广告、点赞）、数据包不完整等；","category":"page"},{"location":"dataStruc&algo/leetcode/#二分问题","page":"-","title":"二分问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"704. 二分查找【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】升序整型数组 nums 和目标值 target","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回 target 所在的下标，如果不存在返回 -1","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"二分，向下取整计算中点 mid = (right - left) // 2 + left：：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"求中点 mid = (right - left) // 2 + left；\n判断：循环条件 left <= right\n如果 nums[mid] < target，left = mid + 1；\n如果 nums[mid] > target，right = mid - 1；\n如果 nums[mid] == target，return mid；\n如果找不到，就会因不满足循环条件跳出循环，按照题意 return -1。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"367. 有效的完全平方数【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】正整数 num","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】判断 num 是否为一个完全平方数","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"二分，以 [1, num] 作为区间，向下取整计算中点 mid = (right - left) // 2 + left：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"判断：循环条件 left <= right，square = mid * mid\nsquare < num，left = mid + 1；\nsquare > num，right = mid - 1；\nsquare == num，return True；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"374. 猜数字大小【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】数字 n 代表所选择的数字是在区间 [1, n] 中","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】猜出所选的数字 pick 是多少","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"有一个接口 int guess(int num)，向下取整计算中点 mid = (right - left) // 2 + left：：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 pick < num，返回 -1；\n如果 pick > num，返回 1：\n如果 pick == num，返回 0；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"二分，以 [1, n] 作为区间：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"判断：循环条件 left <= right：\nguess(mid) == 1，left = mid + 1；\nguess(mid) == -1，right = mid - 1；\nguess(mid) == 0，return mid；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"441. 排列硬币【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】硬币数量 n","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】可以形成完整阶梯行的总行数 row。换句话说，即小于 n 的最大数列和 1+2+3+cdots+textrow","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"二分，以 [1, n] 作为区间，向上取整计算中点 mid = (right - left + 1) // 2 + left","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"判断：循环条件 left < right：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 mid * (mid + 1) <= 2 * n，left = mid；\n否则 right = mid - 1","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"35. 搜索插入位置【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"判断：循环条件 left <= right：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 nums[mid] < target，left = mid + 1；\n否则有 nums[mid] >= target，right = mid - 1；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"根据 if 的判断条件，left 左边的值一直保持小于 target，right 右边的值一直保持大于等于 target，而且 left 最终一定等于 right + 1。在循环结束之后，left 左边的部分全部小于 target，结尾的位置为 right；right 右边的部分全部大于等于 target，并且开始的位置是 left。因此最终的答案一定是 left. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"278. 第一个错误的版本【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"判断：循环条件 left < right，下取整求 mid","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 isBadVersion(mid)，right = mid；\n否则，left = mid + 1；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"剑指 Offer 53 - I. 在排序数组中查找数字 I【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】非递减数组 nums 以及目标数 target","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回 target 在 nums 中的出现次数","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"通过设定 lower 为 True 或者 False，以下二分查找代码可以查找在数组 nums 中第一个 target 的位置，以及第一个大于 target 的位置：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"class Solution:\n    def binarySearch(self, nums, target, lower):\n        n = len(nums)\n        ans = n\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (right - left) // 2 + left\n            if (nums[mid] > target) or (lower and nums[mid] >= target):\n                right = mid - 1\n                ans = mid\n            else:\n                left = mid + 1\n        return ans\n\n    \n    def search(self, nums: List[int], target: int) -> int:\n        leftIdx = self.binarySearch(nums, target, True)\n        rightIdx = self.binarySearch(nums, target, False) - 1\n        if (leftIdx <= rightIdx) and (rightIdx < len(nums)) and (nums[leftIdx] == target) and (nums[rightIdx] == target):\n            return rightIdx - leftIdx + 1\n        return 0","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1337. 矩阵中战斗力最弱的 K 行【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】大小为 m * n 的矩阵 mat 以及一个 k，mat 中的每一行的都包含一定数量的 1 和 0，并且 1 总是在 0 前","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回矩阵中包含 1 最少的 k 行的索引；如果两行包含 1 的数量一样那么行数小的排在前面","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"对于每一行，使用二分去查找最后一个 1 的位置 pos，那么该行包括的 1 的数量为 pos + 1。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"然后把每一行包含 1 的数量以及该行的索引构成的元组建立小根堆，然后不断地弹出堆顶，将堆顶元素里的行索引放入答案数组。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"对于所有的行 i：\n二分区间 [0, n - 1]，判断条件 left <= right，向下取整求 mid\n如果 mat[i][mid] == 0，right = mid - 1；\n否则 mat[i][mid] == 1，left = mid + 1， pos = mid；\n将计算得到的 [pos + 1, i] 加入到一个列表 power 中；\n小根堆：Python 中小根堆化为 heapq.heapify(power)，弹出堆顶为 heapq.heappop(power)；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"剑指 Offer II 069. 山峰数组的顶部【简单】852. 山脉数组的峰顶索引【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】山峰数组 arr，长度 arr.length >= 3","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回其中任何的一个山峰的位置","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"二分区间 [1, n - 2]，判断条件 left <= right，向下取整求 mid","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 arr[mid] > arr[mid + 1]，right = mid - 1，ans = mid；\n否则 arr[mid] <= arr[mid + 1]，left = mid + 1","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"475. 供暖器【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】房屋 houses 和供暖器 heaters 的位置","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回供暖器可以覆盖所有房屋的最小加热半径","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"将供暖器 heaters 排序；\n对于每一个房屋 house：\n找到满足 heaters[i] <= house 的最大下标 i：\n假如 heaters[0] > house 时，i = -1，对应距离设为 inf；\n令 j = i + 1，则 j 是满足 heaters[j] > house 的最小下标；\n当 heaters[n - 1] <= house 时，j = n，对应距离设为 inf；\n离 house 最近的供暖器为 heaters[i] 或者 heaters[j]，这两个供暖器与 house 距离的最小值，即为考虑当前 house 时的最小加热半径；\n如果当前 house 的最小加热半径大于全局最小加热半径，更新全局最小加热半径；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"528. 按权重随机选择【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】正整数数组 w","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】实现函数 pickIndex，随机从范围 [0, w.length - 1] 内返回一个下标。选取下标 i 的概率为 w[i] / sum(w)","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"构造前缀和数组 sum，长度为 n + 1，并且 sum[i] = sum[i - 1] + w[i - 1]；\n选取阈值 t 为 [1, sum[n - 1]] 的整数\n二分区间 [1, n - 1]，判断条件 left < right，向下取整求 mid；\n如果 sum[mid] >= t，right = mid；\n否则，left = mid + 1；\n最终的答案为 right - 1；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"611. 有效三角形的个数【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】包含非负整数数组 nums","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回可以组成三角形的三元组的个数","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"将数组 nums 进行升序排序；\nfor i in range(n):\nfor j in range(i + 1, n):\n二分区间 [j + 1, n - 1]，判断条件 left <= right，向下取整求 mid，k = j；\n如果 nums[mid] < nums[i] + nums[j]，left = mid + 1，k = mid；\n否则 right = mid - 1\n把答案累加 ans += k - j","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"29. 两数相除【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】两个整数，被除数 dividend 和除数 divisor","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】在不使用乘法、除法、mod 运算下，返回 dividend / divisor 所得到的商的整数部分","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"注意：本题只能存储 32 位整数，如果结果溢出则返回 2 ** 31 - 1","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"根据题意有 ans * divisor >= dividend > (ans + 1) * divisor，因此可以使用二分法找到最大的满足 ans * divisor >= dividend 的 ans。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"题目限制不能够使用乘法，可以使用「快速乘」来得到 ans * divisor 的值。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"「快速乘」与「快速幂」类似，前者通过加法实现乘法，后者通过乘法实现幂运算。「快速幂」题目：50. Pow(x, n)，将里面的乘法运算改成加法运算就是「快速乘」","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"定义最小值和最大值：INT_MIN, INT_MAX = -2 ** 31, 2 ** 31 - 1；\n判断特殊情况：\n如果被除数为最小值 dividend = INT_MIN：如果被除数为 1 返回 INT_MIN，如果被除数为 -1 返回 INT_MAX；\n如果被除数为 0，返回 0；\n如果除数为最小值 divisor = INT_MIN，","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"33. 搜索旋转排序数组【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"34. 在排序数组中查找元素的第一个和最后一个位置【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"74. 搜索二维矩阵【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"81. 搜索旋转排序数组 II【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"153. 寻找旋转排序数组中的最小值【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"154. 寻找旋转排序数组中的最小值 II【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"162. 寻找峰值【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"220. 存在重复元素 III【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"240. 搜索二维矩阵 II【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"274. H 指数【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"275. H 指数 II【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1818. 绝对差值和【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1838. 最高频元素的频数【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1894. 找到需要补充粉笔的学生编号【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"786. 第 K 个最小的素数分数【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"911. 在线选举【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"981. 基于时间的键值存储【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1004. 最大连续1的个数 III【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1011. 在 D 天内送达包裹的能力【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1208. 尽可能使字符串相等【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1438. 绝对差不超过限制的最长连续子数组【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1482. 制作 m 束花所需的最少天数【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"352. 将数据流变为多个不相交区间【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"4. 寻找两个正序数组的中位数【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"354. 俄罗斯套娃信封问题【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"363. 矩形区域不超过 K 的最大数值和【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"778. 水位上升的泳池中游泳【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1707. 与数组中元素的最大异或值【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1713. 得到子序列的最少操作次数【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1751. 最多可以参加的会议数目 II【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/#双指针问题","page":"-","title":"双指针问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/#背包问题","page":"-","title":"背包问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/#股票问题","page":"-","title":"股票问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"股票问题是学习动态规划很好的系列，因此一下最先考虑的都是用动态规划怎么做。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】prices 表示每一天的股票的价格，长度为 n，根据不同题目会有额外的参数，包括最多交易 k 次，冷冻期，手续费 fee。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】能够获得的最大利润。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"121. 买卖股票的最佳时机【简单题】：只能交易一次。矩阵 dp[n][2] 表示第 i 天交易完后的最大利润，其中 dp[i][0] 表示未持有股票，dp[i][1] 表示持有股票。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi0=maxdpi-10 dpi-11+pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi1=maxdpi-11 -pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"其中边界条件：dp[0][0] = 0，dp[0][1] = -prices[0]. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"实际上，dp[i][1] 就是在记录过去的天数中最低的价格。这个问题最简单的思路，其实就是记录以往的最低价格，然后用今天的价格出售，动态维护最大值即为答案。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"122. 买卖股票的最佳时机 II【中等题】：能够交易无限次。同样的，矩阵 dp[n][2] 表示第 i 天交易完后的最大利润，其中 dp[i][0] 表示未持有股票，dp[i][1] 表示持有股票。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi0=maxdpi-10 dpi-11+pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi1=maxdpi-11 dpi-10-pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"其中边界条件：dp[0][0] = 0，dp[0][1] = -prices[0]. 最终答案为：dp[n - 1][0]. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"714. 买卖股票的最佳时机含手续费【中等题】：每笔交易都要支付手续费 fee. 同样的方式，只是在卖出的时候要多计算一个手续费","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi0 = maxdpi - 10 dpi - 11 + pricesi - fee","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi1 = maxdpi-11dpi-10-pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"其中边界条件：dp[0][0] = 0，dp[0][1] = -prices[0]. 最终答案为：dp[n - 1][0]. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"123. 买卖股票的最佳时机 III【困难题】：最多完成两笔交易。定义 4 个状态，分别是：buy1 进行一次买入、sell1 进行一次卖出、buy2 进行第二次买入、sell2 进行第二次卖出。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"buy_1 = maxbuy_1 -pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"sell_1=maxsell_1 buy_1+pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"buy_2 = maxbuy_2 sell_1-pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"sell_2=maxsell_2buy_2+pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"其中边界条件：buy1 = -prices[0]，sell1 = 0，buy2 = -prices[0]，sell2 = 0，答案就是 sell2. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"188. 买卖股票的最佳时机 IV【困难题】：最多只能够完成 k 笔交易。定义矩阵 buy[n][k] 和 sell[n][k] 分别表示第 i 天时处于第 j 笔交易时持有以及未持有股票的最大利润。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"buyij = maxbuyi-1jselli-1j-1-pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"sellij=maxselli-1jbuyi-1j+pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"其中边界条件：buy[0][0...k] = -prices[i]，sell[0][0...k] = 0。当 j = 0 时，buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]). ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"最终答案为 sell[n - 1][0...k] 中的最大值。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"注意：因为 n 天最多只能进行 lfloorfracn2rfloor 次交易，因此在一开始时可以令 k = min(k, n // 2)，如果 k == 0 那么答案直接为 0. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"309. 最佳买卖股票时机含冷冻期【中等题】：冷冻期为 1 天（卖出股票后得隔一天才能买入股票）。矩阵 dp[n][3] 存储第 i 天结束时的最大收益，其中 dp[i][0] 表示持有一支股票，dp[i][1] 表示不持有任何股票并且处于冷冻期，dp[i][2] 表示不持有股票并且不处于冷冻期。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi0 = maxdpi-10 dpi-12 - pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi1 = dpi-10 + pricesi","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"dpi2=maxdpi-11dpi-12","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"其中边界条件：dp[0][0] = -prices[0]，dp[0][1] = 0， dp[0][2] = 0. 最终答案为 max(dp[n - 1][1], dp[n - 1][2]). ","category":"page"},{"location":"dataStruc&algo/leetcode/#岛屿问题","page":"-","title":"岛屿问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"岛屿问题是学习深度优先搜索（DFS）和广度优先搜索（BFS）的经典系列问题。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】grid 是一个 M 行 N 列的矩阵，其中 1 代表陆地，0 代表海洋。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】不同的问题有不同的要求，例如岛屿数量、岛屿周长、岛屿面积等","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"200. 岛屿数量【简单题】：计算岛屿数量。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"DFS：扫描网格，碰到某个位置为 1，以其为起始节点开始进行深度优先搜索。将每个碰到的 1 都变成 0，避免重复搜索。最终的答案就是进行 DFS 的次数。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"BFS：扫描网格，如果某个位置为 1，将其加入队列，开始 BFS，没搜索到的 1 都重新标记为 0，直到队列为空。最终的答案就是进行 BFS 的次数。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"305. 岛屿数量 II【困难题】：最初全部为海洋，positions[i] = [ri, ci] 记录的是每次添加的陆地位置，要求返回 answer 记录每次将 [ri, ci] 变成陆地后地图中的岛屿数量。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"这个问题在题解里只找到并查集的解法。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"并查集：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"463. 岛屿的周长【简单题】：grid 中只有一个岛屿，且岛屿中没有湖，要求返回这个岛屿的周长。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"DFS：扫描网格，碰到第一个为 1 的位置，开始搜索，如果碰到海洋或者边界，则周长加 1，否则继续搜索。通过将 grid[x][y] 添加到集合中或者重新标记为 2 来避免重复搜索。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"BFS：扫描网格，碰到第一个为 1 的位置，将其加入队列并开始搜索，如果碰到海洋或者边界，则周长加 1，搜索到的位置添加到已遍历集合中或者标记为 2，直到队列为空。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"694. 不同岛屿的数量【中等题】：返回 grid 中有多少种不同形状的岛屿。相同形状的岛屿指的是可以通过平移与另一个岛屿重合（不可旋转、翻转）。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"695. 岛屿的最大面积【中等题】：返回 grid 中最大岛屿的面积。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"DFS：扫描网格，碰到某个位置为 1，开始 DFS，将每个碰到的 1 都重新标志为 0，并且面积加 1，遍历完之后动态维护全局最大面积。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"BFS：扫描网格，碰到某个位置为 1，加入队列，开始 BFS，将每个碰到的 1 都重新标志为 0，并且面积加 1，直到队列为空。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"序列化遍历顺序：用 [1, 2, 3, 4] 分别代表上下左右四个方向的进口，出口则分别对应 [-1, -2, -3, -4]，这样遍历完一个岛屿，就能够得到一个序列，将这个序列保存到一个集合中。最终的答案就是集合中不同种序列的数量。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1254. 统计封闭岛屿的数目【中等题】：定义「岛」是由最大的 4 个方向连通的陆地组成的群；「封闭岛」是一个 完全由海洋包围的岛。题目要求返回封闭岛屿的数量。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"这道题目中陆地和海洋的标志互换了，这里还是依照 1 代表陆地，0 代表海洋来讨论。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"BFS：如果 BFS 中碰到了边界，则不是一个封闭岛。碰到某个位置为 1，加入队列开始 BFS，将碰到的每个 1 都重新标志为 0，如果碰到了边界，则记录该陆地不是封闭岛，不断重复直到队列为空。如果该陆地为封闭岛则数量加 1.","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"1905. 统计子岛屿【中等】：有两个同样大小的 grid1 和 grid2，如果 grid2 中的岛屿中每个位置在 grid1 中的对应位置都是陆地，那么这个岛屿就称为「子岛屿」，题目要求返回 grid2 中子岛屿的数目。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"DFS：扫描网格 grid2，碰到某个位置为 1，开始搜索，每个 1 都判断在 grid1 中是否也为 1，如果不是则记录该岛不是一个子岛屿，然后将遇到的每一个 1 都重新标志为 0. 在遍历完 grid2 中的一个岛之后，如果是一个子岛屿，则将子岛屿的数量加 1. ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"BFS：扫描网格 grid2，碰到某个位置为 1，加入队列开始搜索，每个 1 都判断在 grid1 中是否也为 1，如果不是则记录该岛不是一个子岛屿，然后将遇到的每一个 1 都重新标志为 0. 在遍历完 grid2 中的一个岛之后，如果是一个子岛屿，则将子岛屿的数量加 1. ","category":"page"},{"location":"dataStruc&algo/leetcode/#排列、组合、子集问题","page":"-","title":"排列、组合、子集问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"排列、组合、子集问题是学习回溯算法的一系列很好的问题。回溯算法就是在一棵树上的深度优先遍历（DFS）。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"46. 全排列【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个不包含重复数字的序列 nums","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回所有不重复的全排列（不考虑顺序）","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(nums, temp, used)，temp 是当前已经决策的路径，used 记录对应数字是否已使用：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 len(temp) == len(nums)，将 temp 放入答案数组中，找到其中一个答案；\n定义一个标记数组 used，递归时遍历 nums 找到没被选择的数字填入 temp，继续递归；\n回溯的时候要撤销 temp 中的数的数以及标志，继续尝试其他没被标记过的数；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"47. 全排列 II【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个包含重复数字的序列 nums","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回所有不重复的全排列（不考虑顺序）","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(nums, temp, used)，temp 是当前已经决策的路径，used 记录对应数字是否已使用：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"首先对数组 nums 排序，再开始递归；\n如果 len(temp) == len(nums)，将 temp 放入答案数组中，找到其中一个答案；\n定义一个标记数组 used，递归时遍历 nums 找到没被选择的数字填入 temp，继续递归；\n避免重复：将 nums 进行排序之后，相同的数字会在一起，如果当前数字与前一个数字相同，并且前一个数字没有被使用 i > 0 and nums[i] == nums[i - 1] and not used[i - 1]，则跳过当前的数字；\n回溯的时候要撤销 temp 中的数以及标志，继续尝试其他没被标记过的数；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"注意：组合与排列的不同，排列问题是关注顺序的，而组合问题不关注。具体而言，对于数组 [1, 2, 3] 和 [1, 3, 2] 在组合问题中是一样的，而在排列问题中则不一样。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"39. 组合总和【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个无重复元素的整数数组 candidates 和目标整数 target","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回 candidates 中可以使得数字和为 target 的所有不同组合所组成的列表（不考虑顺序），同一个数字可以重复使用","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(candidates, target, combine, begin) 表示还剩 target 要组合，已经组合的列表为 combine，从 begin 位置去遍历：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"剪枝：首先对 candidates 进行排序，然后开始递归；\n当 target == 0 时将当前组合 combine 加入到答案列表中；\n遍历 candidates 的 i = [begin, ..., n] 位置：\n当 target - candidates[i] < 0 则停止遍历【剪枝】；\n否则将当前数字加入 combine 中，将当前位置 i 作为 begin （因为数字可以重复使用）继续递归 dfs(candidates, target - candidates[i], combine, i)；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"40. 组合总和 II【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个含重复元素的整数数组 candidates 和目标整数 target","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回 candidates 中使得数字和为 target 的所有不同组合所组成的列表（不考虑顺序），同一个数字只能使用一次","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(candidates, target, combine, begin)，表示还剩 target 要组合，已经组合的列表为 combine，从 begin 位置去遍历：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"剪枝：首先对 candidates 进行排序，然后开始递归；\n当 target == 0 时将当前组合 combine 加入到答案列表中；\n遍历 candidates 的 i = [begin, ..., n] 位置：\n当 target - candidates[i] < 0 则停止遍历【剪枝】；\n如果 i > begin and candidates[i - 1] == candidates[i] 则跳过当前的数；\n否则将当前数字加入 combine 中，将下一个位置 i + 1 作为 begin （因为数字不可以重复使用）继续递归 dfs(candidates, target - candidates[i], combine, i + 1)；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"77. 组合【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】两个整数 n 和 k","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回范围 [1, n] 中所有的可能的 k 个数的组合","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(cur, n, k, temp) 表示当前在位置 cur，数组范围为 n 要选择 k 个数字进行组合，temp 数组用于记录当前已经选择的数字：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 temp  的长度已经等于 k，那么记录当前的组合；\n对区间 i in [cur, ..., n] 进行遍历：\n剪枝：如果 temp 的长度加上区间 [cur, n] 的长度小于 k，那么不可能构造出长度为 k 的 temp，直接结束遍历；\n考虑当前位置，则 temp.append(i)；\n不考虑当前位置，则直接对下一个位置进行决策 dfs(i + 1, n, k, temp)；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"78. 子集【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个不含重复元素的整数数组 nums","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回该数组所有可能的子集（不考虑顺序）","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(nums, idx, temp) 代表当前决策数组 nums 中的第 idx 个位置，临时数组 temp 中为决定放进子集的数字：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果当前已经决策完所有的数字 idx == len(nums)，则把 temp 作为答案放进答案数组 self.ans.append(temp.copy())；\n考虑添加当前位置的数字：将当前位置加入临时数组 temp，则 temp.append(nums[cur])，再对下一个位置进行决策；\n考虑不添加当前位置的数字：直接对下一个位置进行决策 dfs(nums, idx + 1, temp)；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"90. 子集 II【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】包含重复元素的整数数组 nums","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回该数组所有不重复的子集（不考虑顺序）","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"避免重复的方法：先对数组 nums 进行排序，保证相同的数字都在一起。如果没有选择上一个数，并且当前数字与上一个数相同，则跳过当前生成的子集。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(nums, idx, temp, used) 代表当前决策数组 nums 中的第 idx 个位置，临时数组 temp 中为决定放进子集的数字，used 有哪些数字被选择：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"先对 nums 进行排序，再开始递归；\n如果 idx == len(nums)，则将数组加入到答案中；\n对于当前的位置 idx：\n首先考虑不添加当前位置的数字 dfs(nums, idx + 1, temp, used)；\n如果 cur > 0 and nums[cur - 1] == nums[cur] and not used[idx]，则直接 return；\n否则，将当前位置加入临时数组 temp，即 temp.append(nums[idx])，再对下一个位置进行决策；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"注意：考虑不添加当前位置的情况要放在判断是否重复前面，否则答案数组中会没有「空集」","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"60. 排列序列【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】给定 n 和 k","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回集合 [1, 2, 3,..., n] 所有排列的第 k 个","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"这个题目可以很好地学习剪枝的思想，基本的思路是 46. 全排列 再加上剪枝。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"剪枝：在每个分支里，根据还未选定的个数计算阶乘 (n - index) 来得到当前分支有多少个叶子结点：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 k 大于这个分支的叶子结点数，代表答案肯定不在这个分支里，直接跳过当前分支；\n如果 k 小于这个分支的叶子结点数，代表答案肯定在这个分支里，继续递归进行剪枝；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(n, k, index, temp, used) 表示当前决策第 index 个数，temp 保存已经决策完的 index - 1 个数，used 用于标记已经使用过的数字。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 index == n 则代表 temp 为要返回的第 k 个序列，即为答案；\n每一次 DFS 都要在 i = [1, 2,..., n] 中找到没有使用的数字 used[i] == False：\n计算 cnt = factorial[n - index]；\n如果 cnt < k 则要对这个分支进行剪枝，令 k -= cnt 然后寻找下一个未被使用的数字；\n否则 cnt >= k 代表答案在当前分支里，选择当前数字 temp.append(i)，标记为已使用 used[i] = Ture，继续递归决策下一个数 dfs(n, k, index + 1, temp, used)；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"由于题目中 nin1 9，因此可以弄一个数组存放不同数字对应的阶乘：[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"93. 复原 IP 地址【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】只包含数字的字符串 s","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】输出所有可能的有效 IP 地址","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"有效 IP 地址：由四个 [0, 255] 之间的整数组成，例如 0.1.2.201, 192.168.1.1, 255.255.255.255","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(s, segId, segStart, temp) 表示从 s[segStart] 开始，已经搜索完前 segId 个字段，其中 textsegIdin01234，temp 数组保存全部 4 个字段：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果当前已经到字符串的末尾 segStart == len(s)：\n如果已经找到了 4 个字段 segId == 4，那么将 temp 转化成符合格式的 IP 地址放到答案数组中；\n否则代表当前找的不是一个满足要求的，那么递归返回；\n【剪枝 1】如果剩余的字符串长度 restChar 小于剩余要找的字段 segId 或者大于 restId * 3 那么进行剪枝（直接递归返回）；\n遍历当前位置往后的 3 个长度的字符串 segEnd in range(segStart, min(len(s), segStart + 3))：\n由于不能含有前导零：如果字段长度为 1 并且当前字段为 0，那么只能单独成为一个字段；\n如果字段的范围在 (0, 255] 区间内，那么继续递归；\n【剪枝 2】否则进行剪枝；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"具体的代码可以参考我的题解：【回溯 + 剪枝】回溯实际上就是对一棵树的深度优先遍历","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"733. 图像渲染【简单】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】大小为 (m, n) 的二维数组 image，着色位置 sr, sc 和颜色 newColor，image[i][j] 表示该点的像素值；sr, sc 表示从位置 image[sr][sc] 开始着色 newColor","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回经过上色渲染之后的图像","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"上色渲染：将上下左右所有颜色相同的位置都变成 newColor","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(image, x, y, preColor, newColor)：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"先记录 image[sr][sc] 的颜色 preColor，如果 preColor 和要修改的颜色 newColor 一样，那么不用递归；\n先把当前颜色改成新颜色 image[x][y] = newColor，然后分别搜索上下左右 4 个方向，如果颜色是 preColor 则继续递归修改；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"130. 被围绕的区域【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】大小为 (m, n) 的由若干 X 和 O 组成的二维数组 board","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】不输出任何内容，直接原地修改（将所有被 X 围绕的 O 都变成 X）","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"实际上，任何不与边界相连的 O 都是被 X 围绕的。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(board, x, y)，每寻找到一个边界的 O 就开始递归：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"将与边界相连的 O 都标记为 A；\n递归完成之后，如果 board[x][y] == 'A' 代表与边界相连，那么重新标记为 O；如果 board[x][y] == 'O' 代表没有与边界相连，那么重新标记为 X；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"字符串的回溯算法：字符串问题的特殊之处在于，字符串的拼接是产生新对象，而 list 对象是直接修改对象。","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"79. 单词搜索【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】大小为 (m, n)  的数组 board，一个字符串 word","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回 word 是否存在于 board 中，存在返回 True 否则 False","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(board, word, x, y, k, used) 代表以网格的位置 (x, y) 出发，能否搜索到单词 word[k:]：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 board[x][y] != word[k] 返回 False；否则如果当前到了字符串末尾 k == len(word) - 1 则返回 True；\n标记当前位置被使用 used[x][y] = True，遍历所有相邻位置，如果找到某一个位置有路径可以组成 word，则返回 True；\n否则把当前位置重新标记为未使用 used[x][y] = False，返回 False；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"具体的代码，可以参考题解：回溯算法：就是深度优先搜索","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"17. 电话号码的字母组合【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个仅包含数字 2-9 的字符串 digits","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回所有它能表示的字母组合","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"数字到字母的映射是电话九宫格的方式：phoneMap = {'2': 'abc', '3': 'def', ..., '9': 'wxyz'}","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(digits, idx, temp) 表示当前决策第 idx 个字母，temp 数组存放已经决定加入的字母：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 idx == len(digits)，那么将当前的数组 temp 转化成字符串加入到答案数组中；\n遍历当前位置对应的所有字母 phoneMap[digits[index]]，添加进 temp 里，继续递归；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"具体的代码，可以参考题解：回溯算法：深度优先搜索","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"784. 字母大小写全排列【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】一个字符串 s，将其中每个字母转变大小写，可以获得一个新的字符串","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回所有可能得到的字符串集合","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(s, index, temp) 表示当前决策第 index 个字符，temp 数组存放已经在的字母：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 index == len(s)，将当前数组 temp 转化成字符串加入到答案数组中；\n如果 s[index].isalpha() 是字母，那么分别添加大写和小写，再继续递归；\n如果不是字母，那么直接添加，再递归；","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"字母转换成大小写的方式：char.upper() 和 char.lower(). ","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"22. 括号生成【中等】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输入】整数 n 代表生成括号的对数","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"【输出】返回所有可能的 n 对括号组成的有效括号组合","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"递归函数 dfs(temp, left, right) 代表当前已决策的左右括号数量 left  和 right，以及数组 temp：","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"如果 len(temp) == 2 * n 将 temp 转化成字符串加入到答案数组；\n如果左括号数量小于 n，可以放一个左括号；\n如果右括号数量小于左括号数量，可以放一个右括号；","category":"page"},{"location":"dataStruc&algo/leetcode/#游戏问题","page":"-","title":"游戏问题","text":"","category":"section"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"51. N 皇后【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"37. 解数独【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"488. 祖玛游戏【困难】","category":"page"},{"location":"dataStruc&algo/leetcode/","page":"-","title":"-","text":"529. 扫雷游戏【困难】","category":"page"},{"location":"py_module/torch/#张量（Tensors）","page":"-","title":"张量（Tensors）","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"官方文档：Torch","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"张量的构建、索引、切片、拼接、修改、随机采样\n数学操作：逐点操作、规约操作、比较操作、频谱分析、其他操作、BLAS and LAPACK","category":"page"},{"location":"py_module/torch/#张量的构建","page":"-","title":"张量的构建","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"tensor：通过复制数据构造一个没有梯度历史的张量（也称为「叶张量」）。","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"叶张量：在自动微分机制（Autograd Mechanics）一节可以了解 PyTorch 是如何实现自动微分的。","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"sparse_coo_tensor：在给定索引处构造一个具有指定值的 COO (rdinate) 格式的稀疏张量。","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"asarray：转化为张量。","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"as_tensor：将数据转成张量，共享数据以及保留梯度历史。","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"as_strided：创建具有指定大小、步幅和 storage_offset 的现有 torch.Tensor 输入的视图（view）。","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"from_numpy：将 numpy.ndarray 转化为 Tensor","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"from_dlpack：将外部库中的张量转换为 torch.Tensor","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"frombuffer：从实现 Python 缓冲区协议的对象创建一维张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"zeros、ones：构建给定 size 一样的全 0 张量或者全 1 张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"zeros_like、ones_like：构建与给定张量一样 size 的全 0 张量或者全 1 张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"arange：在区间 [start, end) 中以固定步长 step 构建一维张量，大小为 lceil (textend - textstart)textstep rceil","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"range：从 start 到 end 以步长 step 构建一维张量，大小为 lfloor (textend - textstart)textstep rfloor + 1","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"linspace：在  start 到 end  均匀分布的一维张量，大小为 step（包含 end 在内）","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"logspace：在以 base 为底的对数尺度中 textbase^textstart 到 textbase^textend 均匀分布的一维向量（包含 textbase^textend 在内）","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"eye：单位二维向量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"empty：构建还未初始化的张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"empty_like：构建与给定张量一样 size 的未初始化张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"empty_strided：创建一个具有指定大小和步幅并填充未定义数据的张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"full、full_like：构建全为给定值 fill_value 的张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"quantize_per_tensor：将浮点张量转换为具有给定比例和零点的量化张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"quantize_per_channel：将浮点张量转换为具有给定比例和零点的每通道量化张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"dequantize：通过反量化量化张量返回 float32 张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"complex：构造一个复数张量，其实部等于 real，虚部等于 imag","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"polar：构造一个复数张量，其元素是笛卡尔坐标，对应于绝对值 abs 和角度 angle 的极坐标","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"heaviside：计算输入中每个元素的 Heaviside 阶跃函数","category":"page"},{"location":"py_module/torch/#索引、切片、拼接、修改","page":"-","title":"索引、切片、拼接、修改","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"adjoint：返回张量共轭和最后两个维度转置的引用视图","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"argwhere：返回输入的所有非零元素的索引张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"cat、concat：连接给定维度中给定的 seq 张量序列","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"conj：返回输入张量的翻转共轭位的引用视图","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"chunk：尝试将张量拆分为指定数量的块","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"split：将张量拆分为块","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"tensor_split：根据索引或由 indices_or_sections 指定的部分数量，将张量拆分为多个子张量，所有这些子张量都是输入的视图","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"vsplit、hsplit、dsplit：根据 indices_or_sections 将输入张量（具有三个或更多维度的张量）沿着垂直、水、深度方向拆分为多个张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"row_stack：通过在张量中垂直堆叠张量来创建一个新张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"column_stack：通过在张量中水平堆叠张量来创建一个新张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"vstack、hstack、dstack：沿着垂直、水平、深度方向堆叠张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"垂直、水平、深度三个方向对应着第一、二、三个维度","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"stack：沿着给定的维度拼接张量序列","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"gather：沿由 dim 指定的轴收集值","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"index_add、index_copy、index_reduce：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"index_select：返回一个新张量，该张量使用索引中的条目沿维度 dim 索引输入张量，该条目是 LongTensor","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"masked_select：返回一个新的一维张量，它根据布尔掩码掩码索引输入张量，该掩码掩码是 BoolTensor","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"movedim、moveaxis：将 source 中位置的输入维度移动到目标位置","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"narrow：返回一个新的张量，它是输入张量的缩小版本","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"nonzero：返回非零元素的索引","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"permute：返回原始张量 input 的置换之后的视图","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"reshape：重新定义输入张量的 size","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"select：在给定索引处沿选定维度对输入张量进行切片","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"scatter、torch.Tensor.scatter_()：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"diagonal_scatter：将 src 张量的值相对于 dim1 和 dim2 沿输入的对角线元素嵌入到输入张量中","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"select_scatter：将 src 张量的值嵌入到给定索引处的输入中","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"slice_scatter：将 src 张量的值嵌入到给定维度的输入中","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"scatter_add：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"scatter_reduce：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"tile：通过重复输入的元素构造一个张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"squeeze：将所有大小为 1 的维度都去掉","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"unsqueeze：返回一个插入到指定位置的尺寸为 1 的新张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"unbind：去除指定维度（返回的是一个保存对这个维度进行分割之后所有矩阵的元组）","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"swapaxes、swapdims、torch.transpose()：交换 dim0 和 dim1","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"t：要求 input 张量的维度必须小于等于 2，转换维度 0 和维度 1","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"take：返回一个新的张量，其中输入的元素在给定的索引处","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"take_along_dim：从沿给定暗淡的索引中选择一维索引处的输入值","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"where：根据条件返回从 x 或 y 中选择的元素的张量","category":"page"},{"location":"py_module/torch/#随机采样","page":"-","title":"随机采样","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"seed：随机设置一个随机种子，不需要给定参数（会返回一个 64 比特的数字代表设置的种子）","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"manual_seed：设定随机种子为给定的 seed，会返回一个 torch.Generator","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"initial_seed：将生成随机数的初始种子以  Python long 数据类型返回","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"get_rng_state：以 torch.ByteTensor 的数据类型返回随机数生成器","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"set_rng_state：设置随机数生成器状态","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"随机数生成器","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bernoulli：伯努利分布，生成 0 或者 1","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"multinomial：返回一个张量，其中每行包含从位于张量输入的相应行中的多项概率分布中采样的 num_samples 个索引","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"normal：返回从给出均值和标准差的独立正态分布中抽取的随机数张量","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"poisson：返回与输入相同大小的张量，每个元素从泊松分布中采样，速率参数由输入中的相应元素给出","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"rand、rand_like：单位均匀分布 0 1)","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"randint、randint_like：[low, high) 之间的随机整数","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"randn、randn_like：标准正太分布采样","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"randperm：返回从 0 到 n - 1 的整数的随机排列","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"一些 In-place 的随机采样：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"torch.Tensor.bernoulli_() - in-place version of torch.bernoulli()\ntorch.Tensor.cauchy_() - numbers drawn from the Cauchy distribution\ntorch.Tensor.exponential_() - numbers drawn from the exponential distribution\ntorch.Tensor.geometric_() - elements drawn from the geometric distribution\ntorch.Tensor.log_normal_() - samples from the log-normal distribution\ntorch.Tensor.normal_() - in-place version of torch.normal()\ntorch.Tensor.random_() - numbers sampled from the discrete uniform distribution\ntorch.Tensor.uniform_() - numbers sampled from the continuous uniform distribution","category":"page"},{"location":"py_module/torch/#逐点操作","page":"-","title":"逐点操作","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"abs、absolute：计算输入张量 input 每个元素的绝对值","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"cos (cosh)：计算每个元素的正弦、余弦、正切","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"asin (arcsin)、acos (arccos)、atan (arctan)：计算每个元素的反正弦、反余弦、反正切","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"asinh (arcsinh)、acosh (arccosh)、atanh (arctanh)：计算每个元素的反双曲正弦、反双曲余弦、反双曲正切","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"atan2 (arctan2)：有两个输入 input 和 other，考虑象限的 textinput_itextother_i 的逐元素反正切","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"add：将输入 input 点乘以 alpha 再加上 other","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"div (divide)：将输入 input 的每个元素除以 other 的对应元素","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"frac：计算输入中每个元素的小数部分","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"floor_divide：按元素计算 input 除以 other，并将每个商向零的方向舍入","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"addcdiv：将 tensor1 元素点除 tensor2 的结果乘以标量 value 再加到 input 上","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"addcmul：将 tensor1 元素点乘 tensor2 的结果乘以标量 value 再加到 input 上","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"exp：计算每个元素的指数","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"frexp：将输入分解为尾数（mantissa）和指数张量，即 textinput=textmantissatimes 2^textexponent","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"exp2 (special.exp2())","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"expm1 (special.expm1())","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"float_power：计算每个元素的 exponent 次幂","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"angle：计算每个元素的角度（以弧度为单位）","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"deg2rad：返回一个新的张量，输入的每个元素都从角度转换为弧度","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"位计算","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bitwise_not：计算 input 张量的按位非","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bitwise_and：计算 input 和 other 的按位与","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bitwise_or：计算 input 和 other 的按位或","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bitwise_xor：计算 input 和 other 的按位异或","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bitwise_left_shift：计算 input 左移 other 位的结果","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"bitwise_right_shift：计算 input 右移 other 位的结果","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"ceil：返回一个新的张量，其中输入元素的 ceil 是大于或等于每个元素的最小整数","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"floor：返回一个新的张量，其中输入元素的 floor，最大整数小于或等于每个元素","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"clamp (clip)：将 input 中的所有元素限制在 [min, max] 范围内","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"conj_physical：计算给定输入张量的元素共轭","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"copysign：创建一个新的浮点张量，元素为 input 的大小和 other 元素的符号","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"digamma (special.digamma())：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"erf (special.erf())：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"erfc (special.erfc())：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"erfinv (special.erfinv())：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"fake_quantize_per_channel_affine：返回一个新张量，其中输入假数据中的数据使用 scale、zero_point、quant_min 和 quant_max 在指定 axis 的通道上按通道进行量化","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"fake_quantize_per_tensor_affine：返回一个新张量，其中输入假数据中使用 scale、zero_point、quant_min 和 quant_max 量化","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"fix (trunc())：","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"fmod：Applies C++’s std::fmod entrywise.","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"gradient：使用二阶精确中心差法（ second-order accurate central differences method）估计函数 gmathbbR^nrightarrow mathbbR 在一个或多个维度上的梯度","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"imag：将张量自身虚数部分作为新张量进行返回","category":"page"},{"location":"py_module/torch/#自动微分机制","page":"-","title":"自动微分机制","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"Autograd Mechanics","category":"page"},{"location":"py_module/torch/#问题","page":"-","title":"问题","text":"","category":"section"},{"location":"py_module/torch/","page":"-","title":"-","text":"❓item() 和 detach() 的区别是什么？","category":"page"},{"location":"py_module/torch/","page":"-","title":"-","text":"item() 返回的是 Tensor 中的值，且只能返回单个值（即标量），不能返回向量；\ndetach() 是阻断反向传播，返回值仍然为 Tensor；","category":"page"},{"location":"AI/GNN/#通用框架","page":"图神经网络","title":"通用框架","text":"","category":"section"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"除了图神经网络的不同变体，人们还提出了一些通用框架，旨在将不同的模型集成到单一的框架中。^1","category":"page"},{"location":"AI/GNN/#消息传递神经网络","page":"图神经网络","title":"消息传递神经网络","text":"","category":"section"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"消息传递神经网络^2（MPNN, Message Passing Neural Network）包含两个阶段：消息传递阶段和读出阶段。\t","category":"page"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"","category":"page"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"参考：","category":"page"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"[1] 刘知远，周界，《图神经网络导论》","category":"page"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"[2]  J. Gilmmer, S. S. Schoenholz, P. F. Riley, et al. Neural message passing for quantum chemistry. In Proc. of ICML, 2018: 1263-1272. ","category":"page"},{"location":"AI/GNN/","page":"图神经网络","title":"图神经网络","text":"[3] 刘忠雨，李彦霖，周洋，《深入浅出图神经网络》","category":"page"},{"location":"AI/DeepLearn/#逐层归一化","page":"-","title":"逐层归一化","text":"","category":"section"},{"location":"AI/DeepLearn/","page":"-","title":"-","text":"逐层归一化（Layer-wise Normalization）是将传统机器学习中的数据归一化应用到深度神经网络中，对神经网络中隐藏层的输入进行归一化，从而使得网络更容易训练。","category":"page"},{"location":"AI/DeepLearn/#批量归一化","page":"-","title":"批量归一化","text":"","category":"section"},{"location":"AI/DeepLearn/","page":"-","title":"-","text":"批量归一化（Batch Normalization, BN）中，如果 input batch 的 shape 为 (B, C, H, W)，统计出的 mean 和 variance 的 shape 为 (1, C, 1, 1). ","category":"page"},{"location":"competition/","page":"-","title":"-","text":"在竞赛的时候，数据探索一般分为三个部分：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"首先是赛前数据探索，也叫数据初探，帮助我们对数据有个整体性的认识，并发现数据中存在的问题，比如缺失值、异常值和数据冗余等；\n其次是竞赛中的数据探索，通过分析数据发现变量的特点，帮助提取有价值的特征，可以从单变量、多变量和变量分布进行分析；\n最后是模型的分析，可以分为特征重要性分析和结果误差分析，帮助我们从结果发现问题，并且进一步优化；","category":"page"},{"location":"competition/","page":"-","title":"-","text":"数据探索主要采用的方法：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"单变量可视化分析：提供原始数据集中每个字段的摘要统计信息；\n对于连续型变量，需要统计数据的中心分布趋势和变量的分布\n对于类别型变量，一般使用频次或占比表示每一个类别的分布情况，可以用柱形图来表示可视化分布情况\n多变量可视化分析：用来了解不同变量之间的交互关系；\n连续型与连续型：\n绘制散点图：通过形状可以很直观的判断变量之间是线性和还是非线性的\n计算相关性：相关性系数的绝对值为 0 ~ 0.09 为没有相关性，0.1 ~ 0.3 为弱相关，0.3 ~ 0.5 为中等相关，0.5 ~ 1.0 为强相关\n类别型与类别型：\n双向表：通过建立频次（次数）和频率（占比）的双向表来分析变量之间的关系\n堆叠柱状图：更为直观\n卡方检验：用于两个和两个以上样本率（构成比）及两个二值型离散变量的关联性分析，即比较理论频次与实际频次的吻合程度或拟合优度\n类别型与连续型：可以绘制小提琴图（Voilin Plot），可以分析类别变量在不同类别时，另一个连续变量的分布情况\n降维分析：有助于发现数据中特征变量之间方差最大的字段，并可以在保留最大信息量的同时减少数据维度；","category":"page"},{"location":"competition/","page":"-","title":"-","text":"缺失值产生的原因：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"机械原因：数据存储的失败、存储器损坏、机械故障导致某段时间的数据未能收集\n人为原因：市场调查中被访人拒绝透露相关问题的答案，或者回答的问题是无效的，数据漏录","category":"page"},{"location":"competition/","page":"-","title":"-","text":"缺失值主要分为 4 类：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"完全随机丢失：对于所有观察结果，丢失的概率是相同的。\n随机丢失：变量的值丢失的概率会因为其他输入变量的值或级别不同而变化。例如女性年龄缺失率比男性高；\n不可预测因子导致的缺失：数据不是随机丢失，而是受到一些潜在因子的影响。\n取决于自身的缺失：发生缺失的概率受缺失值本身的影响。例如收入特别高或者特别低的人不愿意透露自己的收入。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"缺失值的处理方法：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"删除：成列删除（List Wise Deletion）和成对删除（Pair Wise Deletion）。成列删除会使得样本减少，可能会造成拟合能力降低；成对删除可以保留更多的样本，但是对于不同的变量要使用不同大小的样本集。\n平均值、众数、中值填充：分为「一般填充」和「相似样本填充」。一般填充是用该变量下所有非缺失值的均值或中值来补缺；相似样本填充是利用具有相似特征的样本的值或者近似值进行填充\n预测模型填充：利用没有缺失值的数据作为训练集来训练预测网络。不足之处在于如果变量之间不存在关系，得到的缺失值会不准确。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"异常值：远远偏离整个样本总体的观测值","category":"page"},{"location":"competition/","page":"-","title":"-","text":"异常值产生的原因：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"数据输入误差：数据手机、输入过程中，人为错误产生的误差。例如数据录入的时候打错。\n测量误差：最常见的异常值来源。\n实验误差\n有意造成的异常值：涉及敏感的数据。例如青少年报告消费的酒精量，经常是比较少的\n数据处理误差：操作或提取的过程中造成的误差\n采样误差","category":"page"},{"location":"competition/","page":"-","title":"-","text":"异常值的影响：增加模型预测的错误方差，降低模型的拟合能力。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"异常值的检测：一般采用可视化方法进行异常值检测","category":"page"},{"location":"competition/","page":"-","title":"-","text":"箱线图：不在 -1.5IQR 和 1.5IQR 之间的样本点认为是异常值。使用封顶方法可以认为在第 5 和第 95 百分位数范围之外的任何值都是异常值；距离平均值为三倍标准差或者更大的数据点可以认为是异常值\n直方图：\n散点图：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"异常值的处理：一般采用删除、转换、填充、区别对待等方法","category":"page"},{"location":"competition/","page":"-","title":"-","text":"删除：如果是由输入误差、数据处理误差引起的异常值，或者异常值很小，则可以直接将其删除\n转换：例如有的时候对数据取对数会减轻由极值引起的变化\n填充：如果是认为造成的，可以使用均值、中值等填充处理\n区别对待：如果存在大量的异常值，就应该区别对待。例如将数据分为两组，分别建模，最终将两组的输出合并","category":"page"},{"location":"competition/","page":"-","title":"-","text":"变量转换：一些变量的取值分布不平均，会极大影响估计。可以对变量的取值区间等进行转换，使其分布落在合理的区间内","category":"page"},{"location":"competition/","page":"-","title":"-","text":"变量转换的方法主要包括：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"缩放比例或标准化：不会更改变量的分布\n非线性关系转换成线性：对数变换是常用的一种方式\n使倾斜分布对称：对于向右倾斜的分布，对变量取平方根或者立方根或者对数；对于向左倾斜的分布，对变量取平方或立方或指数；\n变量分组：根据不同的目标把变量按不同类别分组","category":"page"},{"location":"competition/","page":"-","title":"-","text":"变量转换方法：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"对数变换：对变量取对数，通常用于向右倾斜的分布，缺点是无法用于含有零或者负值的变量；\n取平方根或立方根：对其分布有波形的影响\n变量分组：对变量进行分类，可以基于原始值、百分比或者频率来分类","category":"page"},{"location":"competition/","page":"-","title":"-","text":"变量生成：基于现有变量生成新变量的过程。新变量可能与目标变量有更好的相关性，有助于进行数据分析","category":"page"},{"location":"competition/","page":"-","title":"-","text":"变量生成的方法：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"创建派生变量：使用一组函数或者不同方法从现有变量创建新变量。\n创建哑变量：可以将类别型变量转换成数值型变量","category":"page"},{"location":"competition/","page":"-","title":"-","text":"特征工程：就是从原始数据提取可以很好地描述数据的特征的过程，让模型能够的性能表现可以达到最优，接近最佳性能","category":"page"},{"location":"competition/","page":"-","title":"-","text":"特征工程包括特征使用、特征获取、特征处理、特征选择和特征监控","category":"page"},{"location":"competition/","page":"-","title":"-","text":"特征工程的处理流程：（1）去掉无用特征（2）去除冗余特征，如共线特征，并利用存在的特征、转换特征、内容中的特征以及其他数据源生成新特征（3）对特征进行转换：数值化、类别转换、归一化等（4）最后对特征进行处理：异常值、最大值、最小值、缺失值等","category":"page"},{"location":"competition/","page":"-","title":"-","text":"数据预处理：特征提取之前要对数据进行预处理，包括数据采集、数据清洗、数据采样","category":"page"},{"location":"competition/","page":"-","title":"-","text":"特征处理：标准化、区间缩放法、归一化、定量特征二值化、定性特征哑编码、缺失值处理和数据转换","category":"page"},{"location":"competition/","page":"-","title":"-","text":"标准化：通过求标准分数的方法，将特征转换为标准正太分布，并和整体样本分布相关。使用 sklearn.preprocessing 的 StandardScaler 类来实现。\n区间缩放法：最常用的是利用最大最小值进行缩放。使用 sklearn.preprocessing 的 MinMaxScaler 类来实现。\n归一化：将样本的特征值转换到同一量纲下，会改变数据的原始距离、分布和信息，但标准化一般不会。使用 sklearn.preprocessing 的 Normalizer 类来实现。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"要使用归一化还是标准化：","category":"page"},{"location":"competition/","page":"-","title":"-","text":"如果对输出结果范围有要求，则使用归一化\n如果数据较为稳定，不存在极端的最大值或最小值，则用归一化\n如果数据存在异常值和较多早上，使用标准化，这样可以通过中心化间接避免异常值和极端值的影响\n支持向量机、K 近邻、主成分分析等模型都必须进行归一化或标准化操作","category":"page"},{"location":"competition/","page":"-","title":"-","text":"定量特征二值化：核心在于设定一个阈值，大于阈值的变为 1，小于等于阈值的变为 0. 使用 sklearn.preprocessing 的 Binarizer 类来实现。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"定性特征哑编码：哑变量（Dummy Variable）也称为虚拟变量，通常是认为虚设的变量，取值为 0 或 1，用来反映某个变量的不同属性。哑变量可以把原本不能定量处理的变量进行量化，从而评估定性因素对因变量的影响。使用 sklearn.preprocessing 的 OneHotEncoder 类来实现哑编码。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"缺失值处理：使用 sklearn.impute 的 SimpleImputer 类来实现。","category":"page"},{"location":"competition/","page":"-","title":"-","text":"数据转换：常见的有基于多项式的、指数函数的和对数函数的转换方式。使用 sklearn.preprocessing 的 PolynomialFeatures 类来实现多项式转换；FunctionTransformer 类来实现函数转换","category":"page"},{"location":"competition/","page":"-","title":"-","text":"类 功能 说明\nStandardScaler 无量纲化 将特征值转换为服从标准正态分布\nMinMaxScaler 无量纲化 利用最大最小值进行缩放到特定区间\nNormalizer 归一化 基于特征矩阵的行，将样本向量转换为单位向量\nBinarizer 定量特征二值化 基于给定阈值，将定量特征按阈值划分\nOneHotEncoder 定性特征哑编码 将定性特征编码为定量特征\nImputer 缺失值处理 填充缺失值\nPolynomialFeatures 多项式数据转换 多项式数据转换\nFunctionTransformer 自定义单元数据转换 使用指定函数进行数据转换","category":"page"},{"location":"competition/","page":"-","title":"-","text":"特征降维：可以去除原始数据中包含的冗余信息以及噪声信息，降低模型识别造成的误差，提高准确率。通常有特征选择和线性降维","category":"page"},{"location":"competition/","page":"-","title":"-","text":"特征选择：常用于数据分析和简单建模中。映射函数直接将不重要的特征删除，","category":"page"},{"location":"vim/#vim-快捷键总结","page":"Vim 使用","title":"vim 快捷键总结","text":"","category":"section"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":"vim 最常用的两种模型：「普通模式」和「输入模式」","category":"page"},{"location":"vim/#普通模式下的快捷键","page":"Vim 使用","title":"普通模式下的快捷键","text":"","category":"section"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":":w 保存文本","category":"page"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":":q 退出文本（如果文本做了改动会退不出去）","category":"page"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":":q! 强制退出不保存文本","category":"page"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":":wq 保存文件并退出","category":"page"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":"i 在光标位置开始输入（左下角会有 --- INSERT --- 的提示），在插入模型下","category":"page"},{"location":"vim/","page":"Vim 使用","title":"Vim 使用","text":"在 10 行和 112 行之间插入 4 空格：10,112 s/^/    /","category":"page"},{"location":"vim/#vim-配置","page":"Vim 使用","title":"vim 配置","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"查看 dict 里是否有某个 key：haskey(dick, key)","category":"page"},{"location":"lang/Julia/#Distributions.jl","page":"Julia","title":"Distributions.jl","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"离散分布（Discrete Distributions）的类型","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"按照给定分布进行采样","category":"page"},{"location":"lang/Julia/#CurveFit.jl","page":"Julia","title":"CurveFit.jl","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"CurveFit.jl 是 Julia 中实现曲线拟合的包。","category":"page"},{"location":"lang/Julia/#线性最小二乘法","page":"Julia","title":"线性最小二乘法","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"线性最小二乘法（Linear Least Square）常用于寻找离散数据集的近似值。给定点集 x[i] 和 y[i] 以及一系列函数 f_i(x)，最小二乘法通过最小化与 y[i] 相关的误差平方来找到对应的系数 a[i]，例如 a[1]*f_1(x) + a[2]*f_2(x) + ... + a[n]*f_n(x).","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"基础功能用 QR 分解来实现：A \\ y：coefs = A \\ y，其中 A[:. i] = f_i(x). 通常 x 是单个变量，如果需要多个自变量，可以使用相同的过程，类似于：A[:, i] = f_i(x1, x2, ..., xn).","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"不同的拟合方式：","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"linear_fit(x, y) finds coefficients a and b for y[i] = a + b*x[i]\npower_fit(x, y) finds coefficients a and b for y[i] = a *x[i]^b\nlog_fit(x, y) finds coefficients a and b for y[i] = a + b*log(x[i])\nexp_fit(x, y) finds coefficients a and b for y[i] = a*exp(b*x[i])\nexpsum_fit(x, y, 2, withconst = true) finds coefficients k, p, and λ for y[i] = k + p[1]*exp(λ[1]*x[i]) + p[2]*exp(λ[2]*x[i])\npoly_fit(x, y, n) finds coefficients a[k] for y[i] = a[1] + a[2]*x[i] + a[3]*x[i]^2 + a[n+1]*x[i]^n\nlinear_king_fit(E, U), find coefficients a and b for E[i]^2 = a + b*U^0.5\nlinear_rational_fit(x, y, p, q) finds the coefficients for rational polynomials: y[i] = (a[1] + a[2]*x[i] + ... + a[p+1]*x[i]^p) / (1 + a[p+1+1]*x[i] + ... + a[p+1+q]*x[i]^q)","category":"page"},{"location":"lang/Julia/#非线性最小二乘法","page":"Julia","title":"非线性最小二乘法","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"有时拟合函数相对于拟合系数是非线性的。 在这种情况下，给定系数的近似值，拟合函数围绕该近似值线性化，并且线性最小二乘法用于计算对近似系数的校正。 重复此迭代直到达到收敛。 拟合函数具有以下形式：f(x_1, x_2, x_3, ..., x_n, a_1, a_2, ..., a_p) = 0，其中 xi 是已知的数据点，ai 是要拟合的系数。","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"当模型公式在拟合系数上不是线性时，非线性算法是必要的。 这个库实现了一个不明确需要导数的牛顿型算法。 这是在函数中实现的：coefs, converged, iter = nonlinear_fit(x, fun, a0, eps=1e-7, maxiter=200)","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"在这个函数中，x 是一个数组，其中每一列代表数据集的一个不同变量，fun 是可调用的（callable），它返回拟合误差，要求可以使用以下签方式调用：residual = fun(x, a)，其中 x 是一个表示一行参数数组 x 的向量，a 是拟合系数的估计值，这些系数都不能为零（以提供比例）。eps  和 maxiter 是收敛参数。","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"nonlinear_fit 函数用于实现一下拟合函数：","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"king_fit(E, U) find coefficients a, b and n for E[i]^2 = a + b*U^n\nrational_fit Just like linear_rational_fit but tries to improve the results using nonlinear least squares (nonlinear_fit)","category":"page"},{"location":"lang/Julia/#通用接口","page":"Julia","title":"通用接口","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"CurveFit.jl 开发了方便使用不同曲线拟合的通用接口：fit = curve_fit(::Type{T}, x, y...)，其中 T 是 curve fitting type，The following cases are implemented:","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"curve_fit(LinearFit, x, y)\ncurve_fit(LogFit, x, y)\ncurve_fit(PowerFit, x, y)\ncurve_fit(ExpFit, x, y)\ncurve_fit(Polynomial, x, y, n=1)\ncurve_fit(LinearKingFit, E, U)\ncurve_fit(KingFit, E, U)\ncurve_fit(RationalPoly, x, y, p, q)","category":"page"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"curve_fit 通用函数返回一个对象，该对象可用于使用 apply_fit 计算模型的估计值。 call 被重载，以便对象可以用作函数。","category":"page"},{"location":"lang/Julia/#用例","page":"Julia","title":"用例","text":"","category":"section"},{"location":"lang/Julia/","page":"Julia","title":"Julia","text":"using PyPlot\nusing CurveFit\n\nx = 0.0:0.02:2.0\ny0 = @. 1 + x + x*x + randn()/10\nfit = curve_fit(Polynomial, x, y0, 2)\ny0b = fit.(x) \nplot(x, y0, \"o\", x, y0b, \"r-\", linewidth=3)","category":"page"},{"location":"lang/Python/#基础知识","page":"Python","title":"基础知识","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：什么是 Python？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 是动态强类型语言，动态还是静态指的是编译器确定类型还是运行期确定类型，强类型指的是不会发生隐式类型转换；\nPython 是鸭子类型语言，关注的是对象的行为，而不是类型。比如只要定义了 __iter__ 方法的对象都可以用 for 迭代；\nPython 是一种解释型语言，在代码运行之前不需要解释；\nPython 适合面向对象的编程，因为它支持通过组合与继承的方式定义类；\nPython 代码编写快，但是运行速度比编译型语言通常要慢；\nPython 用途广泛，常被用作「胶水语言」，可以帮助其他语言和组件改善运行状况；\nPython 程序员可以专注于算法和数据结构的设计，而不用处理底层的细节；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"JavaScript 就是典型的弱类型语言，比如数字和字符串的相加，会生成字符串；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"当一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"最直观的理解「鸭子类型」的例子：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"class Duck: \n    def say(self):\n        print(\"GaGa. \")\n        \nclass Dog:\n    def say(self):\n        print(\"WangWang. \")\n        \ndef speak(duck):\n    duck.say()\n\nduck = Duck()\ndog = Dog()\nspeak(duck)  # GaGa. \nspeak(dog)  # WangWang. ","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：Python2 和 Python3 的区别？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"print 在 Python2 中是关键字，而在 Python3 中是一个函数；\n编码：Python3 中不再有 unicode 对象，默认 str 就是 unicode，而 Python2 的是 bytes；\n除法：Python2 中两个整型除法返回整数；而在 Python3 中返回浮点数，要返回整数应该使用 //；\n类型注解：Python3 的类型注解可以帮助 IDE 实现类型检查；\n优化 super() 方便直接调用父类：Python3 中可以直接使用 super().xxx 代替 super(Class, self).xxx；\n高级解包操作：Python3 可以有这样的语句 a, b, *rest = range(10)；\n限定关键字参数：keyword only arguments；\nPython3 重新抛出异常不会丢失栈信息；\nPython3 文件的默认编码是 utf8，而 Python2 文件的默认编码是 ascii；\nPython3 的 range() 返回的是一个可迭代对象，而 Python2 的是返回一个列表，xrange() 才会返回一个可迭代对象；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 对于以下代码\n# 1. 两个整数相除，结果为整数\n# 2. 操作数之一是浮点，则两个数都转化为浮点计算\nprint type(1/2)  # Python 2.x\n>>> <type 'int'>\n\n# 无论是什么类型，都是按照正常的除法进行\nprint(type(1/2)) # Python 3.x\n>>> <type 'float'>","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：Python 中的作用域","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定。当 Python 遇到一个变量的话它会按照这个顺序进行搜索：本地作用域（Local）=> 当前作用域被嵌入的本地作用域（Enclosing Locals）=> 全局/模块作用域（Global）=> 内置作用域（Built-in）","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：什么是 Python 自省？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 自省是 Python 具有的一种能力，使得程序员面向对象的语言所写的程序在运行时，能够获得对象的类 Python 型。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：有哪些提升 Python 性能的手段？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"使用多进程，充分利用机器的多核性能；\n对于性能影响较大的部分代码，可以用 C 或 C++ 编写；\n对于 IO 阻塞造成的性能影响，可以使用 IO 多路复用来解决；\n尽量使用 Python 的内建函数；\n尽量使用局部变量；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：如何在 Python 中管理内存？Python 的内存管理机制是什么？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 中的内存管理由 Python 私有堆空间管理。所有 Python 对象和数据结构都位于私有堆中。程序员无权访问此私有堆，Python 解释器负责处理这个问题。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 对象的对空间分配由 Python 的内存管理器完成，核心 API 提供了一些程序员编写代码的工具。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 还有一个内置的垃圾收集器，可以回收所有未使用的内存，并使其可用于堆空间。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"关于 __name__：一个模块中，","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"如果直接运行文件 __name__ 为 __main__；\n如果该模块被调用，__name__ 为被调用模块的模块名；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# print_func.py 的代码如下\nprint('Hello World!')\nprint('__name__ value: ', __name__)\n \ndef main():\n    print('This message is from main function')\n \nif __name__ == '__main__':\n   main()\n\n\n# print_module.py 的代码如下\nimport print_func\nprint(\"Done!\")\n\n\n# 运行 print_module.py 的结果\n>>> Hello World! __name__ value: print_func  Done! ","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"py 文件执行完保持交互界面：在终端用命令行 python file.py 执行 py 文件的时候，有时候想要继续测试代码，那么可以在文件的最后添加上下面的两行代码，这样在执行完 py 文件之后就会保持命令行交互界面不退出。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 执行完不退出 Python 交互\nimport code\ncode(banner=\"\", local=locals())","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"filter(object)：将迭代器的数据代入函数中，返回使函数返回值为 True 的值","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndef is_even(n):\n    return n % 2 == 0\n\nprint(list(filter(is_even(), a)))  # 会报错\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: is_even() missing 1 required positional argument: 'n'\n\n# 正确的表达\nprint(list(filter(is_even, a)))  # 注意函数 is_even 后面不用加括号\n# 不严谨地说, 类似于\n[is_even(item) for item in a]","category":"page"},{"location":"lang/Python/#标准库","page":"Python","title":"标准库","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"常用的 Python 标准库：os（操作系统）、time（时间）、random（随机）、pymysql（连接数据库）、threading（线程）、multiprocessing（进程）、queue（队列）","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"常用的第三方库：django、flask、requests、virtualenv、selenium、scrapy、xadmin、celery、re、hashlib、md5","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"常用科学计算库：NumPy、Pandas、Matplotlib、SciPy","category":"page"},{"location":"lang/Python/#os-模块","page":"Python","title":"os 模块","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"常用方法：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.remove()：删除文件；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.rename()：重命名文件；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.walk()：生成目录树下的所有文件；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.chdir()：改变目录；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.mkdir/makedirs：创建目录/多层目录；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.rmdir/removedirs：删除目录/多层目录；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.listdir()：列出指定目录的文件；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.getcwd()：取得当前工作目录；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.chmod()：改变目录权限；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.basename()：去掉目录路径，返回文件名；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.dirname()：去掉文件名，返回目录路径；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.join()：将分离的各部分组合成一个路径名；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.split()：返回 (dirname(), basename()) 元组；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path,splitext()：返回 (filename, extension) 元组；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.getatime/ctime/mtime：分别返回最近访问、创建、修改时间；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.getsize()：返回文件大小；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.exists()：是否存在；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.isabs()：是否为绝对路径；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.isdir()：是否为目录；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path.isfile()：是否为文件；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：os.path 和 sys.path 分别代表什么？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"os.path 主要是用于对系统路径文件的操作；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"sys.path 主要是对 Python 解释器的系统环境参数的操作（动态的改变 Python 解释器搜索路径）；","category":"page"},{"location":"lang/Python/#随机数（random）","page":"Python","title":"随机数（random）","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"在 Python 中用于生成随机数的模块是 random：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"random.random()：生成一个 0 - 1 之间的随机浮点数；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"random.uniform(a, b)：生成 [a, b] 之间的浮点数；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"random.randint(a, b)：生成 [a, b] 之间的整数；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"random.randrange(a, b, step)：在指定的集合 [a, b) 中，以 step 为基数随机取一个数；；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"random.choice(sequence)：从特定序列中随机取一个元素，这里的序列可以是字符串、列表、元组等；","category":"page"},{"location":"lang/Python/#类","page":"Python","title":"类","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"在默认情况下，Python 中的成员函数和成员变量都是公开的（Public），在 Python 中定义私有变量只需要在变量名或函数名前面加上双下划线 __，那么这个函数或者变量就变成私有的了。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓什么是 Python 的 Name Mangling 技术？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"对于私有变量（即名字前面有双下划线的 __），在内部 Python 实际上是将 __membername 替换成 _classname__membername。也就是说，类的内部定义中，所有以双下划线开始的名字，在前面都会加上单下划线和类名。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"这样一来 Python 实际上就没有实现真正的私有化，我们依旧可以通过 实例._类名__变量名 的方式来访问「伪私有变量」。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 里面的变量分为四种（假设 xxx 为名字）：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"公开的（Public）：直接用名字来标识 xxx，用户和类都能够访问；\n保护的（Protected）：单下划线 _xxx，只有类实例和子类实例能够访问到。需要通过类提供的接口进行访问，不能用 from module import * 的方式导入；\n私有的（Private）：双下划线 __xxx，只有类对象自己能够访问，连子类对象也不能访问到这个","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"类变量：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"类和实例都能访问；\n通过类名修改类变量，会作用到所有的实例化对象；\n通过类对象无法改变类变量。通过类对象对类变量赋值，本质不再是修改类变量的值，而是在给该对象定义新的实例变量。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"class Base(object):\n    count = 0\n    \n    def __init__(self):\n        pass\n    \nb1 = Base()\nb2 = Base()\nb1.count = b1.count + 1\nprint(b1.count, end=\" \")\nprint(Base.count, end=\" \")\nprint(b2.count)\n>>> 1 0 0","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：__init__ 和 __new__ 的区别是什么？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"当我们使用 类名() 创建对象的时候，Python 解释器会帮我们做两件事情：第一件是为对象在内存分配空间，第二件是为对象进行初始化。「分配空间」是 __new__ 方法，初始化时 __init__ 方法。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"__new__ 方法在内部其实做了两件事情：第一件事是「为对象分配空间」，第二件事情是「把对象的引用返回给  Python 解释器」。当 Python 的解释器拿到了对象的引用之后，就会把对象引用传递给 __init__ 的第一个参数 self，__init__ 拿到对象的引用之后，就可以在方法的内部，针对对象来定义实例属性。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"之所以要学习 __new__ 方法，就是因为需要对分配空间的方法进行改造，改造的目的就是为了当使用 类名() 创建对象的时候，无论执行多少次，在内存中永远只会创造出一个对象的实例，这样就可以达到单例设计模式的目的。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：什么是元类？它的使用场景是什么？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"元类是创建类的类，type 还有继承自 type 的类都是元类。它的作用是在类定义时 (new, init) 和类实例化时 (call) 可以添加自定义功能。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"使用场景：ORM 框架中创建一个类就代表数据库中的一个表，但是定义这个类时为了统一需要把里面的类属性全部改为小写，这个时候就要用元类重写 new 方法，把 attrs 字典里的 key 转为小写。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：如何节省内存地创建百万级实例？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"可以定义类的 __slots__ 属性，用它来声明实例属性的列表，可以用来减少内存空间。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：什么是 Python 的重用对象内容？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"为了提高内存利用效率，对于一些简单的对象，如一些数值较小的 int 对象（范围在 [-5, 257)），字符串对象等，Python 采用重用对象内容的方法。在 Python 3.6 中小整数对象池的范围会更大。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"a = [1, 2, 3]\nb = [1, 2, 4]\nid(a[1]) == id(b[1])  # 结果为 True\n\na[1] is b[1]  # 结果也为 True\n# 1. is 比较两个对象的 id 值是否相等，是否指向同一个内存地址；\n# 2. == 比较两个对象的内容是否相等，值是否相等","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"对于 += 操作，如果是可变对象，则操作前后序列的 id 值不变，如果是不可变对象，则操作前后序列的 id 值会改变。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 列表是可变对象\nlis = [1, 3, 2]\na = id(lis)\nlis += [4, 5]\nb = id(lis)\nprint(a == b)  # True\n\n# 元祖是不可变对象\ntup = (1, 3, 2)\na = id(lis)\ntup += (4, 5)\nb = id(tup)\nprint(a == b)  # False","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓Python 模块的相互引用是怎么样的？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"参考：https://zhuanlan.zhihu.com/p/349407590","category":"page"},{"location":"lang/Python/#函数","page":"Python","title":"函数","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：Python 是如何传递参数的？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"官方文档：Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per Se.","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"在 Python 中，参数是通过赋值传递的（pass by assignment），或者叫作对象的引用传递（pass by object reference）。由于赋值只是创建对对象的引用，因此调用者和被调用者中的参数名称之间没有别名。Python 里面所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"根据对象的引用来传递，根据对象是可变对象还是不可变对象，得到两种不同的结果。如果是可变对象，则直接修改，如果是不可变对象，则产生新的对象，让形参指向新对象。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 可变对象\ndef flist(l):\n    l.append(0)\n    print(id(l))    # 每次打印的 id 相同，并且与 [1] 行输出的 id 一样\n    print(l)\n\n\nll = []\nprint(id(ll))  # [1]\nflist(ll)   # [0]\nflist(ll)   # [0, 0]\n\n# 不可变对象\ndef fstr(s):\n    print(id(s)) # 和入参 ss 的 id 相同\n    s += \"a\"\n    print(id(s))  # 和入参 ss 的 id 不同，每次打印结果不相同\n    print(s)\n\n\nss = \"sun\"\nprint(id(ss))\nfstr(ss)    # a\nfstr(ss)    # a\n\n# 默认参数只算一次\ndef fl(l=[1]):\n    l.append(1)\n    print(l)\n\nfl()  # [1]\nfl()  # [1, 1]","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"推荐阅读 Stack Overflow - How do I pass a variable by reference? ","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：闭包是什么？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"闭包就是一个嵌套函数，它的内部函数使用了外部函数的变量或参数，它的外部函数返回了内部函数可以保存外部函数内的变量，不会随着外部函数调用完而销毁。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 函数的闭包：如果在函数中定义的 lambda 或者 def 嵌套在一个循环之中，而这个内嵌函数又引用了一个外层作用域的变量，该变量被循环所改变，那么所有在这个循环中产生的函数会有相同的值 —— 也就是在最后一次循环中完成时被引用变量的值。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"def fn():\n    t = []\n    i = 0  # 外层作用域\n    while i < 2:\n        t.append(lambda x: print(i * x, end=\",\"))\n        i += 1\n    return t\n\nfor f in fn():  # fn() 执行完之后 i = 2\n    f(2)  # t = [lambda x: print(2 * x, end=\",\"), lambda x: print(2 * x, end=\",\")]\n>>> 4,4,","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"若函数体内对一个变量重新赋值，会使得函数内部屏蔽了外面的全局变量，导致报错","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":">>> num = 1\n>>> def fn():\n...     num += 1\n...     return lambda: print(num)\n... \n>>> x = fn()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 2, in fn\nUnboundLocalError: local variable 'num' referenced before assignment","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：什么是装饰器？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"装饰器是一个接受函数作为参数的闭包函数，它可以在不修改函数内部源代码的情况下，给函数添加额外的功能：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：Python 中的 *args* 和 `kwargs` 是什么？**","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"*args 和 **kwargs 是 Python 中方法的可变参数。*args 表示任何多个无名参数，是一个 Tuple；**kwargs 表示多个关键字参数，是一个 Dict。同时使用时 *args 参数要在 **kwargs 前面。当方法的参数不确定时，可以使用 *args 和 **kwargs.","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"a, *b, c = range(5)  # *b: 剩下的参数会分配给 b\nprint(a, b, c)\n>>> 0 [1, 2, 3] 4\n\n*a, *b, c = range(5)  # 这种表达会报错\n>>> SyntaxError: two starred expressions in assignment","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 参数传递采用的是「传对象引用」的方式，这种方式相当于传值和传引用的一种综合。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"如果函数收到的是一个可变对象（比如 字典 或者 列表）的引用，就能修改对象的原始值 —— 相当于通过「传引用」来传递对象。\n如果函数收到的是一个不可变对象（比如 数字、字符 或者 元组）的引用，就不能直接修改原始对象 —— 相当于通过「传值」来传递对象。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"def changeList(nums):\n    nums.append('c')\n    print(\"nums\", nums)\n\nstr1 = ['a', 'b']\n# 调用函数\nchangeList(str1)\nprint(\"str1\", str1)\n>>> nums ['a', 'b', 'c'], str1 ['a', 'b', 'c']","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 的默认参数只在函数定义时被赋值一次，而不会每次调用函数时又创建新的引用，函数定义完成后，默认参数已经存在固定的内存地址。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"如果使用一个可变的默认参数并对其进行改变，那么以后对该函数的调用都会改变这个可变对象\n默认参数如果是不可变对象，不存在该问题，每次调用都会将其变为默认值","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"def fun(a = (), b = []):\n    a += (1,)\n    b.append(1)\n    return a, b\n\nfun()\nprint(fun())\n>>> ((1,), [1, 1])\n# !!! 注意 a == (1,)，而 b = [1, 1]","category":"page"},{"location":"lang/Python/#函数修饰器","page":"Python","title":"函数修饰器","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"函数修饰符 @：可以理解为引用、调用它修饰的函数","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"def test(f):\n    print(\"before ...\")\n    f()\n    print(\"after ...\")\n    \n@test\ndef func():\n    print(\"func was called\")\n\n# 运行之后的输出结果为\n>>> before ...\n>>> func was called\n>>> after ...","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"当 Python 解释器读到函数修饰符 @ 的时候，执行的步骤为：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"调用 test 函数，test 函数的入口参数就是 func 函数；\ntest 函数被执行，入口参数的函数（func 函数）也会被调用；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"def dec(f):\n    n = 3\n    \n    def wrapper(*args, **kw):\n        return f(*args, **kw) * n\n    \n    return wrapper\n\n@dec\ndef foo(n):\n    return n * 2\n\nfoo(2) == 12  # True\nfoo(3) == 18  # True\n\n# *args, **kw 是参数，用的是我们调用函数 foo(n) 时候的参数 n，\n# 注意与 dec(f) 里的 n = 3 作区分\n# 当我们利用了修饰符之后，就相当于\nfoo = dec(foo)","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"@property：相当于一个 get 方法，用于获取私有属性值，可以使得类有一个与方法同名的属性。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"@*.setter：其中星号 * 代表方法名，它的两个作用是 1、对要存入的数据进行预处理；2、设置可读（不可修改）的属性。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"注意：@*.setter 装饰器必须在 @property 装饰器的后面，并且两个被修饰的函数名词必须保持一致。","category":"page"},{"location":"lang/Python/#数据结构","page":"Python","title":"数据结构","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python3 中有 6 个标准的数据类型：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"不可变数据：Number（数字）、String（字符串）Tuple（元祖）\nNumber：包括整型、浮点型、复数、布尔型；\n可变数据：List（列表）、Dictionary（字典）、Set（集合）","category":"page"},{"location":"lang/Python/#列表","page":"Python","title":"列表","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"列表的切片一般指创造新的对象，是浅拷贝，不会有索引越界的情况，如果超出了列表的索引范围不会报错，会输出空列表。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"lists = [1, 2, 3, 4, 5, 6]\nprint(lists[6:])\n>>> []","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 列表的生成","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"注意：在生成列表的时候，最好用 [0 for _ in range(n)] 的方式而不是 [0] * n 的方式生成，原因如下。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"假设我们想要创建一个长度为 n = 2 列表 a 的时候，一般的做法有两种：a = [0] * n 和 a = [0 for _ in range(n)]，在一维的时候两种方法没有区别。但是如果我们想要创建一个列表，列表中的每个元素都是长度为 m = 3 的列表时用两种方法出来的结果就是不同的：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"n, m = 2, 3\na = [[0] * n] * m  # 用第一种方法生成的\n# a = [[0, 0], [0, 0], [0, 0]]\nb = [[0 for _ in range(n)] for _ in range(m)]  # 用第二种方法生成的\n# b = [[0, 0], [0, 0], [0, 0]]\n\na[0][0] = 1  # 令 a 列表的第一个元素为 1\n# a = [[1, 0], [1, 0], [1, 0]]\nb[0][0] = 1\n# b = [[1, 0], [0, 0], [0, 0]]","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"我们的预期结果是像 b 这样的，也就是第一个列表的第一个元素等于 1，但是列表 a 是将每一个列表的第一个元素都设为 1 了。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"导致这种情况的原因在于，用第一种生成方法是类似于 = 的方式去生成的，也就是假设 a, b 都是列表，我们令 a = b，如果他们其中一个的元素改变了，另一个也会跟着变，例如：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"a = [0, 0, 0]\nb = a\nb[0] = 1\n# a = [1, 0, 0]\n# b = [1, 0, 0]","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"要想避免这样的情况，就应该这样写 b = list(a). ","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"回到一开始的问题，如果用第一种方法 a = [[0] * n] * m，那么 a 中的 m 个列表存储的地址都是一样的，那么你改变其中的一个列表，其他的列表都会跟着改变，就会出现上面的情况。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"c = [[0] * n for _ in range(m)]  # 没问题\nd = [[0 for _ in range(n)]] * m  # 有问题","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"所以，以后要生成的列表时候，一律用 [0 for _ in range(n)] 会更好。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：list 和 tuple 有什么区别？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"list 长度可变，tuple 长度不可变；\nlist 中元素的值可变，tuple 一旦创建成功，其中的元素就不可变；\nlist 支持 append，insert，remove，pop 等方法，tuple 都不支持；","category":"page"},{"location":"lang/Python/#字典","page":"Python","title":"字典","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"字典是 Python里唯一的映射类型，它存储了键值对的关联，是由键到键值的映射关系。存入字典里面的数据不会自动排序，可以使用 sort 函数对字典进行排序。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 字典里面有一个 get 方法\ndict.get(key, default)  # 当 key 对应的值存在时返回其本身，当 key 对应的值不存在时返回给定的 default 作为替代\n\ndict.pop(key)  # 删除 key 对应的 value，并且返回该 value","category":"page"},{"location":"lang/Python/#默认字典","page":"Python","title":"默认字典","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"defaultdict 中，当字典里的 key 不存在但被查找时，返回的不是 keyError 而是一个默认值。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"from collections import defaultdict  # 需要先导入\n# 用法 dict_type = defaultdict( factory_function)\ndict_int  = defaultdict(int)  # 不存在时返回 整数 0\ndict_set  = defaultdict(set)  # 不存在时返回 空集 {}\ndict_str  = defaultdict(str)  # 不存在时返回 空字符 \"\"\ndict_list = defaultdict(list) # 不存在时返回 空列表 []","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：list 和 dict 是怎么实现的？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"list 本质是顺序表，只不过每次表的扩容都是指数级，所以动态增删数据时，表并不会频繁改变物理结构，同时受益于顺序表遍历的高效性，使得 Python 的 list 综合性能比较优秀；\ndict 本质上是顺序表，不过每个元素存储位置的角标，不是由插入顺序决定的，而是由 key 通过哈希算法和其他机制动态生成的，key 通过哈希散列，生成 value 的存储位置，再保存或者读取这个 value，所以 dict 的查询时间复杂度是 mathcalO(1)；","category":"page"},{"location":"lang/Python/#字符串","page":"Python","title":"字符串","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"str.strip()  # 删除首尾的空格\nstr.rstrip()  # 仅删除末尾的空格\n\nstr.upper()  # 把所有字符中的小写字母转化成大写字母\nstr.lower()  # 把所有字符中的大写字母转化成小写字母\nstr.capitalize()  # 把第一个字母转化为大写字母，其余小写\nstr.title()  # 把每个单词的第一个字母转化为大写，其余小写\n\nstr.find(char, beg=0, end=len(strs))  # 表示在 str 中返回第一次出现 char 的位置下标, 找不到返回 -1\n# beg 表示在 strs 中的开始索引，默认为 0，end 为结束索引，默认为 strs 的长度。\nstr.index(char)  # 表示在 str 中返回第一次出现 char 的位置下标, 找不到会报错\n\nstr.rfind()  # 与 find 不同的在于它返回最后一次匹配的位置，如果匹配不到返回 -1\n\nstr.endswith(suffix[, start[, end]]) # 用于判断字符串是否以指定后缀结尾\n# 如果以指定后缀结尾返回 True，否则返回 False\n# start 与 end 为可选参数，代表检索字符串的开始和结束位置\n\nstr = \"Hello, Python\"\nsuffix = \"Python\"\nprint(str.endswith(suffix, 2))  # 从位置 2（'l'）开始判断字符串 str 是否以 suffix 结尾\n>>> True","category":"page"},{"location":"lang/Python/#集合","page":"Python","title":"集合","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"集合（set）是一个无序的不重复元素序列","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 集合 set 用大括号 {x, y,...} 或者 set() 来创建\n# 注意：空集合的创建只能用 set(), {} 是创建空字典\ns.add(x)  # 添加元素\ns.update(x)  # 添加的元素可以是列表、元祖、字典等\ns.remove(x)  # 移除元素, 如果元素不存在会报错\ns.discard(x)  # 移除元素，不存在不会报错\ns.pop()  # 随机删除集合中的一个元素\nlen(s)  # 计算集合元素的个数\ns.clear()  # 清空集合\nx in s  # 判断 x 是不是在集合中\n\n# 如果集合 A 是集合 B 的子集，方法 issubset() 返回 True\n# The issubset() method returns True if set A is the subset of B\nA.issubset(B)","category":"page"},{"location":"lang/Python/#全局解释器锁","page":"Python","title":"全局解释器锁","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：什么是 Python 中的 GIL？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"全局解释器锁（Global Interpreter Lock, GIL），它是解释器中一种线程同步的方式。对于每一个解释器进程都具有一个 GIL，它的直接作用是限制单个解释器进程中多线程的并行执行，使得即使在多核处理器上对于单个解释器进程来说，在同一个时刻运行的线程仅限一个。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"GIL 并不是 Python 的特性，是在实现 Python 解析器（CPython）时所引入的一个概念。Python 代码被编译后的字节码会在解释器中执行，在执行过程中，存在于 CPython 解释器中的 GIL 会致使在同一时刻只有一个线程可以执行字节码。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"例如 C++ 是一套语言标准，可以用不同的编译器来编译成可执行代码，例如 GCC、INTEL C++、Visual C++ 等。同一套 Python 代码可以用 CPython、PyPy、Psyco 等不同的执行环境来执行。而 JPython 就没有 GIL，只不过 CPython 是大部分环境下默认的执行环境。因此，Python 是可以不受到 GIL 的限制的。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"Python 的多线程是伪多线程，无法利用多核资源，同一个时刻只有一个线程在真正的运行。对于 GIL 有不同的方法：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"在 IO 密集型任务下，我们可以使用多线程或者协程来完成；\n可以选择更换 JPython 等没有 GIL 的解释器，但并不推荐更换解释器，因为会错过众多 C 语言模块中的有用特性；\nCPU 密集可以使用多进程 + 进程池；\n将计算密集型任务转移到 Python 的 C/C++ 扩展模块中完成；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：有了 GIL 还要关注线程安全吗？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"GIL 保证的是每一条字节码在执行过程中的独占性，即每条字节码的执行都是原子性的。GIL 具有释放机制，所以 GIL 并不会保证字节码在执行过程中线程不会进行切换，即在多个字节码之间，线程具有切换的可能性。一个操作如果是一个字节码指令可以完成就是原子的，非原子操作不是线程安全的，原子操作才可以保证线程安全。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"GIL 和线程互斥锁的粒度是不同的，GIL 是 Python 解释器级别的互斥，保证的是解释器级别共享资源的一致性，而线程互斥锁则是代码级（或用户级）的互斥，保证的是 Python 程序级别共享数据的一致性，所以我们仍需要线程互斥锁及其他线程同步方式来保证数据一致。","category":"page"},{"location":"lang/Python/#迭代器","page":"Python","title":"迭代器","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"推荐阅读：Python: Built-in Types – Iterator Types;\nPython：可迭代对象、迭代器、生成器函数、生成器的解析举例代码说明；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"迭代是 Python 范围集合元素的一种方法。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"可迭代对象（Iterable）：Python 中某对象实现 __iter__() 方法或者 __getitem__() 方法，且其参数从 0 开始索引，那么该对象就是可迭代对象。可以用 for 循环的对象，或者说序列（Sequence）都是可迭代对象，比如列表（list）、字典（dict）、元祖（tuple）、集合（set)、字符串（string）这些序列都是可迭代对象。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"使用 iter() 方法可以将可迭代对象变成迭代器，如果可迭代对象实现了 __iter__() 方法，那么调用该方法会返回一个迭代器对象。调用迭代器的 __next__() 方法返回每一次迭代的内容，直到迭代完成后抛出 StopIteration 异常。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"当使用 for 循环的时候，解释器会检查对象是否有 __iter__() 方法，有的话就调用它来获取一个迭代器；\n如果没有 __iter__() 方法但是实现了 __getitem__()，解释器会创建一个迭代器，尝试从 0 开始按顺序遍历元素；\n如果尝试失败，就会抛出一个 TypeError；\n字符串、列表、元祖、字典、集合等均不是迭代器，但是他们是可迭代对象，在迭代中本质上就是对调用 __iter__() 后得到的迭代器通过不断使用 next() 函数来实现的；\n使用  isinstance() 函数可以判断某个对象是否为某一类型，因此可以使用 isinstance(nums, Iterable) 来判断对象 nums 是否为可迭代对象；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"迭代器（Iterator）：可以记住遍历对象的位置，其内部有一个状态用于记录迭代所在的位置，以便下次迭代时能够取出正确的元素。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"迭代器有两个基本方法 iter() 和 next()，前者可以将可迭代对象变成迭代器，后者可以返回下一个值；\n要定义一个迭代器必须实现 __iter__()  和 __next__() 方法。在 Python 2 中则要求类内包含有 next() 方法；\n迭代器只能往前不能后退，从集合的第一个元素开始访问，直到所有的元素被访问完之后结束；\n迭代器一定是可迭代对象，但是可迭代对象不一定是迭代器，例如字符串、字典、元祖、集合等；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":">>> nums = [1, 2, 3]   # 创建一个列表\n>>> nums_iterator = iter(nums)  # 得到一个迭代器\n>>> print(nums_iterator)\n<list_iterator object at 0x7fe1a014e250>\n>>> print(next(nums_iterator))\n1\n>>> print(next(nums_iterator))\n2\n>>> print(next(nums_iterator))\n3\n# next() 方法调用到末尾时会跳出 StopIteration\n>>> print(next(nums_iterator))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"创建一个迭代器的具体方式如下所示，该代码实现的迭代器功能为迭代从 0 每次递增 1 到 9 的所有数字：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"class my_inter:\n    def __iter__(self):\n        self.length = 10 \n        self.index = 0\n        return self\n\n\n    def __next__(self):\n        if self.index < self.length:\n            x = self.index\n            self.index += 1\n            return x\n        else:\n            raise StopIteration\n\n\nnums = my_inter()  # 实例化对象\nprint(nums)\n# 对实例化对象使用 iter() 返回迭代器\nnums_iter = iter(nums)\n\nfor x in nums_iter:  # 对迭代器进行迭代\n    print(x, end=\" \")\n\n>>> 0 1 2 3 4 5 6 7 8 9 ","category":"page"},{"location":"lang/Python/#生成器","page":"Python","title":"生成器","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"在 Python 中使用了 yield 的函数称为生成器函数（Generator Function）。调用一个生成器函数，返回的是一个实例化迭代器对象。生成器函数返回一个只能用于迭代操作的生成器（Generator），生成器是一种特殊的迭代器，自动实现了「迭代器协议」，即实现 __iter__() 和 __next__() 两个方法，无需再手动实现。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"生成器因为有 send() 方法，因此在迭代的过程中可以改变当前迭代值，而这在普通迭代器上会引发异常。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 语句表达式的值，并在下一次执行 next() 或者 send() 方法时从当前位置继续运行。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"注意：在 Python 3 开始，生成器的 next() 方法变成 __next__()","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"使用以下方法判断是否为生成器函数或者是否为生成器：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"from inspect import isgeneratorfunction\nisgeneratorfunction(x)  # 判断 x 是否为生成器函数\n\nimport types\nisinstance(x, types.GeneratorType)  # 判断 x 是否为生成器","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"生成 generator 的两种方式：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"第一种是列表生成式加括号：g = (x for x in range(n))\n另外一种创建生成器函数的具体方式如下所示：","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"def my_list(num):   # 定义生成器\n    now = 0   # 当前迭代值，初始为 0\n    while now < num:\n        val = yield now  # 返回当前迭代值，并接受可能的 send 发送值\n        # val 如果为空，迭代值自增 1；否则重新设定当前迭代值为 val\n        now = now + 1 if val is None else val\n\n\naddOneGenera = my_list(5)  # 得到一个生成器对象\nprint(\"下一个迭代值：{}\".format(addOneGenera.__next__()))\nprint(\"下一个迭代值：{}\".format(addOneGenera.__next__()))\nprint(\"重新设定当前迭代值为 3\")\naddOneGenera.send(3)\nprint(\"下一个迭代值：{}\".format(addOneGenera.__next__()))\n\n>>> 下一个迭代值：0\n>>> 下一个迭代值：1\n>>> 重新设定当前迭代值为 3\n>>> 下一个迭代值：4","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：数据的大小超过内存的大小时如何读取数据？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"例如内存大小是 4G，要如何读取一个 5G 的数据？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"方法一：可以通过生成器，分多次少量的读取相对少的数据进行处理；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"方法二：可以通过 Linux 命令 split 切割成多个小文件，再对数据进行处理。这个方法可以按照行数切割，也可以按照文件大小切割；","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"❓问：输入某年某月某日，如何判断这一天是这一年的第几天？","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"可以使用 Python 的标准库 datetime","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"import datetime\n\ndef dayOfYear(year, month, day):\n    date1 = datetime.date(year = year, month = month, day = day)\n    date2 = datetime.date(year = year, month = 1, day = 1)\n    return (date1 - date2 + 1).days","category":"page"},{"location":"lang/Python/#虚拟环境-virtualenv","page":"Python","title":"虚拟环境 virtualenv","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"pip, virtualenv, fabric 统称为 Python 的三大神器。其中 virtualenv 的作用是建立一个虚拟的 Python 环境。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"通过 pip 安装 virtualenv：pip install virtualenv，如果输入 virtualenv --version 能够输出版本号就代表安装成功了。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"为项目搭建新的虚拟环境：virtualenv nine-py，执行完之后会在当前的目录中创建一个相对应名字的文件夹，是独立的 Python 运行环境，包含了 Python 可执行文件，以及 pip 库的一份拷贝，在这个环境中安装的库都是独立的，不会影响到其他的环境。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"如果想要指定 Python 解释器：virtualenv -p /usr/bin/python2.7 nine-py","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"激活虚拟环境：source nine-py/bin/activate","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"停用虚拟环境：deactivate（停用之后会回到系统默认的 Python 解释器）","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"查看当前安装版本：pip freeze","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"将当前环境输出为文件：pip freeze > requirements.txt，会创建一个 requirements.txt 文件，其中包含当前环境所有包以及对应版本的简单列表。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"安装环境文件：pip install -r requirements.txt","category":"page"},{"location":"lang/Python/#文件操作","page":"Python","title":"文件操作","text":"","category":"section"},{"location":"lang/Python/#读取文件","page":"Python","title":"读取文件","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"# 读取文件的不同方法\nread(size)  # 从文件当前位置起读取 size 个字节，若不给定参数则读取至文件末尾\nreadline()  # 每次读出一行内容，占用内存小，适合读取大文件\nreadlines()  # 读取文件所有行，保存在一个 list 中","category":"page"},{"location":"lang/Python/#Socket-操作","page":"Python","title":"Socket 操作","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"sk.recv(bufsize[,flag])：接受套接字的数据。数据以字符串形式返回，bufsize 指定最多可以接收的数量。flag 提供有关消息的其他信息，通常可以忽略。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"sk.recvfrom(bufsize[.flag])：与 recv() 类似，但返回值是 (data, address)。其中 data 是包含接收数据的字符串，address 是发送数据的套接字地址。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"sk.getsockname()：返回套接字自己的地址。通常是一个元组 (ipaddr, port)。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"sk.connect(address)：连接到 address 处的套接字。一般，address 的格式为元组 (hostname, port)，如果连接出错，返回 socket.error 错误。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"sk.listen(backlog)：开始监听传入连接。backlog 指定在拒绝连接之前，可以挂起的最大连接数量。","category":"page"},{"location":"lang/Python/#Python-PEP-8-编码风格","page":"Python","title":"Python PEP 8 编码风格","text":"","category":"section"},{"location":"lang/Python/","page":"Python","title":"Python","text":"PEP 8 编码规范详细地给出了 Python 编码的指导，具体的格式可以看一下官方文档。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"官方提供了命令行工具来检查 Python 代码是否违反了 PEP 8 规范，可以通过 pip install pycodestyle 来安装，用法是 pycodestyle --show-source --show-pep8 main.py，通过 --show-source 显示不符合规范的源码，以便修改。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"还有一个自动将 Python 代码格式化为 PEP 8 风格的工具是 autopep8，用 pip install autopep8 来安装，用法是 autopep8 --in-place main.py，如果不带参数 –-in-place，会将格式化之后的代码直接输出到控制台，带上这个参数会直接将结果保存到原文件中。","category":"page"},{"location":"lang/Python/","page":"Python","title":"Python","text":"函数的注释：","category":"page"},{"location":"books/#人工智能","page":"推荐书籍大全","title":"人工智能","text":"","category":"section"},{"location":"books/","page":"推荐书籍大全","title":"推荐书籍大全","text":"[ ] 王贺、刘鹏、钱乾《机器学习算法竞赛实战》\n[ ] 天池平台《阿里云天池大赛赛题解析 - 机器学习篇》\n[ ] 邱锡鹏《神经网络与深度学习》\n[ ] 《深度学习与目标检测：工具、原理与算法》  涂铭、金志勇\n[x] 《机器学习》  周志华\n[ ] 《深度学习推荐系统》  王喆\n[ ] 《机器学习》  汤姆 • 米切尔\n[x] 《百面机器学习》  诸葛越、葫芦娃\n[x] 《深度学习》  伊恩 • 古德费洛等\n[ ] 《图神经网络导论》  刘知远、周界\n[ ] 《深入浅出图神经网络：GNN 原理解析》  刘忠雨、李彦霖、周洋\n[ ] 《图神经网络基础与前沿》  马腾飞\n[x] 《Python Data Science Handbook: Essential Tools for Working with Data》  Jake VanderPlas\n[ ] 《PyTorch Computer Vision Cookbook》  Michael Avendi\n[ ] 《The Kaggle Book》  Konrad Banachewicz, Luca Massaron","category":"page"},{"location":"books/#编程语言","page":"推荐书籍大全","title":"编程语言","text":"","category":"section"},{"location":"books/","page":"推荐书籍大全","title":"推荐书籍大全","text":"[ ] 《与孩子一起学编程 Warren Sande, Carter Sande｜零基础入门级别，Python 语言\n[ ] 《Python 编程快速上手》  Al Sweigart\n[ ] 《Python 编程：从入门到实践》  Eric Matthes\n[ ] 《设计模式：可复用面向对象软件的基础》Erich Gamma 等｜有史以来最伟大的软件开发书之一\n[ ] 《C 语言程序设计现代方法》K. N. King｜经典 C 语言的书\n[ ] 《C 陷阱与缺陷：C 语言调试指南》Andrew Koenig｜C 语言在泛型编程上的各种问题\n[ ] 《C++ Primer 中文版》Stanley B. Lippman｜学习 C++ 必看\n[ ] 《深度探索 C++ 对象模型》Stanley B. Lippman\n[ ] 《Effective C++：改善程序与设计的 55 个具体做法》Scott Meyers\n[ ] 《More Effective C++：35 个改善程序与设计的有效方法》Scott Meyers","category":"page"},{"location":"books/#操作系统","page":"推荐书籍大全","title":"操作系统","text":"","category":"section"},{"location":"books/","page":"推荐书籍大全","title":"推荐书籍大全","text":"[ ] 《编码：隐匿在计算机软硬件背后的语言》Charles Petzold｜深度理解计算机工作原理\n[ ] 《鸟哥的 Linux 私房菜：基础学习篇》  鸟哥  有关于计算机和操作系统、Linux 系统\n[ ] 《Linux C 编程一站式学习》宋劲杉\n[ ] 《Linux/UNIX 系统编程手册》Michael Kerrisk\n[ ] 《Linux 系统编程》Robert Love\n[ ] 《Unix 编程艺术》Eric S. Raymond\n[ ] 《MySQL 必知必会》  Ben Forta\n[ ] 《数据库系统概念》Abraham Silberschatz｜斯坦福大学、耶鲁大学教科书\n[ ] 《现代操作系统》Andrew S• Tanenbaum｜进程、线程、存储管理、死锁\n[ ] 《计算机网络：自顶向下方法》James F. Kurose, Keith W. Ross｜\n[ ] 《计算机网络》Andrew S. Tanenbaum\n[ ] 《计算机程序的构造和解释》Harold Abelson｜MIT 计科教材，经典中的经典\n[ ] 《编译原理：原理、技术与工具》Alfred V. Aho｜又称「龙书」\n[ ] 《深入理解计算机系统》Randal E. Bryant, David O’ Hallaron｜最伟大的计算机教材之一\n[ ] 《Unix 环境高级编程》W. Richard Stevens, Stephen A. Rago\n[ ] 《UNIX 网络编程 卷 1：套接口 API》W. Richard Stevens 等\n[ ] 《UNIX 网络变成 卷 2：进程间通信》W. Richard Stevens\n[ ] 《TCP/IP 详解 卷 1：协议》W. Richard Stevens\n[ ] 《TCP/IP 网络编程》尹圣雨\n[ ] 《图解 TCP/IP》竹下隆史\n[ ] 《领域驱动设计：软件核心复杂性应对之道》Eric Evans\n[ ] 《架构整洁之道》Robert C. Martin\n[ ] 《操作系统导论》｜王海鹏版本的翻译不太好，可以简单过一遍","category":"page"},{"location":"books/#代码理论","page":"推荐书籍大全","title":"代码理论","text":"","category":"section"},{"location":"books/","page":"推荐书籍大全","title":"推荐书籍大全","text":"[ ] 《编程珠玑》乔恩 • 宾利\n[ ] 《代码大全（第 2 版）》Steve McConnell｜旧书、厚、不太容易看\n[ ] 《算法》Robert Sedgewick, Kevin Wayne｜每个软件工程师应该会的 50 个算法\n[ ] 《算法图解》Aditya Bhargava\n[ ] 《算法导论》Thomas H. Cormen｜计算机专业的教材\n[ ] 《数据结构与算法分析》Mark Allen Weiss\n[ ] 《计算机程序设计艺术》系列 Donald E. Knuth｜包含一切基础算法的宝典\n[ ] 《剑指 Offer：名企面试官精讲典型编程题》何海涛","category":"page"},{"location":"books/#程序员的自我修养","page":"推荐书籍大全","title":"程序员的自我修养","text":"","category":"section"},{"location":"books/","page":"推荐书籍大全","title":"推荐书籍大全","text":"[ ] Michael C. Feathers《修改代码的艺术》\n[ ] Robert C. Martin《代码整洁之道》代码质量与其整洁度成正比\n[ ] Robert C. Martin《代码整洁之道：程序员的职业素养》\n[ ] 《程序员修炼之道：通向务实的最高境界》  Andrew Hunt, David Thomas  如何成为高级软件工程师\n[ ] 《高效能程序员的修炼》Jeff Atwood｜博文选集\n[ ] 《重构：改善既有代码的设计》  Martin Fowler  教你如何构建优秀的代码\n[ ] 《人月神话》Frederick P. Brooks. Jr.｜如何管理复杂项目、过时但经典\n[ ] 《黑客与画家》Paul Graham｜「黑客」的爱好、动机、工作方法\n[ ] 《完美软件：对软件测试的各种幻想》Gerald M. Weinberg｜软件测试的心理问题\n[ ] 《Google 软件测试之道》James A. Whittaker","category":"page"},{"location":"network/#计算机网络","page":"-","title":"计算机网络","text":"","category":"section"},{"location":"network/","page":"-","title":"-","text":"资料：湖科大，小林 coding","category":"page"},{"location":"network/","page":"-","title":"-","text":"URI（Uniform Resource Identifier，统一资源标识符）：一个存放网页数据的文件名或者是一个 CGI 程序的文件名。","category":"page"},{"location":"network/","page":"-","title":"-","text":"CGI 程序：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI，而按照 CGI 规范来工作的程序就称为 CGI 程序。","category":"page"},{"location":"network/","page":"-","title":"-","text":"TCP 的三次握手和四次挥手：","category":"page"},{"location":"network/","page":"-","title":"-","text":"❓http 与 https 在哪一层？https 如何保证安全？","category":"page"},{"location":"network/","page":"-","title":"-","text":"加密、身份认证、校验；","category":"page"},{"location":"network/","page":"-","title":"-","text":"❓加密算法有哪些了解？","category":"page"},{"location":"network/","page":"-","title":"-","text":"RSA 与 ECDHE","category":"page"},{"location":"network/","page":"-","title":"-","text":"❓TCP、UDP 的区别，它们分别适合什么场景？","category":"page"},{"location":"network/","page":"-","title":"-","text":"（为什么是三次握手和四次挥手）","category":"page"},{"location":"network/","page":"-","title":"-","text":"❓TCP 拥塞控制","category":"page"},{"location":"network/","page":"-","title":"-","text":"❓TCP/IP 五层架构对应什么协议","category":"page"},{"location":"network/","page":"-","title":"-","text":"","category":"page"},{"location":"network/","page":"-","title":"-","text":"[1] 小林 coding","category":"page"},{"location":"爬虫/","page":"-","title":"-","text":"爬虫三步：","category":"page"},{"location":"爬虫/","page":"-","title":"-","text":"拿到页面源代码 requests；\n通过 xpath 提取有效的信息 lxml；\n保存数据；","category":"page"},{"location":"爬虫/","page":"-","title":"-","text":"拿到页面源代码需要先有 url，header 是模拟浏览器的。","category":"page"},{"location":"爬虫/","page":"-","title":"-","text":"header 的获取，可以在登录 url 的时候，F12 切换到 Network 的界面，随便找到一个请求，然后在 Headers 上找到 User-Agent 直接复制使用：","category":"page"},{"location":"爬虫/","page":"-","title":"-","text":"headers = {\n    \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36\"\n}\n\n","category":"page"},{"location":"AI/FE/#组合特征","page":"特征工程","title":"组合特征","text":"","category":"section"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。在实际问题中，需要面对多种高维特征，简单地两两组合，依然容易存在参数过多、过拟合等问题。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"怎样有效地找到组合特征？ 可以利用决策树来寻找特征组合方式。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"例如，影视推荐问题有两个低阶特征「语言」和「类型」，其中有语言分为中文和英文，类型分为电影和电视剧，那么这两个特征的高阶组合特征有（中文，电影）、（英文，电视剧）、（英文，电影）、（中文，电视剧）四种。下表的数据，就可以变为新的数据：","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"是否点击 语言 类型\n0 中文 电影\n1 英文 电影\n1 中文 电视剧\n0 英文 电视剧","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"是否点击 语言 = 中文，类型 = 电影 语言 = 英文，类型 = 电影 语言 = 中文，类型 = 电视剧 语言 = 英文，类型 = 电视剧\n0 1 0 0 0\n1 0 1 0 0\n1 0 0 0 1\n0 0 0 0 1","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"以逻辑回归为例，假设数据的特征向量为 X=(x_1x_2dotsx_k)，则有：","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"Y=textsigmoid(sum_isum_jw_ijlangle x_ix_jrangle)","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"其中 langle x_ix_jrangle 表示 x_i 和 x_j 的组合特征，w_ij 的维度等于第 i 和第 j 个特征不同取值的个数。在上例中，「语言」这个特征有中文和英文两个选择，「类型」这个特征有电影和电视剧两个选择，那么 w_ij 的维度就为 2times 2=4. 当组合之前的两个特征不同取值的个数都不大时，用这种方式不会有太大的问题。但是对于某些问题，有用户 ID 和物品 ID，而用户和物品的数量动辄几千万，几千万乘几千万 mtimes n，这么大的参数量，无法进行学习。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"对于这种「高维组合特征」要如何处理？假设用户和物品的数量分别为 m 和 n，一种行之有效的方法是将两个特征分别用 k 维的低维向量表示（kll mkll n），这样原本 mtimes n 的学习参数就降低为 mtimes k + ntimes k，这其实等价于推荐算法中的矩阵分解。","category":"page"},{"location":"AI/FE/#文本表示模型","page":"特征工程","title":"文本表示模型","text":"","category":"section"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"最基础的文本表示模型是词袋模型，就是将每篇文章看成一袋子词，并忽略每个词出现的顺序。每篇文章可以表示成一个长向量，向量中的每一维度代表一个单词，而该维对应的权重则反映了这个词在原文章中的重要程度。常用 TF-IDF（Term Frequency-Inverse Document Frequency）来计算权重：","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"textTF-IDF(td)=textTF(td)times textIDF(t)","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"其中 textTF(td) 为单词 t 在文档 d 中出现的频率，textIDF(t) 是逆文档频率，用来衡量单词 t 对表达语义所起的重要性，表示为：","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"textIDF(t) = logfractextNum of articlestextNum of articles containing word t+1","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"直观解释为，如果一个单词在非常多的文章里面都出现，那么它可能是一个比较通用的词汇，对于区分谋篇文章特殊语义的贡献比较小，因此对权重做一定惩罚。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"有的时候，多个不同的单词组合起来会有特殊的含义，比如 natural language processing 组合起来就有「自然语言处理」的意思，但是把这三个单词拆开，就没有组合起来的特别。将类似这样的连续出现的 n 个词（nle N）组成的词组（N-gram）也作为一个单独的特征放到向量表示中去，构成 N-gram 模型。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"词干抽取（Word Stemming），同一个词可能有多种词性变化，却有相似的含义。在实际应用中，一般会对单词进行词干抽取，即将不同词性的单词统一成为同一词干的形式。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"主题模型用于从文本库中发现有代表性的主题（得到每个主题上面词的分布特性）。","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"词嵌入是一类将词向量化的模型的统称，将每个词都映射成低维空间上的一个稠密向量（Dense Vector），通常维度 K=50sim 300。词嵌入将每个词映射成一个 K 维向量，如果一篇文章有 N 个词，就可以用一个 Ntimes K 的矩阵来表示这篇文章。但是这样的表示仅仅只是底层的表示，在实际应用中，如果仅仅把这个矩阵作为原文本的表示特征输入到机器学习模型当中，很难得到令人满意的结果。","category":"page"},{"location":"AI/FE/#Word2Vec","page":"特征工程","title":"Word2Vec","text":"","category":"section"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"❓cbow 的原理是什么？","category":"page"},{"location":"AI/FE/","page":"特征工程","title":"特征工程","text":"❓cbow 和 skip-gram 的区别是什么？","category":"page"},{"location":"company_info/#旷视科技（MEGVII）","page":"-","title":"旷视科技（MEGVII）","text":"","category":"section"},{"location":"company_info/","page":"-","title":"-","text":"移动端高效卷积神经网络 ShuffleNet","category":"page"},{"location":"company_info/","page":"-","title":"-","text":"AI 生产力平台 Brain++：包括开源深度学习框架天元 MegEngine、深度学习云计算平台 MegCompute、数据管理平台 MegData","category":"page"},{"location":"company_info/","page":"-","title":"-","text":"旷视人才：孙剑，著有论文 Residual Network、Fast R-CNN、Faster R-CNN 等","category":"page"},{"location":"git/#第一章-Git-基础","page":"Git 使用","title":"第一章 Git 基础","text":"","category":"section"},{"location":"git/#.-常用命令","page":"Git 使用","title":"1. 常用命令","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.1. 配置 user 信息","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"配置自己的用户名为 strongnine，邮箱为 strongnine@163.com，实际用的时候请将此换成自己的用户名和邮箱。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"$ git config --global user.name 'strongnine'\n$ git config --global user.email 'strongnine@163.com'","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.2. config 的三个作用域","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"$ git config --global\n$ git config --local","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"可以显示自己目前的局部（local）或者全局（global）的配置。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 显示 config 设置\n$ git config --list --local\n$ git config --list --global","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.3. git 命令","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"创建仓库可以在 GitHub 上创建仓库，然后再通过 git clone 克隆到自己的本地，也可以现在本地新建的文件夹里用 git init 初始化创建仓库。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# git 仓库的初始化\n$ git init","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"查看当前仓库状态：git status 可以查看当前仓库的状态。能够看到文件的修改、删除、添加、以及重命名（重命名的逻辑就是删除一个文件并且添加一个文件），并且还能够看到当前存在的冲突啥的。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"添加文件：git add 可以将某个文件的更新添加到暂存区区里；","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git add -u：将文件的修改、文件的删除，添加到暂存区。git add .：将文件的修改，文件的新建，添加到暂存区。git add -A：将文件的修改，文件的删除，文件的新建，添加到暂存区。git add -A 相对于 git add -u 命令的优点 ： git add -A 可以提交所有被删除、被替换、被修改和新增的文件到数据暂存区，而 git add -u 只能操作跟踪过的文件。git add -A 等同于 git add -all. ","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"撤销添加（版本回退）：有的时候我们 add 了一个文件，想要撤销，可以用 git reset","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"撤销添加：git reset HEAD 将绿字变成红字；","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"提交修改：git commit 将当前暂存区里的更新提交，会用默认编辑器跳出信息，可以在第一行添加提交的备注信息，例如 \"add README.md\". ","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git commit -m\"add README.md\" 可以直接将备注信息一起提交。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"删除文件：git mv <文件名> 是正确删除文件的方法。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"重命名的文件：git mv oldname newname","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"当你重命名了一个文件之后，用 git status 会提示有一个文件被删除，有一个文件是新的 Untracked 文件。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"重置文件：git reset --hard 用来对暂存区的文件进行重置。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"warning: Warning\n注意：git reset 是一条相对危险的命令。","category":"page"},{"location":"git/#.-版本管理","page":"Git 使用","title":"2. 版本管理","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.1. 分支管理","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"查看历史：git log 可以查看当前分支的提交历史记录日志，命令 gitk 可以调出图形界面查看历史版本。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git log --graph 可以有比较图形化的界面；git log --oneline 只显示每次提交的备至；git log -n4 --online 指定查看最近 4 个 commit；git log --all 查看全部分支的日志；git log --all --graph 用图形化的方式显示所有分支的日志；","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"查看分支：git branch -v 可以查看本地有多少分支。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git branch -av：查看所有分支；git branch -d 分支名：删除分支；git branch -D 分支名：强制删除分支；","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"warning: Warning\n如果分支还未被 merged 的时候要用强制删除，请确保该分支无用。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"创建分支：git checkout ","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git checkout -b 可以创建新分支并且切换到该新的分支；","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"有的时候需要加上 --decorate 参数才可以显示（master）（temp）等分支信息。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.2. .git 目录的内容","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"cat 命令主要用来查看文件内容，创建文件，文件合并，追加文件内容等功能。 cat HEAD 查看 HEAD 文件的内容 git cat-file 命令 显示版本库对象的内容、类型及大小信息。 git cat-file -t b44dd71d62a5a8ed3 显示版本库对象的类型 git cat-file -s b44dd71d62a5a8ed3 显示版本库对象的大小 git cat-file -p b44dd71d62a5a8ed3 显示版本库对象的内容","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"HEAD：指向当前的工作路径 config：存放本地仓库（local）相关的配置信息。 refs/heads：存放分支 refs/tags：存放tag，又叫里程牌 （当这次 commit 是具有里程碑意义的，比如项目 1.0 的时候 就可以打 tag） objects：存放对象 .git/objects/ 文件夹中的子文件夹都是以哈希值的前两位字符命名 每个 object 由 40 位字符组成，前两位字符用来当文件夹，后 38 位做文件。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"commit、tree、blob 的关系","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"(Image: relations)","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"一个 commit 对应一颗 tree，tree 相当于文件夹，blob 相当于具体的文件（数据）。git 里面，文件内容相同， 就是视为同一个文件。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"当创建了新的空文件夹时，使用 status 不会检测到这个空的文件夹。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.3. 分离头指针","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"变更没有基于某个 branch，在分离头指针进行的 commit，如果没有及时合并到某个 branch，可能会被 git 当作垃圾清掉。如果这种变更是重要的，就要将其与某个 branch 绑在一起。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git checkout -b 可以创建新分支并且切换到该新的分支。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"HEAD 指针可以指向某个分支的最后一次提交，也可以不和某个分支挂钩，当处于分离头指针时，可以直接指向某个 commit。它只能够定位到某个 commit。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"对比提交之间的差异：git diff [commit1] [commit2] 可以比较两个具体的 commit 的差异。git diff HEAD HEAD^1 将当前结点与其父亲结点进行对比。HEAD^1, HEAD~1, HEAD~, HEAD^ 都一样。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"一个节点，可以包含多个子节点（checkout 出多个分支）\n一个节点可以有多个父节点（多个分支合并）\n^ 和 ~ 都是父节点，区别是跟随数字时候，^2 是第二个父节点，而 ~2 是父节点的父节点\n^ 和 ~ 可以组合使用,例如 HEAD~2^2","category":"page"},{"location":"git/#第二章-独自使用-Git","page":"Git 使用","title":"第二章 独自使用 Git","text":"","category":"section"},{"location":"git/#.-commit-的操作","page":"Git 使用","title":"1. commit 的操作","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.1. 修改 commit 的 message","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 修改最新 commit 的信息\n$ git commit --amend\n# 想要修改旧 commit 的信息，需要先选择其父节点\n# 运行后会弹出一个交互界面，在里面修改、保存之后\n# 还会继续弹出一个交互界面，提示要把 message 如何修改\n$ git rebase -i 父节点","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"warning: Warning\n这种操作只适用于还未合并到「主线」 的分支上，否则会影响到合作者的工作。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.2. 整理多个 commit ","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 和上一个操作相似\n# 在弹出的交互界面进行不同的修改就行（会有提示）\n$ git rebase -i 父节点\n\n# 上面的是把「连续的」commit 合并，还有一种是把「间隔的」合并\n$ git rebase -i 父节点","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.3. 对比差异","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 对比暂存区和 HEAD 里面内容的差异（看看做了哪些改动）\n$ git diff --cached\n\n# 对比工作区和暂存区的不同\n$ git diff\n\n# 只比较某个文件\n$ git diff -- <文件名>\n\n# 查看不同提交的指定文件的差异\n$ git diff <指针 1> <指针 2> -- <文件名>","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.4. 恢复变更","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 把暂存区里面的文件全部恢复成和 HEAD 一样的\n$ git reset HEAD\n\n# 让工作区的文件恢复为暂存区一样（变更工作区）\n$ git checkout -- index.html\n\n# 取消暂存区部分文件的更改\n$ git reset HEAD -- <文件名>...","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.5. 消除最近几次提交","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 将头指针指向特定的某次提交，并且删除这之前的提交\n# <危险指令> 慎用！！！\n$ git reset --hard <指针>","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.6. 删除文件","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 正确删除文件的方法\n$ git rm <文件名>","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.7. 临时加塞的紧急任务 —— stash 的使用","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 把当前状态存放\n$ git stash\n# 列出状态区\n$ git stash list\n# 恢复暂存区（弹出之前放进 stash 顶的），但是 stash 堆栈里的信息还会在\n$ git stash apply\n# 恢复的基础上还会丢掉 stash 里面的信息\n$ git stash pop","category":"page"},{"location":"git/#.-Git-管理","page":"Git 使用","title":"2. Git 管理","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.1. 指定不需要 Git 管理的文件","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":".gitignore 文件上的内容就是表示指定类型的文件不给 Git 进行管理。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.2. Git 的备份","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"(Image: git_learning_fig2)","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"哑协议传输进度不可看见，智能协议可见。智能协议比哑协议快。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# --bare 代表不带工作区的裸仓库\n# 哑协议\n$ git clone --bare /path/to/repo.git <拷贝路径.git>\n# 智能协议\n$ git clone --bare / file:///path/to/repo.git <拷贝路径.git>\n\n# 把本地的变更同步到远端\n$ git remote -v\n$ git remote add <名称> <协议地址>\n# 查看分支\n$ git branch -av\n$ git push <名称>\n$ git push --set-upstream <  > <  >","category":"page"},{"location":"git/#第三章-Github-同步","page":"Git 使用","title":"第三章 Github 同步","text":"","category":"section"},{"location":"git/#配置公私钥","page":"Git 使用","title":"配置公私钥","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"在 Github 首页上，寻找 help，在上面有关于如何 connecting to github with SSH 的做法。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 打开 git bash 在里面输入下面命令\n# 若干存在 id_rsa 和 id_rsa.pub 文件则代表已经有公私钥\n# 否则应该要根据 Help 上的提示进行生成\n$ ls - al ~/.ssh\n# 查看 id_rsa.pub 的内容\n$ cd ~/.ssh\n$ cat id_rsa.pub\n# 复制里面的内容，前往 github 账户设置里面添加 SSH keys","category":"page"},{"location":"git/#**把本地仓库同步到-Github**","page":"Git 使用","title":"把本地仓库同步到 Github","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 添加一个新的 remote\n$ git remote add <名称> <SSH>\n# 查看已有的 remote\n$ git remote -v\n\n# 把所有内容 push\n$ git push <name> --all\n# 如果远端有某些文件是本地未包含的，这个分支会被拒绝 push\n# 需要把远端的先「拉」下来\n$ git fetch <name> master\n# 切换到 master 分支\n$ git checkout master\n# 与远端的 .../master 的分支合并\n$ git merge <远端分支>\n# 但注意如果两个分支都是独立的，没有共同的历史，那么会拒绝合并\n# 查看 merge 帮助\n$ git merge -h\n$ git merge --allow-unrelated-histories <远端分支>\n# 现在进行 push 就不会报错了\n$ git push <name> master","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"注：在之后为了方便学习，将一些命令与视频里面的进行同步，<name> 会用 github 来代替，因为我们把远端的仓库 fetch 下来并且命名为 gitHub 了","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"个人笔记总结git remote -v 查看远程版本库信息\ngit remote add <name> <url>添加 githup 远程版本库\ngit fetch <name> 拉取远程版本库\ngit merge -h 查看合并帮助信息\ngit merge --allow-unrelated-histories githup/master 合并 <name> 上的 master 分支（两分支不是父子关系，所以合并需要添加 –allow-unrelated-histories）\ngit push <name> 推送同步到 <name> 仓库—— by DriveMan_邱佳源","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"fast forward 到底是什么？举个例子，本地分支往远端分支做 push，如果远端分支不是本地分支的祖先，那它俩就不是 fast forward 了。反之，它俩就是 fast forward 的关系。","category":"page"},{"location":"git/#第四章-Git-多人单分支集成协作","page":"Git 使用","title":"第四章 Git 多人单分支集成协作","text":"","category":"section"},{"location":"git/#.-多个人对文件修改","page":"Git 使用","title":"1. 多个人对文件修改","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.1. 不同人修改了不同文件","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# \n# 会出现 Non fast_forwards 的报错，远端仓库会拒绝这个 push\n# 先把远端的 fetch 下来\n$ git fetch <name>(github)\n# 然后查看 branch 会发现有 [ahead 1, behind 1] 这样的信息，\n# 代表远端有的这里没有和这里有的远端没有\n$ git branch -av\nfeature/add_git_commands     07c85df [ahead 1, behind 1] ......\n\n# 有时候会考虑合并\n$ git merge (github/feature/add_git_commands)","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"老师你好，我有个问题哈，clone 命令 git clone git@github.com:git2019/gitlearning.git 既然已经把远程仓库所有内容都克隆到本地了，为什么还需要 git checkout -b feature/addgitcommands origin/feature/addgit_command 命令基于远程分支在本地建立分支，不是从远程clone下来了嘛，为什么还要新建，难道 clone 命令不能克隆分支吗？作者回复：我们在本地无法直接在 clone 下来的远程分支上做变更的，只能基于远程分支建本地分支后，才能创建 commit。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.2. 不同人修改同一文件的不同区域","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# pull 会把远端的内容拉下来，并且本地的也会进行更新\n# 简介的方法就是直接 pull，还有一种是 fetch + merge\n# 多查看 branch ，看看 ahead 和 behind 的数目\n$ git branch -av\n\n# 当只有 ahead 没有 behind 的时候，肯定是 fast-forward 可以提交","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"fast-forword 看了英语翻译为快进，结合 git branch -av 中的 ahead 和 behind，ahead 是本地仓库比远端仓库多 commit，behind 是本地仓库比远端仓库少 commit。对正常的备份系统来说，我本地只能比备份多，备份不可能比我本地多才是。然而，git 由于多用户提交原因出现备份比本地多了，本地滞后了，所以需要 pull 一下，让本地比备份相等或多，这种情况就是 fast forward ，也就是我本地要比备份快进。不知理解对否？作者回复：其实就是两个分支的关系为 0|n 或者 n|0 ，如果两个分支直接为 n|m 的关系就不是 fast forward 。A 分支比 B 分支多 5 个 commit，B 比 A 分支多 3 个 commit。A 和 B 就不是 fast forward。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"1.3. 不同人修改同一文件的同一区域","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 如果 push 不上去，使用 merge 又提示已经更新到最新了\n# 就说明远端变了，要及时更新\n$ git pull\nAuto-merging (index.html)\nCONFLICT(content): Merge conflict in (index.html)\n# 提示 CONFLICT(content) 说明文件有冲突，不能自动合并 index.html\n# 打开这个文件，会提示哪里出现冲突\n$ vi index.html\n# 编辑完成后查看状态\n$ git status\n\n# 如果这个分支有问题了，可以用 --abort 退出合并\n$ git merge --abort\n$ git commit -am'(commit text)'","category":"page"},{"location":"git/#.-更改了文件名","page":"Git 使用","title":"2. 更改了文件名","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.1. 同时变更了文件名和内容","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 其中有一个人变更了文件名\n# 另一个人只变更了文件内容\n# pull 的话会智能识别问题\n$ git pull","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"2.2. 同一文件改成不同的文件名","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 依旧是报冲突\n$ git pull\n# 查看工作目录，会出现未命名的文件，和两个重命名的文件\n# 如果使用 diff 查看两个文件的差异，不会显示差异\n$ diff <file-1> <file-2>\n# 使用 status，会提示：\nboth deleted:  <oldfilename>\nadded by us:   <filename-1>\nadded by them: <filename-2>\n# 可以先移除不要的文件，再加上想要保存的文件名\n$ git rm <filename-2>\n$ git add <filename-1>\n$ git commit -am'(commit text)'","category":"page"},{"location":"git/#第五章-集成使用禁忌","page":"Git 使用","title":"第五章 集成使用禁忌","text":"","category":"section"},{"location":"git/#.-禁止向集成分支执行-push-f","page":"Git 使用","title":"1. 禁止向集成分支执行 push -f","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"-f, --force 是强制更新，即使不是 fast-forward 也可以 push。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"# 把历史 reset 到某个 log\n$ git reset --hard (b3f390c)\n# 强制 push，就会把在 b3f390c 后面做的改变都删除\n$ git push -f (origin) (feature/add_git_commands)","category":"page"},{"location":"git/#.-禁止向集成分支执行变更历史的操作","page":"Git 使用","title":"2. 禁止向集成分支执行变更历史的操作","text":"","category":"section"},{"location":"git/#第六章-GitHub","page":"Git 使用","title":"第六章 GitHub","text":"","category":"section"},{"location":"git/#.-核心功能","page":"Git 使用","title":"1. 核心功能","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"代码预览、项目管理、集成、团队管理、社交编码（开源）、文档、存放代码。","category":"page"},{"location":"git/#.-寻找开源项目","page":"Git 使用","title":"2. 寻找开源项目","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"使用高级搜索：光标放在搜索框里，按回车就会出现 advanced search 了。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"可以在 Help 上查看有哪些高级搜索的语法。  ","category":"page"},{"location":"git/#.-搭建个人博客","page":"Git 使用","title":"3. 搭建个人博客","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"通过高级搜索在搜索框中输入 blog easily start in:readme stars:>5000 找到 jekyll-now 仓库。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"第一步就是 fork 一个到自己的账号里去。fork 完后修改工程名称：<username>.github.io","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"第二步修改 _config.yml。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"在 _posts 里面新增文件格式为：2018-12-24-<title>.md","category":"page"},{"location":"git/#第七章-团队协作","page":"Git 使用","title":"第七章 团队协作","text":"","category":"section"},{"location":"git/#.-创建团队项目","page":"Git 使用","title":"1. 创建团队项目","text":"","category":"section"},{"location":"git/#.-挑选合适的分支集成策略","page":"Git 使用","title":"3. 挑选合适的分支集成策略","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"在仓库的 Insights => Network 里可以看到特性分支演变历史。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"在 Options 的 Merge button 可以设置允许哪种合并。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"merge 把分支最后合并到 master 上去；\nsquash merging 把分支的所有 commits 变成一个，再放到主线上去。（在当前主线后面加上）\nrebase merging 把分支的所有 commits 添加到主线后面去。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"后面两种适合于线性开发的情况。","category":"page"},{"location":"git/#.-issue-跟踪","page":"Git 使用","title":"4. issue 跟踪","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"issue 上有标签管理，对不同的问题进行分类。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"还可以对 issue 进行模型管理，自定义一些问题报告的模板。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"有 Bug report、Feature request 等。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"使用 Projects 的看板来管理 issue","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"点击 Pojects 进行看板（Board）的设置。","category":"page"},{"location":"git/#.-Code-review","page":"Git 使用","title":"5. Code review","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"在 Settings 的 Branches 上可以设置特殊分支的保护规则。比如对于 master 分支进行 push 保护，每次 push 都要有特定人数去检查才能通过。","category":"page"},{"location":"git/#.-多分支的集成","page":"Git 使用","title":"6. 多分支的集成","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"特性分支往主干合，要发 Pull requests。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"git rerere 是一个隐藏功能，允许你让 Git 记住解决一个块冲突的方法，在下一次看到相同冲突时，自动解决。","category":"page"},{"location":"git/#第八章-GitLab","page":"Git 使用","title":"第八章 GitLab","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"这两章先看视频过一遍，等到应用的时候可以复习。目前不知道具体的使用需求，先大概看个印象。","category":"page"},{"location":"git/#其它问题","page":"Git 使用","title":"其它问题","text":"","category":"section"},{"location":"git/#.-在-Windows-上如何支持中文","page":"Git 使用","title":"1. 在 Windows 上如何支持中文","text":"","category":"section"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"参考解决 Git 在 windows 下中文乱码的问题.md。","category":"page"},{"location":"git/","page":"Git 使用","title":"Git 使用","text":"有一个注意的点：目前无法解决输入中文字符会显示乱码的问题解决方案：git commit 时，不用 -m 参数，直接回车让 vim 来处理\n进 vim 后按 i 进入编辑模式，完成后再保存退出","category":"page"},{"location":"lang/EffectivePython/#.-不要用-send-给生成器注入数据","page":"-","title":"34. 不要用 send 给生成器注入数据","text":"","category":"section"}]
}
