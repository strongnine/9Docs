var documenterSearchIndex = {"docs":
[{"location":"machine_learning/GNN/#通用框架","page":"图神经网络","title":"通用框架","text":"","category":"section"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"除了图神经网络的不同变体，人们还提出了一些通用框架，旨在将不同的模型集成到单一的框架中。^1","category":"page"},{"location":"machine_learning/GNN/#消息传递神经网络","page":"图神经网络","title":"消息传递神经网络","text":"","category":"section"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"消息传递神经网络^2（MPNN, Message Passing Neural Network）包含两个阶段：消息传递阶段和读出阶段。\t","category":"page"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"","category":"page"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"参考：","category":"page"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"[1] 刘知远，周界，《图神经网络导论》","category":"page"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"[2]  J. Gilmmer, S. S. Schoenholz, P. F. Riley, et al. Neural message passing for quantum chemistry. In Proc. of ICML, 2018: 1263-1272. ","category":"page"},{"location":"machine_learning/GNN/","page":"图神经网络","title":"图神经网络","text":"[3] 刘忠雨，李彦霖，周洋，《深入浅出图神经网络》","category":"page"},{"location":"leetcode/leetcoding/#做题记录","page":"做题记录","title":"做题记录","text":"","category":"section"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"参考网站：","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"LeetCode 中国：最大最全的题库网站；\nCodeTop 企业题库：能够根据不同的公司选择题库，有专门性地刷；\nlabuladong 的算法小抄\n……","category":"page"},{"location":"leetcode/leetcoding/#心路历程","page":"做题记录","title":"心路历程","text":"","category":"section"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"刷题也好，面试也好，都是有技巧的；\n数据结构是工具，算法是通过合适的工具解决特定问题的方法。—— labuladong；\n做题先做「二叉树」，最容易培养框架思维，大部分算法技巧本质上都是树的遍历问题。—— labuladong；","category":"page"},{"location":"leetcode/leetcoding/#二分查找（Binary-Search）","page":"做题记录","title":"二分查找（Binary Search）","text":"","category":"section"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"二分查找的题目，就看 liweiwei 的题解就行了：写对二分查找不能靠模板，需要理解加练习 （附练习题）","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"一般情况下，边界设置为 left = mid + 1 与 right = mid，这个时候中点是下取整，即偏向于左边取：mid = (right - left) / 2 + left。","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"当看到边界设置行为是 left = mid 与 right = mid - 1 的时候，需要将 mid = (right - left + 1) / 2 + left，即调整为上取整，即偏向于右边取。","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"34. 在排序数组中查找元素的第一个和最后一个位置，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"33. 搜索旋转排序数组，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"81. 搜索旋转排序数组 II，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"153. 寻找旋转排序数组中的最小值，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"154. 寻找旋转排序数组中的最小值 II，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"69. Sqrt(x)，简单题，字节算法，","category":"page"},{"location":"leetcode/leetcoding/#快慢指针","page":"做题记录","title":"快慢指针","text":"","category":"section"},{"location":"leetcode/leetcoding/#左右指针","page":"做题记录","title":"左右指针","text":"","category":"section"},{"location":"leetcode/leetcoding/#滑动窗口","page":"做题记录","title":"滑动窗口","text":"","category":"section"},{"location":"leetcode/leetcoding/#前缀和数组","page":"做题记录","title":"前缀和数组","text":"","category":"section"},{"location":"leetcode/leetcoding/#差分数组","page":"做题记录","title":"差分数组","text":"","category":"section"},{"location":"leetcode/leetcoding/#动态规划（Dynamic-Programming）","page":"做题记录","title":"动态规划（Dynamic Programming）","text":"","category":"section"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"动态规划的 liweiwei 有一个关于买卖股票问题的题解：暴力解法、动态规划（Java），还有股票问题系列通解（转载翻译）。","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"53. 最大子序和，简单题，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"经典股票系列问题","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"121. 买卖股票的最佳时机，简单题，我的题解；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"122. 买卖股票的最佳时机 II，中等题；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"123. 买卖股票的最佳时机 III，困难题；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"188. 买卖股票的最佳时机 IV，困难题；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"309. 最佳买卖股票时机含冷冻期，中等题；","category":"page"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"714. 买卖股票的最佳时机含手续费，中等题；","category":"page"},{"location":"leetcode/leetcoding/#哈希（Hash）","page":"做题记录","title":"哈希（Hash）","text":"","category":"section"},{"location":"leetcode/leetcoding/","page":"做题记录","title":"做题记录","text":"350. 两个数组的交集 II，简单题，我的题解；","category":"page"},{"location":"algorithm/algo/#个人心得","page":"数据结构与算法","title":"个人心得","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"这个笔记是本人在跟着 labuladong 的算法小抄进行学习时候的个人笔记，主要是记录一些重要的点，算法的练习无论如何还是在于自己真正地上手去练习。笔记中的代码，也是根据「算法小抄」中提供的代码框架，改成 Python 的版本，作为一个记录，方便自己在刷题的时候有个地方可以对照着。","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"我想这些框架，就像是上学的时候写数学题的公式，把公式整理到笔记本上， 在做题的时候，就直接代公式。只是重要的是要学习如何代公式，这个部分是自己的思考，逃不开练习。","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"笔记的最后有列出参考资料，一些句子不是自己写的，会用「引用」并且「上标」的方式来注明。","category":"page"},{"location":"algorithm/algo/#数据结构","page":"数据结构与算法","title":"数据结构","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"在最底层中，数据结构的存储方式只有两种方式：数组（顺序存储）和链表（链式存储）。而其他的例如散列表、栈、队列、堆、树、图等等的数据结构，都是在数组和链表上的特殊操作。","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"而对于任何数据结构，基本操作就是「遍历」和「访问」，也就是「增删查改」。线性的形式以 for/while 迭代为代表，非线性的形式以递归为代表。","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"算法的本质就是「穷举」，但穷举有两个关键难点：无遗漏、无冗余。^1","category":"page"},{"location":"algorithm/algo/#二叉树","page":"数据结构与算法","title":"二叉树","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"几乎所有二叉树的题目都是一套这个框架就出来了：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"def traverse(root):\n    # 前序遍历代码位置\n    traverse(root.left)\n    # 中序遍历代码位置\n    traverse(root.right)\n    # 后序遍历代码位置","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"快速排序就是二叉树的前序遍历，归并排序就是二叉树的后序遍历。^1","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"快速排序的代码框架：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"def sort(nums, lo, hi):\n    #===== 前序遍历位置 =====#\n    # 通过交换元素构建分界点 p\n    p = partition(nums, lo, hi)\n    #======================#\n    sort(nums, lo, p-1)\n    sort(nums, p+1, hi)","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"归并排序的代码框架：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"def sort(nums, lo, hi):\n    mid = lo + (hi - lo) / 2\n    sort(nums, lo, mid)    # 排序 nums[lo...mid]\n    sort(nums, mid+1, hi)  # 排序 nums[mid+1...hi]\n    \n    #===== 后序遍历位置 =====#\n    # 合并 nums[lo...mid] 和 nums[mid+1...hi]\n    merge(nums, lo, mid, hi)\n    #======================#","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"层序遍历属于迭代遍历，代码框架：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"from collections import deque\n# 输入一棵二叉树的根节点，层序遍历这棵二叉树\ndef levelTraverse(root):\n    if (root == None): \n        return\n    q = deque()\n    q.append(root)\n    \n    # 从上到下遍历二叉树的每一层\n    while q:\n        sz = len(q)\n        for i in range(sz):\n            cur = q.popleft()\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"笔记^1：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"只要涉及递归的问题，所有回溯、动态规划、分治算法，都是树的问题；\n写树相关的算法，就是先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点；\n二叉树题目的「递归」解法可以分成两类思路：\n第一类：遍历一遍二叉树得出答案，对应的是「回溯算法」；\n第二类：通过分解问题计算出答案，对应的是「动态规划」；\n首先思考是否可以通过遍历一遍二叉树得到答案？不能的话能够定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？\n遇到子树问题，首先想到给函数设置返回值，在后序位置做文章；","category":"page"},{"location":"algorithm/algo/#二叉搜索树（Binary-Search-Tree,-BST）","page":"数据结构与算法","title":"二叉搜索树（Binary Search Tree, BST）","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"BST 代码框架：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"def BST(root, target):\n    if (root.val == target):\n        # 找到目标，增删改\n    if (root.val < target):\n        BST(root.right, target)  # 目标值大于当前节点值，在右边找\n    if (root.val > target):\n        BST(root.left, target)   # 目标值小于当前节点值，在左边找","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"BST 删除节点的代码：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"def delNode(root, key):\n    if (root == None): return None\n    if (root.val == key):\n        # case 1 and 2\n        if (root.left == None): return root.right\n        if (root.right == None): return root.left\n        # case 3\n        minNode = getMin(root.right)\n        # 这一步删除右子树最小结点，只会碰到 case 1：没有子节点\n        root.right = delNode(root.right, minNode.val)\n        minNode.left = root.left\n        minNode.right = root.right\n        return minNode\n    elif (root.val > key):\n        root.left = delNode(root.left, key)\n    elif (root.val < key):\n        root.right = delNode(root.right, key)\n    return root\n\ndef getMin(node):\n    while node.left: node = node.left\n    return node","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"验证 BST 代码：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"def isValidBST(root):\n    return isValid(root, None, None)\n\n# 让 root 的信息能够传给子树节点\ndef isValid(root, minNode, maxNode):\n    if (root == None): return True\n    if (minNode and root.val <= minNode.val): return False\n    if (maxNode and root.val >= maxNode.val): return False\n    # 左子树最大的值不能超过 root 节点\n    # 右子树最小的值不能超过 root 节点\n    return isValid(root.left, minNode, root) and isValid(root.right, root, maxNode)","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"笔记^1：","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"BST 特性：对于每一个结点 node（1）左子树节点的值都比 node 的要小，右子树节点的值都比 node 的大；（2）左右子树都是 BST；\nBST 的中序遍历结果是升序的（将遍历的顺序变成先遍历右结点再遍历左结点，结果就是降序的）；\nBST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求；\nBST 中删除节点 node 的三种情况：\nnode 是叶节点，直接变为 None；\nnode 只有一个非空子节点，直接让其替代自身；\n有两个非空子节点，用左子树最大的节点，或者右子树最小的节点接替自己；\n一般最好不要通过修改节点内部值来实现交换节点，而是把整个节点进行交换；","category":"page"},{"location":"algorithm/algo/#回溯算法","page":"数据结构与算法","title":"回溯算法","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"回溯算法就是个 N 叉树的前后序遍历问题，没有例外。^1","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"回溯算法的特点：简单粗暴效率低，但又特别有用。","category":"page"},{"location":"algorithm/algo/#动态规划","page":"数据结构与算法","title":"动态规划","text":"","category":"section"},{"location":"algorithm/algo/#贪心算法","page":"数据结构与算法","title":"贪心算法","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"所谓贪心算法就是在题目中发现一些规律（专业点叫贪心选择性质），使得你不用完整穷举所有解就可以得出答案。^1","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"动态规划问题的一般形式就是求最值，核心问题就是穷举，特殊之处在于存在「重叠子问题」，需要「备忘录」或者「DP table」来优化穷举过程。","category":"page"},{"location":"algorithm/algo/#参考","page":"数据结构与算法","title":"参考","text":"","category":"section"},{"location":"algorithm/algo/#相关资料","page":"数据结构与算法","title":"相关资料","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"[1]：《数据结构与算法之美》王争｜极客时间；","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"[2]：LeetCode 官方题解；","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"[3]：C 语言中文网；","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"[4]：CodeTop 企业题库：能够根据不同的公司选择题库，有专门性地刷；","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"[5]：labuladong 的算法小抄：十分推荐的刷题资料，索引做得十分好；","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"[6]：labuladong 刷题三件套：《算法秘籍》、《刷题笔记》、刷题插件（提取码：541i）；","category":"page"},{"location":"algorithm/algo/#语录参考","page":"数据结构与算法","title":"语录参考","text":"","category":"section"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"1：labuladong","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"2：王争","category":"page"},{"location":"algorithm/algo/","page":"数据结构与算法","title":"数据结构与算法","text":"3：强劲九","category":"page"},{"location":"library/recommend/#计算机技术","page":"个人推荐","title":"计算机技术","text":"","category":"section"},{"location":"library/recommend/","page":"个人推荐","title":"个人推荐","text":"学会如何使用 Git | 练习 Git 用法：Learning Git Branching 教程网站地址 | Github 项目地址 learnGitBranching；","category":"page"},{"location":"library/recommend/","page":"个人推荐","title":"个人推荐","text":"练习正则表达式 RegexOne | 测试正则表达式 RegExr；","category":"page"},{"location":"library/recommend/","page":"个人推荐","title":"个人推荐","text":"练习 SQL 的网站：SQLZOO；","category":"page"},{"location":"library/recommend/#极客时间：有哪些值得推荐的课程","page":"个人推荐","title":"极客时间：有哪些值得推荐的课程","text":"","category":"section"},{"location":"library/recommend/#数据结构与算法之美","page":"个人推荐","title":"数据结构与算法之美","text":"","category":"section"},{"location":"library/recommend/","page":"个人推荐","title":"个人推荐","text":"王争老师的《数据结构与算法之美》，是我买的第一门课程，也是我计算机知识启蒙。课程中每个篇章的安排十分合理，从头开始学习的话，每天好好花时间，把一节课的东西都吸收了，学完会感觉自己的学到很多。不要求多快，但要求把那些知识都好好地吸收，真正地去学习。","category":"page"},{"location":"library/recommend/#二爷的产品经理课程","page":"个人推荐","title":"二爷的产品经理课程","text":"","category":"section"},{"location":"library/recommend/","page":"个人推荐","title":"个人推荐","text":"二爷就是邱岳，公众号：「二爷鉴书」，发的都是二爷看书的文章。二爷在极客时间上开了两门课，分别是《邱岳的产品手记》和《邱岳的产品实战》。这两门课程，也让我深刻地知道了产品经理所应该有的能力，他应该承担的责任以及每天的工作都是啥。","category":"page"},{"location":"leetcode/algorithm/#算法总结","page":"算法总结","title":"算法总结","text":"","category":"section"},{"location":"leetcode/algorithm/#排序算法","page":"算法总结","title":"排序算法","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。假设有 n 个数据，要从小到大排列，完全有序的数据的有序度就是 n(n-1)2，逆序度就是 0. ","category":"page"},{"location":"leetcode/algorithm/#归并排序（Merge-Sort）","page":"算法总结","title":"归并排序（Merge Sort）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"核心思想：先把数值从中间分成前后两个部分，然后对前后两个部分分别排序，再将排好的两个部分合并在一起，这样整个数组就都有序了。归并排序可以用递归的方式来实现，写递归代码的技巧：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"分析得出递推公式；\n找到终止条件；\n将递推公式翻译成递归代码；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"我根据王争老师的的课程《数据结构与算法之美》第 12 讲中给的伪代码，翻译出了一个 Python 版本的：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"# 递推公式：\n# merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+1...r))\n# \n# 终止条件：\n# p >= r 不用再继续分解\n\n# 归并排序算法，A 是数组，n 表示数组大小\ndef merge_sort(A, n):\n    return merge_sort_c(A, 0, n-1)\n\n# 递归调用函数\ndef merge_sort_c(A, p, r):\n    # 递归终止条件\n    if p >= r:\n        return\n    # 取 p 到 r 之间的中间位置 q\n    q = p + (r - p) / 2\n    # 分治递归\n    merge_sort_c(A, p, q)\n    merge_sort_c(A, q+1, r)\n    # 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]\n    merge(A[p...r], A[p...q], A[q+1...r])\n    \n# 将已经有序的两个子数组合并成一个新的有序数值的函数\ndef merge(A[p...r], A[p...q], A[q+1...r]):\n    i, j, k = p, q+1, 0  # 初始化变量 i, j, k\n    tmp = [0 for _ in range(len(A))]  # 申请一个大小跟 A[p...r] 一样的临时数组\n    while (i <= q) and (j <= r):\n        if A[i] <= A[j]:\n            tmp[k] = A[i]\n            i += 1\n        else:\n            tmp[k] = A[j]\n            j += 1\n        k += 1\n        \n    # 判断哪个子数组中有剩余的数据\n    start, end = i, q\n    if j <= r:\n        start, end = j, r\n    \n    # 将剩余的数据拷贝到临时数组 tmp\n    while start <= end:\n        tmp[k] = A[start]\n        k += 1\n        start += 1\n    \n    # 将 tmp 中的数组拷贝回 A[p...r]\n    for i in range(r-p):\n        A[p+i] = tmp[i]","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"之后会思考一下，如何使用「哨兵」来简化 merge() 函数的编程","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"性能分析：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"归并排序稳不稳定取决于 merge() 函数的实现；\n时间复杂度：mathcalO(nlog n)；\n空间复杂度：mathcalO(n)；","category":"page"},{"location":"leetcode/algorithm/#拓扑排序","page":"算法总结","title":"拓扑排序","text":"","category":"section"},{"location":"leetcode/algorithm/#二分查找（Binary-Search）","page":"算法总结","title":"二分查找（Binary Search）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"王争老师的二分查找循环写法：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"int bsearch(vector<int> a, int n, int value) {\n    int low = 0;\n    int high = n - 1;\n    \n    while (low <= high) {\n        int mid = low + (hight - low) / 2;\n        if (a[mid] == value) {\n            return mid;\n        } else if (a[mid] < value) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    return -1;\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"递归写法：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"int bsearch(vector<int> a, int n, int val) {\n    return bsearchInternally(a, 0, n - 1, val);\n}\n\nint bsearchInternally(vector<int>, int low, int high, int value) {\n    if (low > high) return -1;\n    \n    int mid = low + ((high - low) >> 1);\n    if (a[mid] == value) {\n        return mid;\n    } else if (a[mid] < value) {\n        return bsearchInternally(a, mid+1, high, value);\n    } else {\n        return bsearchInternally(a, low, mid-1, value);\n    }\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"liweiwei 的版本下，循环条件是 left < right，他的写法中，退出循环时一定有 left == right 成立。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"二分查找的时间复杂度是 mathcalO(log n)，查找数据的效率非常高。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"二分查找的局限性：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"依赖顺序表结构，也就是数组；\n只针对有序数据。如果是对于静态数据（没有频繁插入和删除），可以用一次排序，多次二分查找，来均摊排序的成本；\n数据量太小不适合二分查找；\n数据量太大也不适合用二分。主要原因在于二分查找依赖于数组，而数组需要的是连续的内存空间，如果数组太大，难以找到连续的内存空间；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"二分查找的原理及其简单，但是想要写出没有 Bug 的二分查找并不容易。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"尽管第一个二分查找算法在 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。—— 《计算机程序设计艺术》唐纳德 • 克努特（Donald E.Knuth）","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"4 种常见二分查找变形问题：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"查找第一个值等于给定值的元素；\n查找最后一个值等于给定值的元素；\n查找第一个大于等于给定值的元素；\n查找最后一个小于等于给定值的元素；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"变体一：查找第一个值等于给定值的元素","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"int bsearch(vector<int> a, int n, int value) {\n    int low = 0;\n    int high = n - 1;\n    while (low <= high) {\n        int mid = low + ((high - low) >> 1);\n        if (a[mid] > value) {\n            high = mid - 1;\n        } else if (a[mid] < value) {\n            low = mid + 1;\n        } else {\n            if ((mid == 0) || (a[mid - 1] != value)) return mid;    // 第 11 行\n            else high = mid - 1;\n        }\n    }\n    return -1;\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"关键是第 11 行代码：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 mid == 0，那这个元素是第一个元素，肯定是我们要找的；\n如果 mid != 0 并且前面一个元素 a[mid-1] 不等于要找的值 value，那这个元素就是我们要找的；\n如果 a[mid] 前面的元素也是 value，那么此时的 a[mid] 肯定不是第一个等于给定值 value 的元素，让 high = mid - 1；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"变体二：查找最后一个值等于给定值的元素","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"int bsearch(vector<int> a, int n, int value) {\n    int low = 0;\n    int high = n - 1;\n    while (low <= high) {\n        int mid = low + ((high - low) >> 1);\n        if (a[mid] > value) {\n            high = mid - 1;\n        } else if (a[mid] < value) {\n            low = mid + 1;\n        } else {\n            if ((mid == n - 1) || (a[mid + 1] != value)) return mid;  // 第 11 行\n            else low = mid + 1;\n        }\n    }\n    return -1;\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"关键是第 11 行代码：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 a[mid] 是数组中的最后一个元素，那肯定是要找的值；\n如果 a[mid] 的最后一个元素 a[mid+1] 不等于 value，那也说明是要找的最后一个值等于给定值的元素；\n如果发现 a[mid] 的后面一个元素 a[mid+1] 也等于 value，说明当前的 a[mid] 并不是最后一个值等于给定值的元素，更新 low = mid + 1；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"变体三：查找第一个大于等于给定值的元素","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"int bsearch(vector<int> a, int n, int value) {\n    int low = 0;\n    int high = n - 1;\n    while (low <= high) {\n        int mid = low + ((high - low) >> 1);\n        if (a[mid] >= value) {\n            if ((mid == 0) || (a[mid - 1] < value)) return mid;  // 第 7 行\n            else high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 a[mid] 小于给定的值 value，那要查找的值肯定在 [mid+1, high] 之间，所以更新 low = mid + 1；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"对于第 7 行代码，如果 a[mid] 大于等于给定值 value：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 a[mid] 为第一个元素，或者前面一个元素小于要查找的值 value，那 a[mid] 就是我们要找的元素；\n如果 a[mid-1] 也大于等于要查找的值 value，那么说明要查找的元素在 [low, mid-1] 之间，更新 high = mid - 1；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"变体四：查找最后一个小于等于给定值的元素","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"int bsearch(vector<int> a, int n, int value) {\n    int low = 0;\n    int high = n - 1;\n    while (low <= high) {\n        int mid = low + ((high - low) >> 1);\n        if (a[mid] > value) {\n            high = mid - 1;\n        } else {\n            if ((mid == n - 1) || (a[mid + 1] > value)) return mid;  // 第 9 行\n            else low = mid + 1;\n        }\n    }\n    return -1;\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 a[mid] 大于给定的值 value，那么要查找的值肯定在区间 [low, mid-1] 之间，所以更新 high = mid - 1；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"对于第 9 行代码，如果 a[mid] 小于等于给定的值：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 a[mid] 为最后一个元素，或者其后面一个元素大于要查找的值 value，那么其肯定是要找的元素；\n如果 a[mid+1 也小于等于要查找的值，那么说明要查找的元素在 [low, mid+1] 之间，更新 low = mid + 1；","category":"page"},{"location":"leetcode/algorithm/#二叉树的遍历","page":"算法总结","title":"二叉树的遍历","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"实际上，二叉树的前、中、后序遍历就是一个递归过程。写递归代码的关键，就是写出递推公式。写递归公式的关键，就是如果要解决问题 A，就假设问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"// 前序遍历的递推公式：\npreOrder(r) = print r => preOrder(r->left) => preOrder(r->right);\n\n// 中序遍历的递推公式：\ninOrder(r) = inOrder(r->left) => print r => inOrder(r->right);\n\n// 后序遍历的递推公式：\npostOrder(r) = postOrder(r->left) => postOrder(r->right) => print r;","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"根据递推公式，可以写出三种遍历方式的伪代码：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"// 前序遍历\nvoid preOrder(TreeNode* root) {\n  if (root == nullptr) return;\n  print root // 此处为伪代码，表示打印 root 节点\n  preOrder(root->left);\n  preOrder(root->right);\n}\n\n// 中序遍历\nvoid inOrder(TreeNode* root) {\n  if (root == nullptr) return;\n  inOrder(root->left);\n  print root // 此处为伪代码，表示打印 root 节点\n  inOrder(root->right);\n}\n\n// 后序遍历\nvoid postOrder(TreeNode* root) {\n  if (root == nullptr) return;\n  postOrder(root->left);\n  postOrder(root->right);\n  print root // 此处为伪代码，表示打印 root 节点\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"由于每个节点最多会被访问两次，所以前中后序遍历的时间复杂度为 mathcalO(n)。","category":"page"},{"location":"leetcode/algorithm/#堆排序","page":"算法总结","title":"堆排序","text":"","category":"section"},{"location":"leetcode/algorithm/#BF/RK-字符串匹配算法","page":"算法总结","title":"BF/RK 字符串匹配算法","text":"","category":"section"},{"location":"leetcode/algorithm/#广度优先搜索（Breadth-First-Search）","page":"算法总结","title":"广度优先搜索（Breadth-First Search）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"广度优先搜索有三个重要的辅助变量：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"visited 用来记录顶点是否被访问了，避免顶点被重复访问；\nqueue 队列，用来存储已经访问，但相连的顶点还没有被访问的顶点；\nprev 用来记录搜索路径。例如 prev[w] 存储的是，顶点 w 是从哪个前驱顶点遍历过来的。所以为了正向打印出路径，需要递归地进行。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"广度优先搜索 C++ 模板：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"private:\n\tstatic constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\npublic:\n\tvector<vector<int>> BFS(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size(0);\n        vector<vector<int>> seen(m, vector<int>(n));\n        queue<pair<int, int>> q;\n\n        // 广度优先搜索\n        while (!q.empty()) {\n            auto [i, j] = q.front();\n            q.pop();\n\t\t\tfor (int d = 0; d < 4; ++d) {\n                int ni = i + dirs[d][0];\n                int nj = j + dirs[d][1];\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && !seen[ni][nj]) {\n                    // ...;\t// 写某些具体的操作\n                    q.emplace(ni, nj);\n                    seen[ni][nj] = 1;\n                }\n            }\n        }\n        return ...;\t\t\t// 返回结果\n    }\n","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"Python3 模板","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"def BFS(self, matrix: List[List[int]]) -> ...:\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    m, n = len(matrix), len(matrix[0])\n    q = collections.deque(...);\t\t# 队列\n    seen = set(...)\t\t\t\t\t# 将见过的位置坐标放进集合里面\n    \n    while q:\n        i, j = q.popleft()\n        for d in range(4):\n            ni = i + dirs[d][0]\n            nj = j + dirs[d][1]\n            if (0 <= ni < m) and (0 <= nj < n) and ((ni, nj) not in seen):\n                # ...\t\t\t\t# 写某些具体操作\n                q.append((ni, nj))\n                seen.add((ni, nj))\n    return ...\t\t\t\t\t\t# 返回结果 ","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"时间复杂度：mathcalO(V+E)，空间复杂度：mathcalO(V)；V E 分别为有向图顶点和边的个数。","category":"page"},{"location":"leetcode/algorithm/#深度优先搜索（Depth-First-Search）","page":"算法总结","title":"深度优先搜索（Depth-First Search）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"深度优先搜索（DFS），最直观的例子就是「走迷宫」。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"C++ 深度优先搜索的框架","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"vector<int> temp;\nvoid dfs(int cur, int n) {\n    if (cur == n + 1) {\n        // 记录答案\n        // ...\n        return;\n    }\n    // 考虑选择当前位置\n    temp.push_back(cur);\n    dfs(cur + 1, n, k);\n    temp.pop_back();\n    // 考虑不选择当前位置\n    dfs(cur + 1, n, k);\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"时间复杂度：mathcalO(E)，空间复杂度：mathcalO(V)；V E 分别为有向图顶点和边的个数。","category":"page"},{"location":"leetcode/algorithm/#贪心算法（Greedy-Algorithm）","page":"算法总结","title":"贪心算法（Greedy Algorithm）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"贪心算法的解题步骤：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"贪心算法适用的问题：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大；\n初步尝试：选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据；\n举例子：检查贪心算法产生的结果是否最优。因为贪心贪心算法并不总能够给出最优解；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"王争：掌握贪心算法的关键是多练习。不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"以下具体例子，应该可以帮助自己去理解贪心算法：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"1. 分糖果：有 m 个糖果和 n 个孩子（孩子比糖果多（mn），要把糖果分配给孩子。糖果有大小之分，并且每个孩子对于糖果大小的需求是不一样的，如何分配才能够尽可能地满足最多数量的孩子？","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"2. 钱币找零：纸币面值有 1、2、5、10、20、50、100 元的，每种面值的纸币有张数限制，如何用最少张的纸币去支付 K 元？","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"用户「开心小毛」留言：找零问题不能用贪婪算法，即使有面值为 1 元的币值也不行：考虑币值为 100，99 和 1 的币种，每种各 100 张，找 396 元。动态规划可求出 4 张 99 元，但贪心算法解出需 3 张 100 和 96 张 1 元。LeetCode 322. 零钱兑换","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"3. 区间覆盖：有 n 个区间，起始端点和结束端点分别为 l_1r_1 l_2 r_2dots，选出两两不相交的区间，最多可以选出多少个？","category":"page"},{"location":"leetcode/algorithm/#霍夫曼编码（Huffman-Coding）","page":"算法总结","title":"霍夫曼编码（Huffman Coding）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中。压缩率通常在 20% ~ 90% 之间。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率。出现频率较多的字符，用稍微短一些的编码，出现频率少的，用稍微长一点的编码。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"问题：假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1 byte = 8 bits），存储这 1000 个字符就需要 8000 biits，如何对这些数据进行压缩？","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"假设文件中只有 6 个字符 a、b、c、d、e、f，并且出现频率从高到低排序。可以将其编码为","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"字符 出现频率 编码 总二进制位数\na 450 1 450\nb 350 01 700\nc 90 001 270\nd 60 0001 240\ne 30 00001 150\nf 20 00000 100","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"这样一来，任何字符的编码都不会是另一个的前缀，在解压缩的时候，读取尽可能长的可解压二进制串。经过这种编码之后，这 1000 个字符只需要 1910 bits 就可以了，压缩率 73.75%。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"问题是，如何根据字符出现频率的不同，给不同的字符进行不同长度的编码，才能不混淆不同的字符？方法如下：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"把每个字符看做一个节点，并且把频率也放到优先队列当中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"王争老师的课程《数据结构与算法之美》第 37 讲中有一张图片，结合图片去看就很好理解了。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"(Image: huffman_coding_queue)","category":"page"},{"location":"leetcode/algorithm/#Prim-和-Kruskal-最小生成树算法","page":"算法总结","title":"Prim 和 Kruskal 最小生成树算法","text":"","category":"section"},{"location":"leetcode/algorithm/#Dijkstra-单源最短路径算法","page":"算法总结","title":"Dijkstra 单源最短路径算法","text":"","category":"section"},{"location":"leetcode/algorithm/#分治算法（Divide-and-Conquer）","page":"算法总结","title":"分治算法（Divide and Conquer）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"MapReduce、GFS 和 Bigtable 是 Google 大数据处理的三驾马车。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"分治算法是一种处理问题的思想，递归是一种编程技巧，这就是分治和递归的区别所在。分治算法的核心思想：分而治之。分治算法的递归实现中，每一层递归都会涉及这三个操作：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"分解：将原问题分解成一系列子问题；\n解决：递归地求解各个子问题，直到子问题足够小到可以直接求解；\n合并：将子问题的结果合并成原问题；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"能够用分治算法解决的问题，需要满足：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"原问题与分解成的小问题具有相同的模式；\n原问题分解成的子问题可以独立求解，子问题之间没有相关性；\n具有分解终止条件 —— 有足够小到可以直接求解的子问题；\n子问题合并成原问题的操作复杂度不能太高；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"分治算法的应用：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"对于海量数据的情况（数据量远远大于内存的大小），可以用分治的思路，用多线程或者多机处理，加快处理速度；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"问题：如何编程求出一组数据的有序对个数或者逆序对个数？","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"利用归并排序算法，将两个有序的小数组，合并成一个有序的数组，同时计算逆序对个数。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"王争老师的课程《数据结构与算法之美》第 38 讲有相关代码可供参考。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"MapReduce 的本质就是分治：其框架只是一个人物调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳，就重新从 Borg 中调度一台机器执行。","category":"page"},{"location":"leetcode/algorithm/#回溯算法（Backtrack）","page":"算法总结","title":"回溯算法（Backtrack）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"0 - 1 背包：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"// 0 - 1 背包的回溯算法实现\nvector<int> weight = {2, 2, 4, 6, 3};   //\t物品重量\nint w = 9;      // \t背包承受的最大重量\nint maxW = INT_MIN;\nvoid f(int i, int cw, int w) {  // 调用 f(0, 0)\n    int n = weight.size()\n    if (cw == w || i == n) {  // cw == c 表示装满了，i == n 表示物品都考察完了\n        if (cw > maxW) {\n            maxW = cw;\n            return maxW;\n        }\n    }\n    f(i + 1, cw, w);  // 选择不装第 i 个物品\n    if (cw + weight[i] <= w) {\n        f(i + 1, cw + weight[i], w);  // 选择装第 i 个物品\n    }\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"这种写法的时间复杂度很高，可以使用「备忘录」来记录所有已经计算过的值，再次要用到的时候，就直接拿出来。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"vector<int> weight = {2, 2, 4, 6, 3};     // 物品重量\nint w = 9;\nint maxW = INT_MIN;\nvector<vector<int>> mem(n, vector<int>(w + 1));\nvoid f(int i, int cw, int w) {\n    int n = weight.size()\n    if (cw == w || i == n) {\n        if (cw > maxW) {\n            maxW = cw;\n            return;\n        }\n    }\n    if (mem[i][cw]) {return;}  //  重复状态\n    mem[i][cw] = true;   // 记录 (i, cw) 这个状态\n    f(i + 1, cw);        // 选择不装第 i 个物品\n    if (cw + weight[i] <= w) {\n        f(i + 1, cw + weight[i]);  // 选择装第 i 个物品\n    }\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"加了「备忘录」的方法跟动态规划的执行效率已经基本没有差别。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"适用问题：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"解决一个问题有多个步骤\n每个步骤有多种方法\n需要找出所有的方法","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"原理：在一棵树上的深度优先遍历","category":"page"},{"location":"leetcode/algorithm/#动态规划（Dynamic-Programming）","page":"算法总结","title":"动态规划（Dynamic Programming）","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"把问题分解为多个阶段，每个阶段对应一个决策。记录每一个阶段可达的状态合集（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"0 - 1 背包问题：对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少？","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"用一个二维数组 state[n][w+1] 来记录每个物品决策完可以到达的状态。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"// C++ 版本的代码\n// weight: 物品重量，n: 物品个数，w: 背包可承载重量\nint knapsack(vector<int> weight, int n, int w) {\n    vector<vector<int>> states(n, vector<int>(w + 1)); // 默认值 0\n    states[0][0] = 1;  // 第一行的数据要特殊处理，可以利用哨兵优化\n    if (weight[0] <= w) {\n        states[0][weight[0]] = 1;\n    }\n    for (int i = 1; i < n; ++i) {  // 动态规划状态转移\n        for (int j = 0; j <= w; ++j) {  // 不把第 i 个物品放入背包\n            if (states[i - 1][j] == 1) {states[i][j] = states[i - 1][j]};\n        }\n        for (int j = 0; j <= w - weight[i]; ++j) {  // 把第 i 个物品放入背包\n          if (states[i - 1][j] == 1) {states[i][j + weight[i]] = 1;}  \n        }\n    }\n    for (int i = w; i >= 0; --i) {  // 输出结果\n        if (states[n - 1][i] == 1) {return i;}\n    }\n    return 0;\n}","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"一般来说动态规划是一种空间换时间的方法。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果对上面的代码进行空间优化，只需要一个大小为 w+1 的一维数组就可以解决：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"def kanpsack2(items, n, w):\n    states = [False for _ in range(w+1)]\n    states[0] = True  # 第一行的数据要特殊处理，可以利用哨兵优化\n    if (items[0] <= w):\n        states[items[0]] = True\n    \n    for i in range(1, n):  # 动态规划\n        # 这一行 j 需要从大到小来处理，否则会出现 for 循环重复计算\n        # 原因是：\n        for j in range(w-items[i], -1, -1):  # 把第 i 个物品放入背包\n            if states[j] == True:\n                states[j+items[i]] = True\n                \n    for i in range(w, -1, -1):  # 输出结果\n        if states[i] == True:\n            return i\n    \n    return 0","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"0 - 1 背包问题（升级版）：现在不仅考虑背包重量和物品重量，不同的物品还有不同的价值，在满足背包最大重量限制下，背包中物品的总价值的最大值是多少？","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果使用回溯算法：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"# Python 版本的代码\nmaxV = float('-inf')  # 结果放到 maxV 中\nitems = [2, 2, 4, 6, 3]  # 物品的重量\nvalue = [3, 4, 8, 9, 6]  # 物品的价值\nn = 5  # 物品个数\nw = 9  # 背包承受的最大重量\ndef f(i, cw, cv):\n    if (cw == w) or (i == n):  # cw == w 表示装满了，i == n 表示物品都考察完了\n        if (cv > maxV):\n            maxV = cv\n        return\n    f(i+1, cw, cv)  # 选择不装第 i 个物品\n    if (cw + weight[i] <= w):\n        f(i+1, cw+weight[i], cv+value[i])  # 选择装第 i 个物品","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果使用动态规划：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"def knapsack3(weight, value, n, w):\n    states = [[0 for i in range(w+1)] for _ in range(n)]\n    for i in range(n):  # 初始化 states\n        for j in range(w+1):\n            states[i][j] = -1\n            \n    states[0][0] = 0\n    if (weight[0] <= w):\n        states[0][weight[0]] = value[0]\n        \n    for i in range(1, n):  # 动态规划，状态转移\n        for j in range(w+1):  # 不选择第 i 个物品\n            if (states[i-1][j] >= 0):\n                states[i][j] = states[i-1][j]\n                \n        for j in range(w-weight[i]+1):  # 选择第 i 个物品\n            if (states[i-1][j] >= 0):\n                v = states[i-1][j] + value[i]\n                if (v > states[i][j+weight[i]]):\n                    states[i][j+weight[i]] = v\n                    \n    # 找出最大值\n    maxvalue = -1\n    for j in range(w+1):\n        if (states[n-1][j] > maxvalue):\n            maxvalue = states[n-1][j]\n    \n    return maxvalue","category":"page"},{"location":"leetcode/algorithm/#A*-算法","page":"算法总结","title":"A* 算法","text":"","category":"section"},{"location":"leetcode/algorithm/#哈希算法","page":"算法总结","title":"哈希算法","text":"","category":"section"},{"location":"leetcode/algorithm/#字符串匹配算法","page":"算法总结","title":"字符串匹配算法","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"字符串匹配算法中 BM、KMP、AC 自动机都是比较难懂的算法，对于算法有一定基础的人来说，想要看懂也不容易。要求是能够看懂就好，不要求自己能够实现。","category":"page"},{"location":"leetcode/algorithm/#Trie-树","page":"算法总结","title":"Trie 树","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"面试官喜欢考 Trie，但是要求能够看懂，会结合应用场景来考，考察的是面试者知道啥时候要用 Trie 树。","category":"page"},{"location":"leetcode/algorithm/#BM","page":"算法总结","title":"BM","text":"","category":"section"},{"location":"leetcode/algorithm/#KMP","page":"算法总结","title":"KMP","text":"","category":"section"},{"location":"leetcode/algorithm/#AC-自动机","page":"算法总结","title":"AC 自动机","text":"","category":"section"},{"location":"leetcode/algorithm/#其他补充知识","page":"算法总结","title":"其他补充知识","text":"","category":"section"},{"location":"leetcode/algorithm/#最高有效位","page":"算法总结","title":"最高有效位","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果正整数 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位为 1，其余都是 0，因此 y (y-1)=0. 如果 yle x，则称 y 为 x 的「最高有效位」。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"题目 338. 比特位计数 利用这样的一个方式，动态地维护最高有效位 highBit，然后算出所有小于给定整数 n 的整数二进制表示包含 1 的数量。","category":"page"},{"location":"leetcode/algorithm/#最低有效位","page":"算法总结","title":"最低有效位","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 lfloorfracx2rfloor，如果 bitslfloorfracx2rfloor 的值已知，则可以得到 bitsx 的值：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"如果 x 是偶数，则 bitsx=bitslfloorfracx2rfloor；\n如果 x 是奇数，则 bitsx = bitslfloorfracx2rfloor+1.","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"上述两种情况可以合并成：bitsx  的值等于 bitslfloorfracx2rfloor 的值加上 x 除以 2 的余数。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"由于 lfloorfracx2rfloor 可以通过 xgg1 得到，x 除以 2 的余数可以通过 x  1 得到，因此有：bitsx=bitsxgg1+(x1).","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"题目 338. 比特位计数 利用最低有效位，遍历从 1 到 n 的每个正整数 i，计算 bits 的值，最终得到的数组 bits 即为答案。","category":"page"},{"location":"leetcode/algorithm/#Brian-Kernighan-算法","page":"算法总结","title":"Brian Kernighan 算法","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"记 f(x) 表示 x 和 x-1 进行「与」运算所得的结果（即 f(x)=x(x1)），那么 f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。参考 LeetCode 题目 461. 汉明距离。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"例如 x=10001000，x-1=10000111，那么 x(x-1)=10000000. ","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"利用 Brian kernighan 算法计算出一个数的二进制表示有多少个 1 的方法如下。不断让 s=f(s)，直到 s=0。每循环一次 s 都会删除二进制表示中最右侧的 1，最终的循环次数即为 s 二进制表示中的 1 的数量。","category":"page"},{"location":"leetcode/algorithm/#索引","page":"算法总结","title":"索引","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"软件开发中，抛开业务和功能的外壳，本质都可以抽象为「对数据的存储和计算」，「存储」需要的就是数据结构，「计算」需要的就是算法。索引设计得好，可以节省存储空间、提高数据的处理效率。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"索引的需求定义：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"功能性需求：\n数据是格式化数据还是非格式化数据。MySQL 中的是结构化数据，搜索引擎中的网页是非结构化数据；\n数据是静态数据还是动态数据。静态数据不会有数据的增加、删除、更新操作；\n索引存储在内存还是硬盘。数据在内存上的查询速度比在磁盘中的快；\n单值查找还是区间查找。有一些数据结构不支持区间查找；\n单关键词查找还是多关键词组合查找。可以通过集合操作（并交集）来得到多关键词查询；\n非功能性需求\n无论是那种存储方式，索引对存储空间的消耗不能太大；\n在考虑索引查询效率的同时，还要考虑索引的维护成本。对原始数据的增删改时，也要维护索引；","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"构建索引常用的数据结构：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"散列表：增删改查操作的性能好，具有 mathcalO(1) 的时间复杂度。例如 Redis、Memcache 等键值数据库；\n红黑树：具有 mathcalO(log n) 的时间复杂度。例如 Ext 文件系统中对磁盘块的索引；\nB+ 树： ","category":"page"},{"location":"leetcode/algorithm/#工程问题与算法题","page":"算法总结","title":"工程问题与算法题","text":"","category":"section"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"工程上的问题比较开放，需要综合各种因素去选择数据结构和算法。我们要考虑到的可能有编码难度、维护成本、数据特征、数据规模等，只有最合适的方法，没有最好的方法。而算法题的背景、条件、限制都十分明确，只需要在规定的输入、输出下找到最优解就好了。","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"关于合理地选择使用哪种数据结构和算法，王争老师在极客时间上的课程《数据结构与算法之美》^1中总结了六条经验：","category":"page"},{"location":"leetcode/algorithm/","page":"算法总结","title":"算法总结","text":"时间、空间复杂度不能跟性能划等号；\n复杂度不是执行时间和内存消耗的精确值；\n代码的执行时间有时不跟时间复杂度成正比【大 mathcalO 表示法有效的前提是在处理大规模数据的情况下才成立】；\n对于处理不同问题的不同算法，其复杂度大小没有可比性；\n抛开数据规模谈数据结构和算法都是「耍流氓」；\n结合数据特征和访问方式来选择数据结构。如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式，这才是解决问题的重点；\n区别对待 IO 密集、内存密集和计算密集；\n善用语言提供的类，避免重复造轮子；\n千万不要漫无目的地过度优化。要优化代码的时候，要先做 Benchmark 基准测试，避免想当然地换了更高效的算法，但是实际上性能是下降了的；","category":"page"},{"location":"git/git_notebook/#第一章-Git-基础","page":"Git 学习笔记","title":"第一章 Git 基础","text":"","category":"section"},{"location":"git/git_notebook/#.-常用命令","page":"Git 学习笔记","title":"1. 常用命令","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.1. 配置 user 信息","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"配置自己的用户名为 strongnine，邮箱为 strongnine@163.com，实际用的时候请将此换成自己的用户名和邮箱。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"$ git config --global user.name 'strongnine'\n$ git config --global user.email 'strongnine@163.com'","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.2. config 的三个作用域","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"$ git config --global\n$ git config --local","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"可以显示自己目前的局部（local）或者全局（global）的配置。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 显示 config 设置\n$ git config --list --local\n$ git config --list --global","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.3. git 命令","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"创建仓库可以在 GitHub 上创建仓库，然后再通过 git clone 克隆到自己的本地，也可以现在本地新建的文件夹里用 git init 初始化创建仓库。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# git 仓库的初始化\n$ git init","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"查看当前仓库状态：git status 可以查看当前仓库的状态。能够看到文件的修改、删除、添加、以及重命名（重命名的逻辑就是删除一个文件并且添加一个文件），并且还能够看到当前存在的冲突啥的。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"添加文件：git add 可以将某个文件的更新添加到暂存区区里；","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git add -u：将文件的修改、文件的删除，添加到暂存区。git add .：将文件的修改，文件的新建，添加到暂存区。git add -A：将文件的修改，文件的删除，文件的新建，添加到暂存区。git add -A 相对于 git add -u 命令的优点 ： git add -A 可以提交所有被删除、被替换、被修改和新增的文件到数据暂存区，而 git add -u 只能操作跟踪过的文件。git add -A 等同于 git add -all. ","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"撤销添加（版本回退）：有的时候我们 add 了一个文件，想要撤销，可以用 git reset","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"撤销添加：git reset HEAD 将绿字变成红字；","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"提交修改：git commit 将当前暂存区里的更新提交，会用默认编辑器跳出信息，可以在第一行添加提交的备注信息，例如 \"add README.md\". ","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git commit -m\"add README.md\" 可以直接将备注信息一起提交。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"删除文件：git mv <文件名> 是正确删除文件的方法。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"重命名的文件：git mv oldname newname","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"当你重命名了一个文件之后，用 git status 会提示有一个文件被删除，有一个文件是新的 Untracked 文件。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"重置文件：git reset --hard 用来对暂存区的文件进行重置。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"warning: Warning\n注意：git reset 是一条相对危险的命令。","category":"page"},{"location":"git/git_notebook/#.-版本管理","page":"Git 学习笔记","title":"2. 版本管理","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.1. 分支管理","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"查看历史：git log 可以查看当前分支的提交历史记录日志，命令 gitk 可以调出图形界面查看历史版本。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git log --graph 可以有比较图形化的界面；git log --oneline 只显示每次提交的备至；git log -n4 --online 指定查看最近 4 个 commit；git log --all 查看全部分支的日志；git log --all --graph 用图形化的方式显示所有分支的日志；","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"查看分支：git branch -v 可以查看本地有多少分支。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git branch -av：查看所有分支；git branch -d 分支名：删除分支；git branch -D 分支名：强制删除分支；","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"warning: Warning\n如果分支还未被 merged 的时候要用强制删除，请确保该分支无用。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"创建分支：git checkout ","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git checkout -b 可以创建新分支并且切换到该新的分支；","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"有的时候需要加上 --decorate 参数才可以显示（master）（temp）等分支信息。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.2. .git 目录的内容","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"cat 命令主要用来查看文件内容，创建文件，文件合并，追加文件内容等功能。 cat HEAD 查看 HEAD 文件的内容 git cat-file 命令 显示版本库对象的内容、类型及大小信息。 git cat-file -t b44dd71d62a5a8ed3 显示版本库对象的类型 git cat-file -s b44dd71d62a5a8ed3 显示版本库对象的大小 git cat-file -p b44dd71d62a5a8ed3 显示版本库对象的内容","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"HEAD：指向当前的工作路径 config：存放本地仓库（local）相关的配置信息。 refs/heads：存放分支 refs/tags：存放tag，又叫里程牌 （当这次 commit 是具有里程碑意义的，比如项目 1.0 的时候 就可以打 tag） objects：存放对象 .git/objects/ 文件夹中的子文件夹都是以哈希值的前两位字符命名 每个 object 由 40 位字符组成，前两位字符用来当文件夹，后 38 位做文件。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"commit、tree、blob 的关系","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"(Image: relations)","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"一个 commit 对应一颗 tree，tree 相当于文件夹，blob 相当于具体的文件（数据）。git 里面，文件内容相同， 就是视为同一个文件。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"当创建了新的空文件夹时，使用 status 不会检测到这个空的文件夹。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.3. 分离头指针","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"变更没有基于某个 branch，在分离头指针进行的 commit，如果没有及时合并到某个 branch，可能会被 git 当作垃圾清掉。如果这种变更是重要的，就要将其与某个 branch 绑在一起。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git checkout -b 可以创建新分支并且切换到该新的分支。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"HEAD 指针可以指向某个分支的最后一次提交，也可以不和某个分支挂钩，当处于分离头指针时，可以直接指向某个 commit。它只能够定位到某个 commit。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"对比提交之间的差异：git diff [commit1] [commit2] 可以比较两个具体的 commit 的差异。git diff HEAD HEAD^1 将当前结点与其父亲结点进行对比。HEAD^1, HEAD~1, HEAD~, HEAD^ 都一样。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"一个节点，可以包含多个子节点（checkout 出多个分支）\n一个节点可以有多个父节点（多个分支合并）\n^ 和 ~ 都是父节点，区别是跟随数字时候，^2 是第二个父节点，而 ~2 是父节点的父节点\n^ 和 ~ 可以组合使用,例如 HEAD~2^2","category":"page"},{"location":"git/git_notebook/#第二章-独自使用-Git","page":"Git 学习笔记","title":"第二章 独自使用 Git","text":"","category":"section"},{"location":"git/git_notebook/#.-commit-的操作","page":"Git 学习笔记","title":"1. commit 的操作","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.1. 修改 commit 的 message","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 修改最新 commit 的信息\n$ git commit --amend\n# 想要修改旧 commit 的信息，需要先选择其父节点\n# 运行后会弹出一个交互界面，在里面修改、保存之后\n# 还会继续弹出一个交互界面，提示要把 message 如何修改\n$ git rebase -i 父节点","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"warning: Warning\n这种操作只适用于还未合并到「主线」 的分支上，否则会影响到合作者的工作。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.2. 整理多个 commit ","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 和上一个操作相似\n# 在弹出的交互界面进行不同的修改就行（会有提示）\n$ git rebase -i 父节点\n\n# 上面的是把「连续的」commit 合并，还有一种是把「间隔的」合并\n$ git rebase -i 父节点","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.3. 对比差异","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 对比暂存区和 HEAD 里面内容的差异（看看做了哪些改动）\n$ git diff --cached\n\n# 对比工作区和暂存区的不同\n$ git diff\n\n# 只比较某个文件\n$ git diff -- <文件名>\n\n# 查看不同提交的指定文件的差异\n$ git diff <指针 1> <指针 2> -- <文件名>","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.4. 恢复变更","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 把暂存区里面的文件全部恢复成和 HEAD 一样的\n$ git reset HEAD\n\n# 让工作区的文件恢复为暂存区一样（变更工作区）\n$ git checkout -- index.html\n\n# 取消暂存区部分文件的更改\n$ git reset HEAD -- <文件名>...","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.5. 消除最近几次提交","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 将头指针指向特定的某次提交，并且删除这之前的提交\n# <危险指令> 慎用！！！\n$ git reset --hard <指针>","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.6. 删除文件","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 正确删除文件的方法\n$ git rm <文件名>","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.7. 临时加塞的紧急任务 —— stash 的使用","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 把当前状态存放\n$ git stash\n# 列出状态区\n$ git stash list\n# 恢复暂存区（弹出之前放进 stash 顶的），但是 stash 堆栈里的信息还会在\n$ git stash apply\n# 恢复的基础上还会丢掉 stash 里面的信息\n$ git stash pop","category":"page"},{"location":"git/git_notebook/#.-Git-管理","page":"Git 学习笔记","title":"2. Git 管理","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.1. 指定不需要 Git 管理的文件","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":".gitignore 文件上的内容就是表示指定类型的文件不给 Git 进行管理。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.2. Git 的备份","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"(Image: git_learning_fig2)","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"哑协议传输进度不可看见，智能协议可见。智能协议比哑协议快。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# --bare 代表不带工作区的裸仓库\n# 哑协议\n$ git clone --bare /path/to/repo.git <拷贝路径.git>\n# 智能协议\n$ git clone --bare / file:///path/to/repo.git <拷贝路径.git>\n\n# 把本地的变更同步到远端\n$ git remote -v\n$ git remote add <名称> <协议地址>\n# 查看分支\n$ git branch -av\n$ git push <名称>\n$ git push --set-upstream <  > <  >","category":"page"},{"location":"git/git_notebook/#第三章-Github-同步","page":"Git 学习笔记","title":"第三章 Github 同步","text":"","category":"section"},{"location":"git/git_notebook/#配置公私钥","page":"Git 学习笔记","title":"配置公私钥","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 Github 首页上，寻找 help，在上面有关于如何 connecting to github with SSH 的做法。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 打开 git bash 在里面输入下面命令\n# 若干存在 id_rsa 和 id_rsa.pub 文件则代表已经有公私钥\n# 否则应该要根据 Help 上的提示进行生成\n$ ls - al ~/.ssh\n# 查看 id_rsa.pub 的内容\n$ cd ~/.ssh\n$ cat id_rsa.pub\n# 复制里面的内容，前往 github 账户设置里面添加 SSH keys","category":"page"},{"location":"git/git_notebook/#**把本地仓库同步到-Github**","page":"Git 学习笔记","title":"把本地仓库同步到 Github","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 添加一个新的 remote\n$ git remote add <名称> <SSH>\n# 查看已有的 remote\n$ git remote -v\n\n# 把所有内容 push\n$ git push <name> --all\n# 如果远端有某些文件是本地未包含的，这个分支会被拒绝 push\n# 需要把远端的先「拉」下来\n$ git fetch <name> master\n# 切换到 master 分支\n$ git checkout master\n# 与远端的 .../master 的分支合并\n$ git merge <远端分支>\n# 但注意如果两个分支都是独立的，没有共同的历史，那么会拒绝合并\n# 查看 merge 帮助\n$ git merge -h\n$ git merge --allow-unrelated-histories <远端分支>\n# 现在进行 push 就不会报错了\n$ git push <name> master","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"注：在之后为了方便学习，将一些命令与视频里面的进行同步，<name> 会用 github 来代替，因为我们把远端的仓库 fetch 下来并且命名为 gitHub 了","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"个人笔记总结git remote -v 查看远程版本库信息\ngit remote add <name> <url>添加 githup 远程版本库\ngit fetch <name> 拉取远程版本库\ngit merge -h 查看合并帮助信息\ngit merge --allow-unrelated-histories githup/master 合并 <name> 上的 master 分支（两分支不是父子关系，所以合并需要添加 –allow-unrelated-histories）\ngit push <name> 推送同步到 <name> 仓库—— by DriveMan_邱佳源","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"fast forward 到底是什么？举个例子，本地分支往远端分支做 push，如果远端分支不是本地分支的祖先，那它俩就不是 fast forward 了。反之，它俩就是 fast forward 的关系。","category":"page"},{"location":"git/git_notebook/#第四章-Git-多人单分支集成协作","page":"Git 学习笔记","title":"第四章 Git 多人单分支集成协作","text":"","category":"section"},{"location":"git/git_notebook/#.-多个人对文件修改","page":"Git 学习笔记","title":"1. 多个人对文件修改","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.1. 不同人修改了不同文件","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# \n# 会出现 Non fast_forwards 的报错，远端仓库会拒绝这个 push\n# 先把远端的 fetch 下来\n$ git fetch <name>(github)\n# 然后查看 branch 会发现有 [ahead 1, behind 1] 这样的信息，\n# 代表远端有的这里没有和这里有的远端没有\n$ git branch -av\nfeature/add_git_commands     07c85df [ahead 1, behind 1] ......\n\n# 有时候会考虑合并\n$ git merge (github/feature/add_git_commands)","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"老师你好，我有个问题哈，clone 命令 git clone git@github.com:git2019/gitlearning.git 既然已经把远程仓库所有内容都克隆到本地了，为什么还需要 git checkout -b feature/addgitcommands origin/feature/addgit_command 命令基于远程分支在本地建立分支，不是从远程clone下来了嘛，为什么还要新建，难道 clone 命令不能克隆分支吗？作者回复：我们在本地无法直接在 clone 下来的远程分支上做变更的，只能基于远程分支建本地分支后，才能创建 commit。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.2. 不同人修改同一文件的不同区域","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# pull 会把远端的内容拉下来，并且本地的也会进行更新\n# 简介的方法就是直接 pull，还有一种是 fetch + merge\n# 多查看 branch ，看看 ahead 和 behind 的数目\n$ git branch -av\n\n# 当只有 ahead 没有 behind 的时候，肯定是 fast-forward 可以提交","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"fast-forword 看了英语翻译为快进，结合 git branch -av 中的 ahead 和 behind，ahead 是本地仓库比远端仓库多 commit，behind 是本地仓库比远端仓库少 commit。对正常的备份系统来说，我本地只能比备份多，备份不可能比我本地多才是。然而，git 由于多用户提交原因出现备份比本地多了，本地滞后了，所以需要 pull 一下，让本地比备份相等或多，这种情况就是 fast forward ，也就是我本地要比备份快进。不知理解对否？作者回复：其实就是两个分支的关系为 0|n 或者 n|0 ，如果两个分支直接为 n|m 的关系就不是 fast forward 。A 分支比 B 分支多 5 个 commit，B 比 A 分支多 3 个 commit。A 和 B 就不是 fast forward。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"1.3. 不同人修改同一文件的同一区域","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 如果 push 不上去，使用 merge 又提示已经更新到最新了\n# 就说明远端变了，要及时更新\n$ git pull\nAuto-merging (index.html)\nCONFLICT(content): Merge conflict in (index.html)\n# 提示 CONFLICT(content) 说明文件有冲突，不能自动合并 index.html\n# 打开这个文件，会提示哪里出现冲突\n$ vi index.html\n# 编辑完成后查看状态\n$ git status\n\n# 如果这个分支有问题了，可以用 --abort 退出合并\n$ git merge --abort\n$ git commit -am'(commit text)'","category":"page"},{"location":"git/git_notebook/#.-更改了文件名","page":"Git 学习笔记","title":"2. 更改了文件名","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.1. 同时变更了文件名和内容","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 其中有一个人变更了文件名\n# 另一个人只变更了文件内容\n# pull 的话会智能识别问题\n$ git pull","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"2.2. 同一文件改成不同的文件名","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 依旧是报冲突\n$ git pull\n# 查看工作目录，会出现未命名的文件，和两个重命名的文件\n# 如果使用 diff 查看两个文件的差异，不会显示差异\n$ diff <file-1> <file-2>\n# 使用 status，会提示：\nboth deleted:  <oldfilename>\nadded by us:   <filename-1>\nadded by them: <filename-2>\n# 可以先移除不要的文件，再加上想要保存的文件名\n$ git rm <filename-2>\n$ git add <filename-1>\n$ git commit -am'(commit text)'","category":"page"},{"location":"git/git_notebook/#第五章-集成使用禁忌","page":"Git 学习笔记","title":"第五章 集成使用禁忌","text":"","category":"section"},{"location":"git/git_notebook/#.-禁止向集成分支执行-push-f","page":"Git 学习笔记","title":"1. 禁止向集成分支执行 push -f","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"-f, --force 是强制更新，即使不是 fast-forward 也可以 push。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"# 把历史 reset 到某个 log\n$ git reset --hard (b3f390c)\n# 强制 push，就会把在 b3f390c 后面做的改变都删除\n$ git push -f (origin) (feature/add_git_commands)","category":"page"},{"location":"git/git_notebook/#.-禁止向集成分支执行变更历史的操作","page":"Git 学习笔记","title":"2. 禁止向集成分支执行变更历史的操作","text":"","category":"section"},{"location":"git/git_notebook/#第六章-GitHub","page":"Git 学习笔记","title":"第六章 GitHub","text":"","category":"section"},{"location":"git/git_notebook/#.-核心功能","page":"Git 学习笔记","title":"1. 核心功能","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"代码预览、项目管理、集成、团队管理、社交编码（开源）、文档、存放代码。","category":"page"},{"location":"git/git_notebook/#.-寻找开源项目","page":"Git 学习笔记","title":"2. 寻找开源项目","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"使用高级搜索：光标放在搜索框里，按回车就会出现 advanced search 了。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"可以在 Help 上查看有哪些高级搜索的语法。  ","category":"page"},{"location":"git/git_notebook/#.-搭建个人博客","page":"Git 学习笔记","title":"3. 搭建个人博客","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"通过高级搜索在搜索框中输入 blog easily start in:readme stars:>5000 找到 jekyll-now 仓库。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"第一步就是 fork 一个到自己的账号里去。fork 完后修改工程名称：<username>.github.io","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"第二步修改 _config.yml。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 _posts 里面新增文件格式为：2018-12-24-<title>.md","category":"page"},{"location":"git/git_notebook/#第七章-团队协作","page":"Git 学习笔记","title":"第七章 团队协作","text":"","category":"section"},{"location":"git/git_notebook/#.-创建团队项目","page":"Git 学习笔记","title":"1. 创建团队项目","text":"","category":"section"},{"location":"git/git_notebook/#.-挑选合适的分支集成策略","page":"Git 学习笔记","title":"3. 挑选合适的分支集成策略","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在仓库的 Insights => Network 里可以看到特性分支演变历史。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 Options 的 Merge button 可以设置允许哪种合并。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"merge 把分支最后合并到 master 上去；\nsquash merging 把分支的所有 commits 变成一个，再放到主线上去。（在当前主线后面加上）\nrebase merging 把分支的所有 commits 添加到主线后面去。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"后面两种适合于线性开发的情况。","category":"page"},{"location":"git/git_notebook/#.-issue-跟踪","page":"Git 学习笔记","title":"4. issue 跟踪","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"issue 上有标签管理，对不同的问题进行分类。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"还可以对 issue 进行模型管理，自定义一些问题报告的模板。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"有 Bug report、Feature request 等。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"使用 Projects 的看板来管理 issue","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"点击 Pojects 进行看板（Board）的设置。","category":"page"},{"location":"git/git_notebook/#.-Code-review","page":"Git 学习笔记","title":"5. Code review","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"在 Settings 的 Branches 上可以设置特殊分支的保护规则。比如对于 master 分支进行 push 保护，每次 push 都要有特定人数去检查才能通过。","category":"page"},{"location":"git/git_notebook/#.-多分支的集成","page":"Git 学习笔记","title":"6. 多分支的集成","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"特性分支往主干合，要发 Pull requests。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"git rerere 是一个隐藏功能，允许你让 Git 记住解决一个块冲突的方法，在下一次看到相同冲突时，自动解决。","category":"page"},{"location":"git/git_notebook/#第八章-GitLab","page":"Git 学习笔记","title":"第八章 GitLab","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"这两章先看视频过一遍，等到应用的时候可以复习。目前不知道具体的使用需求，先大概看个印象。","category":"page"},{"location":"git/git_notebook/#其它问题","page":"Git 学习笔记","title":"其它问题","text":"","category":"section"},{"location":"git/git_notebook/#.-在-Windows-上如何支持中文","page":"Git 学习笔记","title":"1. 在 Windows 上如何支持中文","text":"","category":"section"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"参考解决 Git 在 windows 下中文乱码的问题.md。","category":"page"},{"location":"git/git_notebook/","page":"Git 学习笔记","title":"Git 学习笔记","text":"有一个注意的点：目前无法解决输入中文字符会显示乱码的问题解决方案：git commit 时，不用 -m 参数，直接回车让 vim 来处理\n进 vim 后按 i 进入编辑模式，完成后再保存退出","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"各种数据类型的范围：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"int: -2147483648 2147483647，大约等于 -2times 10^9sim 2times 10^9.","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"位运算符：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"运算符 描述 实例\n& 按位「与」运算 \n| 按位「或」运算 \n^ 按位「异或」运算 \n~ 按位「取反」运算 \n<< 二进制左移运算 \n>> 二进制右移运算 ","category":"page"},{"location":"leetcode/data_structure/#数组","page":"-","title":"数组","text":"","category":"section"},{"location":"leetcode/data_structure/#C-中的向量（Vector）","page":"-","title":"C++ 中的向量（Vector）","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"vector 容器是 STL 中最常用的容器之一，它与 array 容器非常类似，都可以看作是 C++ 对普通数组的「升级版」。不同之处在于：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"array 实现的是静态数组（容量固定的数组）；\nvector 实现的是动态数组，可以进行元素的插入、删除，动态调整占用的内存空间；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"vector 在尾部插入或删除元素的时间复杂度为 mathcalO(1)，但是如果是在头部或者中部插入或删除元素，时间复杂度为 mathcalO(n). ","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"#include <vector>\nusing namespace std;\n\nvector<int> x;     // 创建存储 int 类型的 vector\nvector<int> xs {2, 3, 5, 7}; // 在创建时指定初始值以及元素个数\nvector<int> x(20); // x 初始时就有 20 个值为 0 的元素\nvector<int> x(20, 1); // x 初始有 20 个值为 1 的元素\nx.reserve(20);     // 给 vector 分配内存，可以容纳 20 个元素\n\n// 给向量 x 分配 size 个 value 值\nx.assign(int size, int value);\t\n// 给向量 x 分配从迭代器初始位置到最终位置的值\nx.assign(InputIterator first, InputIterator last);\t\n\nx.size();          // 返回实际元素个数\nx.assign();        // 用新元素替换原有内容\nx.front();         // 返回第一个元素的引用\nx.back();          // 返回最后一个元素的引用\nx.push_back();     // 添加元素至向量末端\nx.pop_back();      // 将最后的元素弹出","category":"page"},{"location":"leetcode/data_structure/#链表（Linked-list）","page":"-","title":"链表（Linked-list）","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"在 LeetCode 中链表节点的定义为：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"哑节点（Dummy node）：在操作链表时常用的技巧，它的 next 指针指向链表头节点。好处是不用对头节点进行特殊判断。","category":"page"},{"location":"leetcode/data_structure/#栈（Stack）","page":"-","title":"栈（Stack）","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"using namespace std;\nstack<int> stk;    // 声明一个栈 stk\nstk.push(1);       // push 元素进栈\nstk.pop();         // 弹出栈顶元素\nskt.top();         // 查看栈顶元素\nstk.empty();       // 判断栈是否为空","category":"page"},{"location":"leetcode/data_structure/#队列（Queue）","page":"-","title":"队列（Queue）","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"using namespace std;\n// 生成方式\nqueue<string> q;\nqueue<string> q {arr};\n\nq.front();            // 返回第一个元素的引用，如果 q 为空，返回值是未定义的\nq.back();             // 返回最后一个元素的引用\nq.push(const T& obj); // 在尾部添加一个元素的副本\nq.emplace();          // 在尾部生成对象\nq.pop();              // 删除第一个元素\nq.size();             // 返回元素个数\nq.empty();            // 判断是否为空","category":"page"},{"location":"leetcode/data_structure/#哈希表（Hash-map）","page":"-","title":"哈希表（Hash-map）","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"哈希表又叫散列表。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"哈希字典：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"using namespace std;\nunordered_map<int, int> hash;  // 创建哈希表 hash\nhash[k] = v;                   // 插入元素\nhash.erase(k);                 // 移除元素\nhash.clear();                  // 清空元素\n// 打印 hash 表中所有元素\nfor (const auto& elemt : hash) {\n    cout << \"key: \" << elemt.first << \", value: \" << elemt.second << \"\\n\";\n}","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"哈希集合：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"unordered_set<int> hash_set;\n// 判断元素 x 是否在集合中\nif (hash_set.find(x) != hash_set.end()) {\n    return true;\n}","category":"page"},{"location":"leetcode/data_structure/#树（Tree）","page":"-","title":"树（Tree）","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"树的每一个元素叫做「节点」，用来连接相邻节点之间的关系，叫做「父子关系」。具有相同父节点的节点称为「兄弟节点」，没有节点的节点叫做「根节点」，没有子节点的节点叫做「叶子节点」或者「叶节点」。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"高度（Height）：节点到叶子节点的最长路径（边数）；\n深度（Depth）：根节点到这个节点所经历的边的个数；\n层数（Level）：节点的深度 + 1；\n数的高度：根节点的高度；","category":"page"},{"location":"leetcode/data_structure/#二叉树","page":"-","title":"二叉树","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉树（Binary Tree）","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"最常用的树结构是二叉树，是十分重点的内容，在面试中经常考。二叉事的每个节点最多有两个子节点，分别称为「左子节点」和「右子节点」。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"满二叉树：叶子节点全部在最底层，除了叶子节点之外，每个节点都有左右两个子节点。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"完全二叉树：叶子节点全都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"存储二叉树的两种方法：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"基于指针或者引用的二叉链式存储法。这种存储方法比较常用；\n基于数组的顺序存储法。根节点存储在 i = 1 的位置，左子节点存储在 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置，以此类推。下标 i/2 的位置存储的就是父节点；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"一个完全二叉树用数组使用顺序存储法是最省内存的。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉树的遍历：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"前序遍历：对于树中的任意节点来说，先打印这个节点，再打印它的左子树，最后打印它的右子树。节点 => 左子树 => 右子树；\n中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。左子树 => 节点 => 右子树；\n后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本书。左子树 => 右子树 => 节点；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉查找树（Binary Search Tree）","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"又名二叉搜索树，是为了实现快速查找而生的。不仅仅支持快速查找一个数据就，还支持快速插入、删除一个数据。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉查找树要求，在书中的任意一个节点，其左子树中的每一个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉查找树的查找操作：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"如果根节点等于我们要查找的数，直接返回；\n比如要查找的数据比根节点小，在左子树中递归查找；\n否者如果比根节点大，在右子树中递归查找；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"class BinarySearchTree {\nprivate: \n    TreeNode tree;\n    \npublic: \n    TreeNode find(int data) {\n        TreeNode* p = tree;\n        while (p != nullptr) {\n            if (data < p->val) {p = p->left;}\n            else if (data > p->val) {p = p->right;}\n            else {return p;}\n        }\n        return null;\n    }\n}","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉查找树的插入操作：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"如果要插入的数据比节点的数据大：\n并且节点的右子树为空，新数据插到右子节点的位置；\n如果不为空，就再递归遍历右子树，查找插入位置；\n如果要插入的数据比节点数值小：\n并且节点的左子树为空，新数据插到左子节点的位置；\n如果不为空，就再递归遍历左子树，查找插入位置；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"void insert(int data) {\n    if (tree == nullptr) {\n        tree = new TreeNode(data);\n        return;\n    }\n    \n    TreeNode* p = tree;\n    while (p != nullptr) {\n        if (data > p->val) {\n            if (p->right == nullptr) {\n                p->right = new TreeNode(data);\n                return;\n            }\n            p = p->right;\n        } else { // data < p->val\n            if (p->left == nulptr) {\n                p->left = new TreeNode(data);\n                return;\n            }\n            p = p->left;\n        }\n    }\n}","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉查找树的删除操作：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 nullptr；\n如果要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点；\n如果要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它的值替换到要删除的节点上，然后再利用上面两条规则来删除这个最小节点（最小节点肯定没有左子节点）；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"void delete(int data) {\n    TreeNode* p = tree;         // p 指向要删除的节点，初始化指向根节点\n    TreeNode* pp = nullptr;     // pp 记录的是 p 的父节点\n    while (p != nullptr && p->val != data) {\n        pp = p;\n        if (data > p->val) {p = p->right;}\n        else {p = p->left;}\n    }\n    if (p == nullptr) {return;} // \t没有找到\n    \n    // 要删除的节点有两个子节点\n    if (p->left != nullptr && p->right != nullptr) { // 查找右子树中最小节点\n        TreeNode* minP = p->right;\n        TreeNode* minPP = p;    // minPP 表示 minP 的父节点\n        while (minP->left != nullptr) {\n            minPP = minP;\n            minP = minP->left;\n        }\n        p->val = minP->val;     // 将 minP 的数据替换到 p 中\n        p = minP;               // 下面就是删除 minP\n    }\n    \n    // 删除节点是叶子节点或者仅有一个节点\n    TreeNode* chile;            // p 的子节点\n    if (p->left != nullptr) {child = p->left;}\n    eles if {p->right != nullptr} {child = p->right;}\n    else {child = nullptr;}\n    \n    if (pp == nullptr) {tree = child;} // 删除的是根节点\n    else if (pp->left == p) {pp->left = child;}\n    else {pp->right = child;}\n}","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"关于二叉树简单、取巧的方法：单纯将要删除的节点标记为「已删除」，并不真正从树中将这个节点删除。虽然比较浪费内存，但是在不增加插入、查找操作代码实现难度的条件下，使得删除操作变简单。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"二叉查找树的其他操作：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"查找最大最小节点、前驱节点和后继节点。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度 mathcalO(n)，二叉查找树也叫二叉排序树。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"支持重复数据的二叉查找树：","category":"page"},{"location":"leetcode/data_structure/#Trie-树","page":"-","title":"Trie 树","text":"","category":"section"},{"location":"leetcode/data_structure/#B-树","page":"-","title":"B+ 树","text":"","category":"section"},{"location":"leetcode/data_structure/#红黑树","page":"-","title":"红黑树","text":"","category":"section"},{"location":"leetcode/data_structure/#堆","page":"-","title":"堆","text":"","category":"section"},{"location":"leetcode/data_structure/#图（Graph）","page":"-","title":"图（Graph）","text":"","category":"section"},{"location":"leetcode/data_structure/#图的表示","page":"-","title":"图的表示","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"图有两种主要存储方式：邻接表和邻接矩阵。图的代码实现：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"class Graph { // 无向图\nprivate:\n    int v;    // 顶点的个数\n    LinkedList* adj[];  // 邻接表\n    \npublic:\n    void Graph(int v) {\n        this->v = v;\n        adj = new LinkedList(v);\n        for (int i = 0; i < v; ++i) {\n            adj[i] = new LinkedList();\n        }\n    }\n    \n    void addEdge(int s, int t) {  // 无向图一条边存两次\n        adj[s].add(t);\n        adj[t].add(s);\n    }\n}","category":"page"},{"location":"leetcode/data_structure/#位图","page":"-","title":"位图","text":"","category":"section"},{"location":"leetcode/data_structure/#常用函数","page":"-","title":"常用函数","text":"","category":"section"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"__builtin_popcount()：返回输入数据，二进制中「1」的个数，只对 int 类型；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"如果想要对 long int 和 long long 类型使用，可以分别用 __builtin_popcountl() 和 __builtin_popcountll","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"lower_bound(ForwardIterator first, ForwardIterator last, const T& val)：返回一个迭代指针，该指针指向在 [first, last) 中不小于 val 的第一个元素。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"isalpha(c)：判断 c 是否为一个字母。","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"大小写转换：tolower(c)：将字母转为小写字母；toupper(c)：将字母转为大写字母；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"to_string(c)：将 c 转化为字符；","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"排序：","category":"page"},{"location":"leetcode/data_structure/","page":"-","title":"-","text":"对一个数组排序：sort(nums.begin(), nums.end())；","category":"page"},{"location":"#Docs","page":"Home","title":"9Docs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"我是强劲九（strongnine），9Docs 是我的个人笔记文档，有问题也可以和我联系或者交流，微信「strongnine」，希望可以点击这里给这个文档一个 Star！","category":"page"},{"location":"#目录","page":"Home","title":"目录","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"数据结构与算法：\n机器学习：\n深度学习；\n图神经网络；\n产品思维：\n产品经理；\n个人学习资料的总结和推荐：\n书籍推荐；\n课程推荐；","category":"page"},{"location":"","page":"Home","title":"Home","text":"以下是我在不同平台的账号，欢迎关注：","category":"page"},{"location":"","page":"Home","title":"Home","text":"GitHub：strongnine；","category":"page"},{"location":"","page":"Home","title":"Home","text":"公众号：strongnine；","category":"page"},{"location":"","page":"Home","title":"Home","text":"CSDN：strongnine；","category":"page"},{"location":"#代表文章","page":"Home","title":"代表文章","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"将一维时间序列转化成二维图片；\nPython：使用 pyts 把一维时间序列转换成二维图片（欢迎给内附的 GitHub 代码点个 Star）；\nLaTeX：公式常用字符和表达式；\n......","category":"page"},{"location":"#Julia-Documenter.jl-的使用","page":"Home","title":"Julia Documenter.jl 的使用","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"把修改 push 到仓库之前，可以先在本地看看能不能编译成功：","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia docs/make.jl 没有报错就编译成功；编译成功会在 docs 目录里面出现一个 build 文件；\npython3 -m http.server --bind localhost 可以开启一个本地的网页服务器（部署在本地）；\n打开 http://[::1]:8000/docs/build/ 可以访问，看看效果；","category":"page"},{"location":"product/product_manager/#产品经理","page":"产品思维","title":"产品经理","text":"","category":"section"},{"location":"product/product_manager/#产品经理如何与开发打交道","page":"产品思维","title":"产品经理如何与开发打交道","text":"","category":"section"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"是什么原因导致了产品经理与开发的对立？","category":"page"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"面对产品或者特性时，产品经理和开发脑子里面的额东西是不同的；\n产品经理：考虑客户、市场、盈利、竞争优势、政策风险、获客，最后的产出可能是 PRD，对产品功能需求的描述；\n开发：会关注是不是遗留系统、系统架构有没有限制、公司的技术栈是什么样的、整个链路架构有没有问题、需不需要重构；","category":"page"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"产品经理应该如何与开发打交道：","category":"page"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"专程交代业务规划和产品价值。对于产品经理来说，一定要专程交代产品价值，而不只在需求评审和需求沟通的时候才去介绍产品的来龙去脉；\n掌握技术概念和技术语言。看代码是一个效率不高但是非常扎实的办法；\n全流程参与。当某个业务有苗头的时候，就开始跟工程师交流，但不正式地提需求；【产品经理与工程师要都参与整个开发流程，知道目前的进度，但是只是知道就好，各自的部分相互不影响。】\n多听工程师的意见。工程师的角度提出来的想法有时候会非常有价值。可以让工程师和产品经理轮番做项目经理；\n不要强迫工程师做评估。不要去说工程师做的某个功能很容易做；\n背黑锅与争取利益。背黑锅是产品经理的天职，要勇敢地、毫不犹豫地在第一时间站出来帮工程师承担责任；要帮工程师争取利益，因为产品经理有渠道跟技术主管有更多的接触；\n互背 KPI，同仇敌忾。产品经理的 KPI 一般是产品指标、业务指标，而工程师是可用性、特性交付等；\n建立良好的个人关系；","category":"page"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"用户「精卫鸟」的留言：敢承认自己的错误。需求变更时不把自己摆在道德高点，别拿用户和体验当幌子，实事求是；\n要有担当。永远不和开发说这个需求自己也不想做，都是老大们让做；或者说这个功能不是我要的，是业务部分要的。开发只会觉得自己没有担当，而不是理解你的无奈。原则上不能守护好产品特性的产品经理，与不能守护好代码完整性的开发，都是很难获得尊敬的。","category":"page"},{"location":"product/product_manager/#参考","page":"产品思维","title":"参考","text":"","category":"section"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"[1] 《邱岳的产品手记》邱岳 | 极客时间","category":"page"},{"location":"product/product_manager/","page":"产品思维","title":"产品思维","text":"[2] 《邱岳的产品实战》邱岳 | 极客时间","category":"page"}]
}
