<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · 9Docs</title><meta name="title" content="- · 9Docs"/><meta property="og:title" content="- · 9Docs"/><meta property="twitter:title" content="- · 9Docs"/><meta name="description" content="Documentation for 9Docs."/><meta property="og:description" content="Documentation for 9Docs."/><meta property="twitter:description" content="Documentation for 9Docs."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">9Docs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">深度学习</span><ul><li><a class="tocitem" href="../DL/CNN/">卷积神经网络</a></li><li><a class="tocitem" href="../DL/stereo/">立体匹配</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/strongnine/9Docs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/strongnine/9Docs/blob/main/docs/src/SLAM.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>[TOC]</p><h2 id="数学基础"><a class="docs-heading-anchor" href="#数学基础">数学基础</a><a id="数学基础-1"></a><a class="docs-heading-anchor-permalink" href="#数学基础" title="Permalink"></a></h2><h3 id="李群与李代数"><a class="docs-heading-anchor" href="#李群与李代数">李群与李代数</a><a id="李群与李代数-1"></a><a class="docs-heading-anchor-permalink" href="#李群与李代数" title="Permalink"></a></h3><p>在 SLAM 中位姿是未知的，需要解决「什么样的相机位姿最符合当前观测数据」的问题。典型方法：构建成一个优化问题，求解最优的 <span>$R, t$</span>，使得误差最小化。但旋转矩阵自身带有约束，例如正交且行列式为 1，做为优化变量时，会引入额外的约束，使得优化变得困难。</p><p><strong>通过李群 — 李代数间的转换关系，可以把位姿估计变成无约束的优化问题，简化求解方式。</strong></p><h4 id="李群"><a class="docs-heading-anchor" href="#李群">李群</a><a id="李群-1"></a><a class="docs-heading-anchor-permalink" href="#李群" title="Permalink"></a></h4><p>三维旋转矩阵构成了特殊正交群 <span>$\text{SO}(3)$</span>： $ \text{SO}(3) = {R\in \mathbb{R}^{3\times 3} \mid RR^T=I,\text{det}(R)=1} $ 变换矩阵构成了特殊欧式群 <span>$\text{SE}(3)$</span>： $ \text{SE}(3)=\left{ T = \begin{bmatrix}   R &amp; t \   0^T &amp; 1 \
\end{bmatrix} \in \mathbb{R}^{4 \times 4} \mid R \in \text{SO}(3), t\in\mathbb{R}^3 \right} $ 旋转矩阵和变换矩阵对加法不封闭。具体来说，对于任意两个旋转矩阵，做加法之后不再是一个旋转矩阵。 $ R<em>1 + R</em>2 \not\in \text{SO}(3), T<em>1 + T</em>2 \not\in \text{SE}(3) $ 而对于乘法是封闭的： $ R<em>1R</em>2\in \text{SO(3)}, T<em>1T</em>2 \in \text{SE}(3) $ 群：就是对于只有一个（良好的）运算的集合的称呼。是一种集合加上一种运算的代数结构。</p><p>李群：是指具有连续（光滑）性质的群。<span>$\text{SO}(3)$</span> 和 <span>$\text{SE}(3)$</span> 就是在实数空间上连续的。</p><h4 id="李代数"><a class="docs-heading-anchor" href="#李代数">李代数</a><a id="李代数-1"></a><a class="docs-heading-anchor-permalink" href="#李代数" title="Permalink"></a></h4><p>一个向量 <span>$a$</span> 对应的反对称矩阵 <span>$A$</span> 有如下关系：</p><p>$</p><p>a^\land = A = \begin{bmatrix}    0  &amp; -a<em>3 &amp;  a</em>2 \   a<em>3 &amp;   0  &amp; -a</em>1 \  -a<em>2 &amp;  a</em>1 &amp;   0  \  \end{bmatrix},  A^\lor = a $</p><p>对于任意时刻下的旋转矩阵有：</p><p>$</p><p>R(t){R(t)}^T = I $</p><p>两边对时间求导得到：</p><p>$</p><p>\dot{R}(t) {R(t)}^T + R(t){\dot{R}(t)}^T = 0 \
\dot{R}(t) {R(t)}^T = -\left( \dot{R}(t) {R(t)}^T \right)^T $</p><p>可以看出 <span>$\dot{R}(t) {R(t)}^T$</span> 是一个反对称矩阵，因此可以找到一个三维向量 <span>$\phi(t)\in\mathbb{R}^3$</span> 与之对应：</p><p>$</p><p>\dot{R}(t) {R(t)}^T = \phi(t)^\land $</p><p>$</p><p>\dot{R}(t) = \phi(t)^\land R(t) = \begin{bmatrix}      0   &amp; -\phi<em>3 &amp;  \phi</em>2 \   \phi<em>3 &amp;     0   &amp; -\phi</em>1 \  -\phi<em>2 &amp;  \phi</em>1 &amp;     0   \  \end{bmatrix} R(t) $</p><p><strong>因此，每对旋转矩阵求一次导数，只需要左乘一个 <span>$\phi(t)^\land$</span> 即可。</strong>设 <span>$t_0 = 0$</span> 时，旋转矩阵为 <span>$R(0) = I$</span>。把 <span>$R(t)$</span> 在 <span>$t = 0$</span> 附近进行一阶泰勒展开： $ \begin{aligned} R(t) &amp; \approx R(t<em>0) + \dot{R}(t</em>0)(t - t<em>0) \
     &amp; = I + t \cdot \phi(t</em>0)^\land \end{aligned} $ <span>$\phi$</span> 反映了 <span>$R$</span> 的导数性质，称它在 <span>$\text{SO}(3)$</span> 原点附近的正切空间（Tangent Space）。设在 <span>$t_0$</span> 附近，<span>$\phi(t_0)=\phi_0$</span>， $ \dot{R}(t) = \phi(t<em>0)^\land R(t) = \phi</em>0^\land R(t) $ 这是关于 <span>$R$</span> 的微分方程，初始值 <span>$R(0)=I$</span>，解得 <span>$R(t)=\exp(\phi_0^\land t)$</span>。</p><ol><li>给定某时刻的 <span>$R$</span>，就能求得一个 <span>$\phi$</span>，它描述了 <span>$R$</span> 在局部的导数关系。<span>$\phi$</span> 就是对应到 <span>$\text{SO}(3)$</span> 上的李代数 <span>$\mathfrak{so}(3)$</span>。</li><li>给定某个向量 <span>$\phi$</span>，计算矩阵指数 <span>$\exp(\phi^\land)$</span>，以及给定 <span>$R$</span> 时，用相反的运算来计算 <span>$\phi$</span>，对应的就是李群与李代数的指数/对数映射。</li></ol><p>（可以认为 <span>$R = \exp{(\phi^\land)}$</span>）。</p><p class="math-container">\[\text{SO}(3)\]</p><p>与 <span>$\text{SE}(3)$</span> 的李代数分别为： $ \mathfrak{so}(3) = \left{ \phi \in \mathbb{R}^3, \Phi=\phi^\land \in \mathbb{R}^{3\times 3} \right} $</p><p>$</p><p>\mathfrak{se}(3) = \left{  \xi =  \begin{bmatrix}  \rho \ \phi  \end{bmatrix} \in \mathbb{R}^6,  \rho\in\mathbb{R}^3, \phi\in\mathfrak{so}(3), \xi^\land= \begin{bmatrix}  \phi^\land &amp; \rho \  0^T    &amp;  0   \end{bmatrix} \in \mathbb{R}^{4 \times 4} \right} $</p><p>需要注意 <span>$\mathfrak{se}(3)$</span> 中的 <span>$\land$</span> 符号不再表示反对称，但可以理解为从向量到矩阵的转换。</p><h4 id="指数与对数映射"><a class="docs-heading-anchor" href="#指数与对数映射">指数与对数映射</a><a id="指数与对数映射-1"></a><a class="docs-heading-anchor-permalink" href="#指数与对数映射" title="Permalink"></a></h4><p>当前的问题是：如何计算 <span>$\exp(\phi^\land)$</span>？</p><p class="math-container">\[\phi\]</p><p>是三维向量，定义它的模长和方向分别为 <span>$\theta$</span> 和 <span>$a$</span>，于是 <span>$\phi=\theta a$</span>，<span>$a$</span> 为长度为 1 的方向向量，<span>$\|a \| = 1$</span>。对于 <span>$a$</span> 有如下公式 $ a^\land a^\land = \begin{bmatrix}  -a^2<em>2-a</em>3^2  &amp; a<em>1a</em>2 &amp;  a<em>1a</em>3 \   a<em>1a</em>2 &amp; -a<em>1^2-a</em>3^2  &amp; a<em>2a</em>3 \  a<em>1a</em>3 &amp;  a<em>2a</em>3 &amp; -a<em>1^2-a</em>2^2  \  \end{bmatrix} = aa^T - I $</p><p>$</p><p>a^\land a^\land a^\land = a^\land(aa^T - I) = -a^\land $</p><p>因此通过一系列的推导（比较复杂，直接记公式）可以得到： $ \begin{aligned} \exp(\phi^\land) &amp; = \exp(\theta a^\land) = \sum_{n=0}^\infty \frac{1}{n!}(\theta a^\land)^n \
&amp; = \cos{\theta}I + (1 - \cos{\theta})aa^T + \sin{\theta}a^\land \end{aligned} $ 这个公式与罗德里格斯公式如出一辙，表明 <span>$\mathfrak{so}(3)$</span> 实际上就是由所谓的旋转向量组成的空间。</p><p class="math-container">\[\mathfrak{se}(3)\]</p><p>上的指数映射形式如下： $ \begin{aligned} \exp(\xi^\land) &amp;= \begin{bmatrix} \sum<em>{n=0}^\infty \frac{1}{n!}(\phi^\land)^n &amp; \sum</em>{n=0}^\infty \frac{1}{(n+1)!}(\phi^\land)^n\rho \
0^T  &amp; 1 \end{bmatrix} \
&amp;\triangleq \begin{bmatrix} \exp{(\phi^\land)} &amp; J\rho \
0^T  &amp; 1 \end{bmatrix} \end{aligned} $ 同样通过（复杂的）推导，可以求得： $ J = \frac{\sin{\theta}}{\theta}I + (1 - \frac{\sin{\theta}}{\theta})aa^T + \frac{1-\cos{\theta}}{\theta}a^\land $</p><h4 id="公式总结"><a class="docs-heading-anchor" href="#公式总结">公式总结</a><a id="公式总结-1"></a><a class="docs-heading-anchor-permalink" href="#公式总结" title="Permalink"></a></h4><p>对于李群 <span>$\text{SO}(3)$</span>，指数映射为： $ \exp(\phi^\land) = \exp(\theta a^\land) = \cos{\theta}I + (1 - \cos{\theta})aa^T + \sin{\theta}a^\land $ 对于李代数 <span>$\mathfrak{so}(3)$</span>，对数映射为： $ \theta = \arccos{\frac{\tr(R) - 1}{2}}, Ra=a $ 对于李群 <span>$\text{SE}(3)$</span>，指数映射为： $ \exp(\xi^\land) = \begin{bmatrix} \exp{(\phi^\land)} &amp; J\rho \
0^T  &amp; 1 \end{bmatrix} $ 其中： $ J = \frac{\sin{\theta}}{\theta}I + (1 - \frac{\sin{\theta}}{\theta})aa^T + \frac{1-\cos{\theta}}{\theta}a^\land $ 对于李代数 <span>$\mathfrak{se}(3)$</span>，对数映射为： $ \theta = \arccos{\frac{\tr(R) - 1}{2}}, Ra=a, t=J\rho $</p><h4 id="BCH-公式与近似形式"><a class="docs-heading-anchor" href="#BCH-公式与近似形式">BCH 公式与近似形式</a><a id="BCH-公式与近似形式-1"></a><a class="docs-heading-anchor-permalink" href="#BCH-公式与近似形式" title="Permalink"></a></h4><h4 id="李群李代数的实际应用"><a class="docs-heading-anchor" href="#李群李代数的实际应用">李群李代数的实际应用</a><a id="李群李代数的实际应用-1"></a><a class="docs-heading-anchor-permalink" href="#李群李代数的实际应用" title="Permalink"></a></h4><p>在 SLAM 中，需要估计一个相机的位姿，该位姿由 <span>$\text{SO}(3)$</span> 上的旋转矩阵，或者 <span>$\text{SE}(3)$</span> 上的变幻矩阵描述。假设某个时刻相机位姿为 <span>$T$</span>，相机观察到一个世界坐标位于 <span>$p$</span> 的点，考虑上随机噪声 <span>$w$</span>，就能够得到观测值 <span>$z$</span> 为： $ z = Tp + w $ 理想的观测与实际数据的误差为： $ e = z - Tp $ 观测到 <span>$N$</span> 个这样的路标点，就会产生 <span>$N$</span> 个误差值，而想要估计位姿，就相当于寻找一个最优的 <span>$T$</span>，使得整体误差最小： $ \min<em>{T} J(T) = \sum</em>{i=1}^N \|z<em>i - Tp</em>i \|_2^2 $ 求解思路有两种：</p><ol><li>用李代数表示姿态，根据李代数加法对李代数求导。（比较复杂）</li><li>对李群左乘或右乘微小扰动，然后对该扰动求导，也即左扰动和右扰动模型。（有更加简单的导数计算方式）</li></ol><h3 id="非线性优化"><a class="docs-heading-anchor" href="#非线性优化">非线性优化</a><a id="非线性优化-1"></a><a class="docs-heading-anchor-permalink" href="#非线性优化" title="Permalink"></a></h3><h4 id="状态估计"><a class="docs-heading-anchor" href="#状态估计">状态估计</a><a id="状态估计-1"></a><a class="docs-heading-anchor-permalink" href="#状态估计" title="Permalink"></a></h4><p>经典 SLAM 模型由一个运动方程和一个观测方程构成： $ \begin{cases} x<em>k = f(x</em>{k-1}, u<em>k) + w</em>k \
z<em>{k,j} = h(y</em>j, x<em>k) + v</em>{k, j} \end{cases} $ 噪声满足高斯分布 <span>$w_k \sim \mathcal{N}(0, R_{k}), v_k \sim \mathcal{N}(0, Q_{k,j})$</span>，均值为 0，<span>$R_k, Q_{k,j}$</span> 为协方差矩阵。其中 <span>$x_k$</span> 是相机位姿，可用 <span>$\text{SE}(3)$</span> 来描述。假设在 <span>$x_k$</span> 处对路标 <span>$y_j$</span> 进行了一次观测，对应到图像上的像素位置为 <span>$z_{k, j}$</span>，那么观测方程可以表示为： $ sz<em>{k,j} = K(R</em>k y<em>j + t</em>k) $ 其中 <span>$K$</span> 为相机内参，<span>$s$</span> 为像素点的距离，也是 <span>$R_ky_j + t_k$</span> 的第三个分量。</p><p>希望通过带噪声的数据 <span>$z$</span> 和 <span>$u$</span> 推断位姿 <span>$x$</span> 和地图 <span>$y$</span>，以及它们的概率分布，这构成了一个状态估计问题。有两种处理方法：</p><ol><li>持有一个当前时刻的估计状态，然后用新的数据来更新，称为增量/渐进（incremental）的方法，或者叫滤波器。仅关心当前时刻的状态估计 <span>$x_k$</span>，对之前的状态不多考虑。</li><li>把数据合并起来处理，称为批量（batch）的方法。这种方法可以在更大的范围达到最优化，是当前视觉 SLAM 的主流方法。极端情况下，可以让机器人或无人机收集所有时刻的数据，再带回计算中心统一处理，这种方式是 SfM（Structure from Motion）的主流做法。</li></ol><p>定义所有时刻的机器人位姿和路标点坐标： $ x = {x<em>1, \dots, x</em>N }, y = { y<em>1, \dots, y</em>M } $ 所有时刻的输入为 <span>$u$</span>，所有时刻的观测数据为 <span>$z$</span>。对机器人状态的估计，从概率学的观点来看，就是已知输入数据和观测数据，求状态 <span>$x,y$</span> 的条件概率分布 <span>$P(x,y\mid z,u)$</span>。当不知道控制输入，只有一张张的图像时，相当于估计 <span>$P(x,y\mid z)$</span> 的条件概率分布，此问题也称为 SfM，即如何从许多图像中重建三维空间结构。利用贝叶斯法则：</p><p>$</p><p>\underbrace{P(x,y\mid z,u)}<em>{后验} = \frac{P(z,u \mid x,y)P(x,y)}{P(z,u)} \propto \underbrace{P(z,u\mid x,y)}</em>{似然} \underbrace{P(x,y)}_{先验} $</p><p>直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下后验概率最大化，则是可行的： $ (x,y)^<em>_{\text{MAP}} = \arg \max P(x,y\mid z,u)  = \arg\max P(z,u\mid x,y)P(x,y) $ 求解最大后验概率等价于最大化似然（Likehood）和先验（Prior）的乘积。如果不知道机器人位姿或路标大概在什么地方，也即没有了先验，那么可以求解最大似然估计（Maximize Likehood estimation, MLE）： $ (x,y)^</em>_{\text{MLE}} = \arg\max P(z,u\mid x,y) $ <strong>直观解释：似然是指：在现在的位姿下，可能产生怎样的观测数据。最大似然估计指：在什么样的状态下，最可能产生现在观测到的数据。</strong></p><p>如何求最大似然估计？对于某一次观测： $ z<em>{k,j} = h(y</em>j, x<em>k) + \underbrace{v</em>{k,j}}<em>{噪声}, \quad v</em>k \sim \mathcal{N}(0, Q<em>{k,j}) $ 观测数据的条件概率依然是一个高斯分布： $ P(z</em>{j,k}\mid x<em>k, y</em>j) = \mathcal{N}(h(y<em>j, x</em>k), Q<em>{k,j}) $ 任意高维高斯分布 <span>$x\sim \mathcal{N}(\mu, \Sigma)$</span>，其概率密度函数展开形式为： $ P(x) = \frac{1}{\sqrt{(2\pi)^N\det(\Sigma)}}\exp\left( -\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right) $ 对其取负对数，变为： $ -\ln(P(x)) = \underbrace{\frac{1}{2}\ln\left( (2\pi)^N\det(\Sigma)\right)}</em>{与 x 无关，可略去}             +\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu) $ 因此，求状态的最大似然估计，只需要最小化右侧的二次型项： $ \begin{aligned} (x<em>k,y</em>j)^* &amp;= \arg\max \mathcal{N}(h(y<em>j,x</em>k), Q<em>{k,j}) \
 &amp; = \arg\min \left( (z</em>{k,j}-h(x<em>k, y</em>j))^T Q^{-1}<em>{k,j} (z</em>{k,j}-h(x<em>k, y</em>j)) \right) \end{aligned} $ 该式等价于最小化噪声项（误差）的一个二次型，这个二次型称为马哈拉诺比斯距离（Mahalanobis distance），又叫马氏距离。可以看成由信息矩阵 <span>$Q_{k,j}^{-1}$</span> 加权之后的欧氏距离。</p><p>假设各个时刻的输入和观测是相互独立的，可以对联合分布进行因式分解： $ P(z,u\mid x,y) = \prod<em>k P(u</em>k\mid x<em>{k-1}, x</em>k)\prod<em>{k,j}P(z</em>{k,j}\mid x<em>k, y</em>j) $ 定义各次输入和观测数据与模型之间的误差： $ \begin{aligned} e<em>{u,k} &amp;= x</em>k - f(x<em>{k-1}, u</em>k) &amp; = w<em>k &amp; \sim \mathcal{N}(0, R</em>{k}) \
e<em>{z,j,k} &amp;= z</em>{k,j} - h(x<em>k, y</em>j) &amp; = v<em>{k,j} &amp; \sim \mathcal{N}(0, Q</em>{k,j})  \end{aligned} $ 最小化所有时刻估计值与真实读数之间的马氏距离，等价于求最大似然估计： $ \min J(x,y) = \sum<em>k e</em>{u,k}^T R<em>k^{-1}e</em>{u,k} </p><ul><li>\sum<em>k\sum</em>j e<em>{z,j,k}^T Q</em>{k,j}^{-1}e_{z,k,j}</li></ul><p>$</p><p>据此得到一个最小二乘问题（Least Square Problem），其解等价于状态的最大似然估计。</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 14:26">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
