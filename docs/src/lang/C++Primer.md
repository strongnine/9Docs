C++ 的最小学习包：

- 运算符；
- 基本语法；
- 关键字；
- 常用类型、容器、标准库类型：字符串、向量、数组
- 类与函数：
- 指针与引用：
- 模板与泛型：

## 运算符

P.147｜运算符优先级表，总结了全部的运算符和它们之间的优先级。

作用域操作符 `::`：告诉编译器应该从操作符 `::` 左边名字所示的作用域中寻找右侧的名字。

## 语法

### 循环语句

#### 范围 for 语句

lambda 表达式：

## 关键字

`constexpr`

`auto`

`decltype`

## 常用类型

### 引用

P.45｜引用（reference）分为左值引用（lvalue reference）和右值引用（rvalue reference）。引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。使用方法为 `&refername`，其中 `refername` 是声明的变量名，`&` 是取地址运算符。

1. 引用必须被初始化。一旦初始化完成，引用将会和它的初始值对象绑定在一起。
2. 无法令引用重新绑定到另外一个对象。
3. 引用本身不是一个对象，不能够定义引用的引用。
4. 所有引用的类型都要和与之绑定的对象严格匹配。
5. 引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。

> ❗️注意：对于第  4 条，有两个例外：（1）const  的引用和（2）基类对派生类的引用。

P.55｜const  的引用：又称为**对常量的引用（reference to const）**，也可以简称为**常量引用**。

1. 对常量的引用不能够用于修改所绑定的对象。
2. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可。
3. 允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式。
4. 非常量引用不可以指向常量对象，常量引用可以指向非常量对象。
5. 常量引用只对引用可参与的操作做出了限定，对于引用的对象本身是否为一个常量并未做出限定。

> 对于第  4 条：假设变量 `ci` 是一个常量对象 `const int ci = 1024`，那么用一个非常量引用 `r2` 绑定到 `ci` 上（即 `int &r2 = ci`）是非法的。假设 `i` 是一个非常量对象 `int i = 42`，那么用一个常量引用 `r1` 绑定到 `i` 上（即 `const int &r1 = i`）是可以的。

P.55｜**临时量（temporary）**：临时量对象就是当编译器需要在一个空间来暂存表达式的求值结果时创建的一个未命名的对象。

❓当一个常量引用被绑定到不同的一种类型时，编译器会做什么？

下列的代码尝试将一个 `int` 型的常量引用绑定到 `double` 型的：

```c++
double dval = 3.14;
const int &ri = dval;
```

答：实际上编译器会将 `double` 型转换为一个 `int` 型的临时量：

```c++
const int temp = dval;  // 又双精度浮点数生成一个临时的整型常量
const int &ri = temp;
```

P.534｜基类引用绑定派生对象：存在继承关系的类中，可以将基类的引用绑定到派生类对象中。

### 指针

P.47｜**指针（pointer）**是「指向」另外一种类型的复合类型。

1. 指针本身就是一个对象，允许对指针赋值和拷贝。 
2. 指针在其生命周期内可以先后指向几个不同的对象。
3. 指针无须在定义时赋初值，如果在块作用域内没有被初始化，会拥有一个不确定的值。
4. 指针的类型必须与其所指定对象的类型一致。

> ❗️注意：对于第  4 条，有两个例外：（1）允许指向常量的指针指向一个非常量对象和（2）。

P.56｜指向常量的指针（pointer to const）不能用于改变其所指向的对象。要想存放常量对象的地址，只能用指向常量的指针。其用法是 `const double *cptr = &pi`，其中 `const` 表明改指针是指向常量的指针。

1. 指向常量的指针可以指向非常量对象。
2. 指向常量的指针仅仅要求不能通过指针改变对象的值，没有规定那个对象的值不能通过其它途径改变。

P.56  常量指针（const pointer）：指针本身是一个常量，也就是它所指向的地址永远不会变。其用法为 `*const` 代表指针是一个常量。

1. 常量指针必须初始化，一旦初始化完成，它的值（也就是存放在指针中的那个地址），就不能再改变。

> 注意区分：
>
> |       指针类型       | 地址是否可变 | 对象是否可变 |
> | :------------------: | :----------: | :----------: |
> | 指向非常量的一般指针 |      ✅       |      ✅       |
> |  指向常量的一般指针  |      ✅       |      ❌       |
> | 指向非常量的常量指针 |      ❌       |      ✅       |
> |  指向常量的常量指针  |      ❌       |      ❌       |

❓有很多的变量声明，应该用什么方法去搞清楚不同的声明呢？

答：最好的方法就是对于变量声明部分，从右往左读，例如：

```c++
const double *cptr = &pi;  // cptr 是一个指针，指向双精度常量
int *const curErr = &errNumb;  // curErr 是一个常量指针，指向 int  型
const double *const pip = &pi;  // pip 是一个常量指针，指向双精度浮点型常量
```

P.400｜动态内存的管理：在 C++ 中动态内存的管理通过一对运算符 `new` 和 `delete` 来进行：

- `new` 在动态内存中为对象分配空间并返回一个指向该对象的指针；
- `delete` 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存；

❓动态内存的使用容易碰到什么问题？

- 忘记释放内存，产生内存泄露。
- 在尚有指针引用内存的情况下就释放了指针，产生引用非法内存的指针。

P.400｜智能指针：其行为类似常规指针，重要的区别是智能指针负责自动释放所指向的对象。

❓智能指针是否是线程安全的？

### 数组

#### 多维数组

严格来说，C++ 没有多维数组，通常所说的多维数组其实是数组和数组。

```c++
int ia[3][4];
int arr[10][20][30];

// int ia[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
}
```

用两层嵌套的 for 循环来处理多维数组的元素：

```c++
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];
for (size_t i = 0; i != rowCnt; ++i) {
    for (size_t j = 0; j != colCnt; ++j) {
        ia[i][j] = i * colCnt + j;
    }
}
```

如果使用范围 for 语句来迭代：

```c++
size_t cnt = 0;
for (auto &row : ia) {
    for (auto &col : row) {
        col = cnt;
        cnt++;
    }
}
```

❓请思考一下为什么下面的语句（没有对 `row` 指定为引用），会编译报错？

```c++
for (auto row : ia) {
    for (auto col : row) {
        // ...
    }
}
```

> P.114 要使用范围 for 语句处理多位数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

❓说一下下面不同声明代表的意思。

```c++
int *ip[4];
int (*ip)[4];
```

`int *ip[4]`：代表整型指针的数组；

`int (*ip)[4]`：代表指向含有  4  个整型的数组；

### 哈希

`map`

`unordered_map`

## 类与函数

分离式编译（Separate Compilation）：允许把程序分割到几个文件中去，每个文件独立编译。

### 继承

## 其它概念

左值

右值

内存管理

---

参考资料

[1]《C++ Primer》[美] Staley B. Lippman, Josee Lajoie, Barbara E. Moo. 