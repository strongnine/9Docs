## 经典系列问题

### 背包问题

### 股票问题

股票问题是学习动态规划很好的系列，因此一下最先考虑的都是用动态规划怎么做。

【输入】`prices` 表示每一天的股票的价格，长度为 `n`，根据不同题目会有额外的参数，包括最多交易 `k` 次，冷冻期，手续费 `fee`。

【输出】能够获得的最大利润。

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)【简单题】：只能交易一次。矩阵 `dp[n][2]` 表示第 $i$ 天交易完后的最大利润，其中 `dp[i][0]` 表示未持有股票，`dp[i][1]` 表示持有股票。

$dp[i][0]=\max\{dp[i-1][0], dp[i-1][1]+prices[i]\},$

$dp[i][1]=\max\{dp[i-1][1], -prices[i]\}.$

其中边界条件：`dp[0][0] = 0`，`dp[0][1] = -prices[0]`. 

实际上，`dp[i][1]` 就是在记录过去的天数中最低的价格。这个问题最简单的思路，其实就是记录以往的最低价格，然后用今天的价格出售，动态维护最大值即为答案。

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)【中等题】：能够交易无限次。同样的，矩阵 `dp[n][2]` 表示第 $i$ 天交易完后的最大利润，其中 `dp[i][0]` 表示未持有股票，`dp[i][1]` 表示持有股票。

$dp[i][0]=\max\{dp[i-1][0], dp[i-1][1]+prices[i]\},$

$dp[i][1]=\max\{dp[i-1][1], dp[i-1][0]-prices[i]\}.$

其中边界条件：`dp[0][0] = 0`，`dp[0][1] = -prices[0]`. 最终答案为：`dp[n - 1][0]`. 

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)【中等题】：每笔交易都要支付手续费 `fee`. 同样的方式，只是在卖出的时候要多计算一个手续费

$dp[i][0] = \max\{dp[i - 1][0], dp[i - 1][1] + prices[i] - fee\},$

$dp[i][1] = \max\{dp[i-1][1],dp[i-1][0]-prices[i]\}.$

其中边界条件：`dp[0][0] = 0`，`dp[0][1] = -prices[0]`. 最终答案为：`dp[n - 1][0]`. 

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)【困难题】：最多完成两笔交易。定义 4 个状态，分别是：`buy1` 进行一次买入、`sell1` 进行一次卖出、`buy2` 进行第二次买入、`sell2` 进行第二次卖出。

$buy_1 = \max\{buy_1, -prices[i]\},$

$sell_1=\max\{sell_1, buy_1+prices[i]\},$

$buy_2 = \max\{buy_2, sell_1-prices[i]\},$

$sell_2=\max\{sell_2,buy_2+prices[i]\}.$

其中边界条件：`buy1 = -prices[0]`，`sell1 = 0`，`buy2 = -prices[0]`，`sell2 = 0`，答案就是 `sell2`. 

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)【困难题】：最多只能够完成 `k` 笔交易。定义矩阵 `buy[n][k]` 和 `sell[n][k]` 分别表示第 $i$ 天时处于第 $j$ 笔交易时持有以及未持有股票的最大利润。

$buy[i][j] = \max\{buy[i-1][j],sell[i-1][j-1]-prices[i]\},$

$sell[i][j]=\max\{sell[i-1][j],buy[i-1][j]+prices[i]\}.$

其中边界条件：`buy[0][0...k] = -prices[i]`，`sell[0][0...k] = 0`。当 `j = 0` 时，`buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i])`. 

最终答案为 `sell[n - 1][0...k]` 中的最大值。

> 注意：因为 `n` 天最多只能进行 $\lfloor\frac{n}{2}\rfloor$ 次交易，因此在一开始时可以令 `k = min(k, n // 2)`，如果 `k == 0` 那么答案直接为 0. 

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)【中等题】：冷冻期为 1 天（卖出股票后得隔一天才能买入股票）。矩阵 `dp[n][3]` 存储第 $i$ 天结束时的最大收益，其中 `dp[i][0]` 表示持有一支股票，`dp[i][1]` 表示不持有任何股票并且处于冷冻期，`dp[i][2]` 表示不持有股票并且不处于冷冻期。

$dp[i][0] = \max\{dp[i-1][0], dp[i-1][2] - prices[i]\},$

$dp[i][1] = dp[i-1][0] + prices[i],$

$dp[i][2]=\max\{dp[i-1][1],dp[i-1][2]\}.$

其中边界条件：`dp[0][0] = -prices[0]`，`dp[0][1] = 0`， `dp[0][2] = 0`. 最终答案为 `max(dp[n - 1][1], dp[n - 1][2])`. 

### 岛屿问题

岛屿问题是学习深度优先搜索（DFS）和广度优先搜索（BFS）的经典系列问题。

【输入】`grid` 是一个 $M$ 行 $N$ 列的矩阵，其中 1 代表陆地，0 代表海洋。

【输出】不同的问题有不同的要求，例如岛屿数量、岛屿周长、岛屿面积等

[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)【简单题】：计算岛屿数量。

DFS：扫描网格，碰到某个位置为 1，以其为起始节点开始进行深度优先搜索。将每个碰到的 1 都变成 0，避免重复搜索。最终的答案就是进行 DFS 的次数。

BFS：扫描网格，如果某个位置为 1，将其加入队列，开始 BFS，没搜索到的 1 都重新标记为 0，直到队列为空。最终的答案就是进行 BFS 的次数。

[305. 岛屿数量 II](https://leetcode.cn/problems/number-of-islands-ii/)【困难题】：最初全部为海洋，`positions[i] = [ri, ci]` 记录的是每次添加的陆地位置，要求返回 `answer` 记录每次将 `[ri, ci]` 变成陆地后地图中的岛屿数量。

> 这个问题在题解里只找到并查集的解法。

并查集：

[463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)【简单题】：`grid` 中只有一个岛屿，且岛屿中没有湖，要求返回这个岛屿的周长。

DFS：扫描网格，碰到第一个为 1 的位置，开始搜索，如果碰到海洋或者边界，则周长加 1，否则继续搜索。通过将 `grid[x][y]` 添加到集合中或者重新标记为 2 来避免重复搜索。

BFS：扫描网格，碰到第一个为 1 的位置，将其加入队列并开始搜索，如果碰到海洋或者边界，则周长加 1，搜索到的位置添加到已遍历集合中或者标记为 2，直到队列为空。

[694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/)【中等题】：返回 `grid` 中有多少种不同形状的岛屿。相同形状的岛屿指的是可以通过平移与另一个岛屿重合（不可旋转、翻转）。

[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)【中等题】：返回 `grid` 中最大岛屿的面积。

DFS：扫描网格，碰到某个位置为 1，开始 DFS，将每个碰到的 1 都重新标志为 0，并且面积加 1，遍历完之后动态维护全局最大面积。

BFS：扫描网格，碰到某个位置为 1，加入队列，开始 BFS，将每个碰到的 1 都重新标志为 0，并且面积加 1，直到队列为空。

序列化遍历顺序：用 `[1, 2, 3, 4]` 分别代表上下左右四个方向的进口，出口则分别对应 `[-1, -2, -3, -4]`，这样遍历完一个岛屿，就能够得到一个序列，将这个序列保存到一个集合中。最终的答案就是集合中不同种序列的数量。

[1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)【中等题】：定义「岛」是由最大的 4 个方向连通的陆地组成的群；「封闭岛」是一个 完全由海洋包围的岛。题目要求返回封闭岛屿的数量。

> 这道题目中陆地和海洋的标志互换了，这里还是依照 1 代表陆地，0 代表海洋来讨论。

BFS：如果 BFS 中碰到了边界，则不是一个封闭岛。碰到某个位置为 1，加入队列开始 BFS，将碰到的每个 1 都重新标志为 0，如果碰到了边界，则记录该陆地不是封闭岛，不断重复直到队列为空。如果该陆地为封闭岛则数量加 1.

[1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)【中等】：有两个同样大小的 `grid1` 和 `grid2`，如果 `grid2` 中的岛屿中每个位置在 `grid1` 中的对应位置都是陆地，那么这个岛屿就称为「子岛屿」，题目要求返回 `grid2` 中子岛屿的数目。

DFS：扫描网格 `grid2`，碰到某个位置为 1，开始搜索，每个 1 都判断在 `grid1` 中是否也为 1，如果不是则记录该岛不是一个子岛屿，然后将遇到的每一个 1 都重新标志为 0. 在遍历完 `grid2` 中的一个岛之后，如果是一个子岛屿，则将子岛屿的数量加 1. 

BFS：扫描网格 `grid2`，碰到某个位置为 1，加入队列开始搜索，每个 1 都判断在 `grid1` 中是否也为 1，如果不是则记录该岛不是一个子岛屿，然后将遇到的每一个 1 都重新标志为 0. 在遍历完 `grid2` 中的一个岛之后，如果是一个子岛屿，则将子岛屿的数量加 1. 



