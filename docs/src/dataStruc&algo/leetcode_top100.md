

## 哈希

[1. 两数之和](https://leetcode.cn/problems/two-sum/description/?favorite=2cktkvj)【简单】

【输入】整数数组 `nums` 和整数目标值 `target`

【输出】和为 `target` 的两个整数在 `nums` 中的下标（输入保证只会有一个答案）

- 建立哈希表 `hashmap`，保存 `target - nums[i]: i`；
- 对于数组中的每一个数字 `x`：
  - 如果 `target - x` 存在于 `hashmap` 中，返回对应的下标以及当前的下标；
  - 否则将当前的键值对加入到 `hashmap` 中；



## 二分

[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/?favorite=2cktkvj)【困难】

【输入】大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`

【输出】这两个数组的中位数

中位数：

- 当 `m + n` 是奇数，中位数是两个有序数组中的第 `(m + n) // 2` 个元素；
- 当 `m + n` 是偶数，中位数是第 `(m + n) // 2` 和第 `(m + n) // 2 + 1` 个元素的平均值；

这道题可以转化成寻找两个有序数组中的第 `k` 小的数，`k` 为 `(m + n) // 2` 和 `(m + n) // 2 + 1`。

对于两个有序数组 `A` 和 `B`，比较 `A[k // 2 - 1]` 和 `B[k // 2 - 1]`，它们前面都只有 `k // 2 - 1` 个元素，因此对于它们中的较小值，最多只会有 `(k // 2 - 1) + (k // 2 - 1) <= k - 2` 个元素比它小，因此 `A[k // 2 - 1]` 和 `B[k // 2 - 1]` 中的最小值以及其前面的数字都不可能是第 `k` 小的数，即不是中位数：

- 如果 `A[k // 2 - 1] <= B[k // 2 - 1]`，那么可以排除 `A[0]` 到 `A[k // 2 - 1]`；
- 如果 `A[k // 2 - 1] > B[k // 2 - 1]`，那么可以排除 `B[0]` 到 `B[k // 2 - 1]`；

我们在排除后的数组上继续进行二分查找，根据排除的个数，减少 `k` 的值，有三种情况要特殊处理：

- 如果 `A[k // 2 - 1]` 或者 `B[k // 2 - 1]` 越界，可以选取对应数组中的最后一个元素。这种情况下，根据排除数的个数减少 `k` 的值，而不是直接将 `k` 减去 `k // 2`；
- 如果一个数组为空，直接返回另一个数组中第 `k` 小的元素；
- 如果 `k = 1` 只需要返回两个数组首元素的最小值就可以；

编写一个函数 `getKthElement(k)` 用于寻找第 `k` 个大小的数：

- `index1` 和 `index2` 是两个数组的偏移指针，代表已经排除了之前的多少个元素，初始化为 0；
- 特殊情况处理：
  - 如果其中一个偏移指针为数组长度，代表这个数组为空，那么返回另一个数组的第 `k` 小的元素（需要注意，`k` 在循环中是会根据已经排除的元素进行减少的）；
  - 如果当前的 `k == 1`，直接返回两个数组首元素的最小值；
- 正常情况：得到指针，如果越界则指向数组最后一个数（用 `min()` 去做）：
  - 得到指针指向的元素 `pivot1` 和 `pivot2`；
  - 如果 `pivot1 <= pivot2`，`k` 减去排除的元素个数，更新数组 `nums1` 的偏移指针 `index1`；
  - 如果 `pivot1 > pivot2`，`k` 减去排除的元素个数，更新数组 `nums2` 的偏移指针 `index2`；

如果 `m + n` 为奇数，使用函数 `getKthElement()` 返回 `(m + n + 1) // 2` 小的数；

如果 `m + n` 为偶数，返回 `(m + n) // 2` 和 `(m + n) // 2 + 1` 两个数的平均值；

## 双指针

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/?favorite=2cktkvj)

【输入】一个字符串 `s`

【输出】不含有重复字符的最长子串的长度

- 右指针 `r` 的初始值为 -1，左指针 `l` 遍历 `[0, n - 1]`；
- 左指针每向右移动一次，哈希集合 `hashset` 中要删除对应的字母；
- 对于左指针的每个位置，判断右指针能到多远，如果下一个字母不存在于 `hashset` 中就可以继续往后走

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/?favorite=2cktkvj)【中等】

【输入】长度为 `n` 的整数数组 `height`，其中每个数可以代表容器壁的高度

【输出】返回最大容器的容量

- 两个指针初始化指向数组的两端；
- 每次判断计算当前的容量，并且同步更新最大容量；
- 每次都把较小值的指针向中间移动；

[15. 三数之和](https://leetcode.cn/problems/3sum/?favorite=2cktkvj)【中等】

【输入】整数数组 `nums`

【输出】返回所有和为 0 且不重复的三元组

- 对数组进行排序；
- 首先选定第一个数字 `a`，并且保证 `a` 与上一次选择的数不一样；
- 之后两个指针 `second` 和 `third`；

## 动态规划

[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/?favorite=2cktkvj)【中等】

【输入】字符串 `s`

【输出】`s` 中的最长回文子串

状态转移方程：

$P(i,j)=P(i + 1, j - 1)\land (S_i==S_j)$

边界条件：

- 长度为 1 的子串一定是回文串 `P(i, i) = True`；
- 长度为 2 的子串，当且仅当两个字符是一样的才为回文串 $P(i, i + 1) = (S_i == S_{i+1})$；



## 深广度优先搜索



## 未分类

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/?favorite=2cktkvj)【中等】

【输入】两个非空链表，按照逆序存储一个非负的整数（保证数字不以 0 开头）

【输出】返回一个链表存储输入的两个数的和
