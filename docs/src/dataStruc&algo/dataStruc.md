## 数组

```c
double * array [8];  // array 是一个数组, 数组的每一个元素是指向双精度实型数据的指针
// double * 为双精度指针类型, 后面的数组为存放双精度指针的数组
```

指针数组 `(* strings [])`：这个变量是一个数组，这个数组的所有元素都是指针类型。32 位系统中，指针占 4 个字节。

数组指针 `((*strings)[])`：这个变量是一个指针，这个指针存放着一个数组的首地址，或者这个指针指向一个数组的首地址。



## 树

二叉树：

- 度：结点所拥有的子树的数目称为该节点的度，叶子结点的度为 0。度数为 0 的结点个数比度数为 2 的结点个数多 1，即 $n_0=n_2+1$. 对于完全二叉树， $n_1$ 为 0 或 1.
- 
- 

二叉搜索树：中序遍历的序列一定是有序的。

满二叉树：结点数 $2^k-1$，$k$ 为深度

哈夫曼树（Huffman Tree）：给定 N 个权值作为 N 个叶子节点，构造一颗二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。

树转换为二叉树：

- 加线：在所有兄弟结点之间加一条连线；
- 抹线：对树中的每一个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；
- 旋转：以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明；

森林转换为二叉树：

- 先把每一棵树转换为二叉树；
- 第一棵二叉树不动，从第二课二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来，不断重复直到所有的二叉树都连接起来；

二叉树转换为树：

- 若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该节点的孩子结点；
- 对每一个结点都用第一个规则进行处理；

二叉树转换为森林：

- 先把每个结点与右孩子结点的连线删除，得到分离的二叉树；
- 把分离后的每颗二叉树转换为树；
- 整理第 2 步得到的树，得到森林；

## 图

拓扑排序：

- 首先选择没有前驱的顶点（入度为 0 的结点），删除与它相关的所有边；
- 继续寻找下一个没有前驱的顶点，删除与它相关的所有边；
- 不断重复这个寻找和删除的步骤。
