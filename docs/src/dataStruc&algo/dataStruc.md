## 数组

```c
double * array [8];  // array 是一个数组, 数组的每一个元素是指向双精度实型数据的指针
// double * 为双精度指针类型, 后面的数组为存放双精度指针的数组
```

指针数组 `(* strings [])`：这个变量是一个数组，这个数组的所有元素都是指针类型。32 位系统中，指针占 4 个字节。

数组指针 `((*strings)[])`：这个变量是一个指针，这个指针存放着一个数组的首地址，或者这个指针指向一个数组的首地址。



## 树

二叉树：

- 度：结点所拥有的子树的数目称为该节点的度，叶子结点的度为 0。度数为 0 的结点个数比度数为 2 的结点个数多 1，即 $n_0=n_2+1$. 对于完全二叉树， $n_1$ 为 0 或 1.

**❓三层的二叉树有多少种？**



二叉搜索树：中序遍历的序列一定是有序的。

满二叉树：结点数 $2^k-1$，$k$ 为深度

**哈夫曼树（Huffman Tree）**：给定 N 个权值作为 N 个叶子节点，构造一颗二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。

树转换为二叉树：

- 加线：在所有兄弟结点之间加一条连线；
- 抹线：对树中的每一个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；
- 旋转：以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明；

森林转换为二叉树：

- 先把每一棵树转换为二叉树；
- 第一棵二叉树不动，从第二课二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来，不断重复直到所有的二叉树都连接起来；

二叉树转换为树：

- 若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该节点的孩子结点；
- 对每一个结点都用第一个规则进行处理；

二叉树转换为森林：

- 先把每个结点与右孩子结点的连线删除，得到分离的二叉树；
- 把分离后的每颗二叉树转换为树；
- 整理第 2 步得到的树，得到森林；

**前缀树（Trie）**：又称字典树，LeetCode 题目 [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)【中等】

实现 Trie 类：

- `Trie()` 初始化前缀树对象。每个结点包括以下字段：
  - 指向子结点的长度为 26 的指针数组 `children` 每个位置代表对应的小写字母，初始化时全为 `None`；
  - 布尔字段 `isEnd` 表示该节点是否为字符串的结尾；
- 插入字符串：`void insert(String word)` 向前缀树中插入字符串 `word` 。从 Trie 的根开始，对于当前字符：
  - 首先指向 Trie 的根结点 `node = self`：
  - 子结点存在，沿着指针移动到子结点，继续处理下一个字符；
  - 子结点不存在，创建一个新的子结点，记录在 `children` 数组的对应位置上，移动到子结点，继续搜索下一个字符；
- 查找单词：`boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。从 Trie 的根开始，对于当前字符：
- 查找前缀：`boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。从 Trie 的根开始，对于当前字符：
  - 子结点存在：沿着指针移动到子结点，继续搜索下一个字符；
  - 子结点不存在：说明 Trie 中不包含该前缀，返回 `False`；

> 「查找单词」和「查找前缀」的区别就是：
>
> - 对于查找单词，如果末尾字符对应结点的 `isEnd` 为真，那么就代表 Trie 中包含这个单词；
> - 对于查找前缀，如果搜索到前缀的末尾，则说明字典树中存在该前缀；

具体代码参考题解：[Python3：实现字典树（Trie）](https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-strongnine-9-2j0b/)

## 图

拓扑排序：

- 首先选择没有前驱的顶点（入度为 0 的结点），删除与它相关的所有边；
- 继续寻找下一个没有前驱的顶点，删除与它相关的所有边；
- 不断重复这个寻找和删除的步骤。

## 问题

❓连续整数之和为 1000，有几组？
